{"meta":{"title":"Sizaif's Blog","subtitle":"Sizaif的小领地","description":"春江潮水连海平,海上明月共潮生.","author":"sizaif","url":"https://www.sizaif.com","root":"/"},"pages":[{"title":"","date":"2022-01-24T02:17:52.713Z","updated":"2021-08-15T15:35:26.000Z","comments":true,"path":"google16e673252f94d06c.html","permalink":"https://www.sizaif.com/google16e673252f94d06c","excerpt":"","text":"google-site-verification: google16e673252f94d06c.html"},{"title":"所有分类","date":"2021-08-06T15:26:13.000Z","updated":"2021-08-14T16:15:40.000Z","comments":true,"path":"navigation/categories/index.html","permalink":"https://www.sizaif.com/navigation/categories/","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-06T14:20:10.000Z","updated":"2021-08-14T16:15:40.000Z","comments":true,"path":"navigation/tags/index.html","permalink":"https://www.sizaif.com/navigation/tags/","excerpt":"","text":""},{"title":"","date":"2021-08-06T16:01:23.000Z","updated":"2021-08-09T08:19:55.000Z","comments":true,"path":"page/friends/index.html","permalink":"https://www.sizaif.com/page/friends/","excerpt":"相聚短暂，孤独常态。","text":"相聚短暂，孤独常态。 &nbsp;举个栗子&nbsp;前置要求 &nbsp;本站信息 友链格式，除高亮行，其余均可选~- title: # 网站名称 url: # 访问地址 avatar: # 头像地址 description: # 描述/一句话概述/格言 screenshot: # 网站截图/展示图 backgroundColor: # 头像背景颜色 textColor: # 文本颜色 keywords: - 标签一 - 标签二 有实质性原创内容的 HTTPS 站点 合法的、非营利性、无商业广告） 访问地址：https://www.sizaif.com/ 站点名称：Sizaif's Blog 头像地址：https://gitee.com/sizaif/images/raw/master/img/20210807132935.jpeg 描述信息：春江潮水连海平,海上明月共潮生"},{"title":"Clubmanualv1","date":"2021-09-16T03:26:03.000Z","updated":"2022-04-09T05:08:56.000Z","comments":true,"path":"page/clubmanualv1/index.html","permalink":"https://www.sizaif.com/page/clubmanualv1/","excerpt":"","text":"基本镜像说明 [image]:[tag] tag版本号会逐步更新 如果不加版本号的话, 默认使用带有latest的版本( 这里latest并不是最新的意思,而是标记tag为latest 的意思) ubuntu:20.04 V1 使用清华源 已安装基本工具: VIM - Vi IMproved 8.1 (2018 May 18, compiled Apr 15 2020 06:40:31) cmake version 3.16.3 gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) g++ (4:9.3.0-1ubuntu2). wget,git,autoconf,automake,build-essential Python 3.8.10 (default, Jun 2 2021, 10:49:15) pip3 pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) ssh 支持使用filezilla等软件进行ssh传输文件，等价于路径映射 ssh 使用方法： 1. $docker run -dit -p 1112:22 &lt;镜像id> 2. $docker attach &lt;容器id> 3. $ /etc/init.d/ssh start e.g: root@xxx:/home/workhome# $/etc/init.d/ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] 此时远程ssh可正常连接 地址： localhost:1112 用户名：root 密码：123 创建使用此镜像创建容器 # 事例, /home/sizworkhome/ 为要映射的主机文件夹目录 # /home/workhome/ 为容器中要映射的目录 # siztest1 为创建的容器名称 # sizaif2000/ubuntu2004v1:2.0 为远程的镜像名称以及版本 # -p 8080:80 $ docker run -dit -v /home/sizworkhome:/home/workhome --name siztest1 sizaif2000/ubuntu2004v1:2.0 ubuntu:20.04 V2 使用清华源 已安装基本工具: VIM - Vi IMproved 8.1 (2018 May 18, compiled Apr 15 2020 06:40:31) cmake version 3.16.3 gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) g++ (4:9.3.0-1ubuntu2). wget,git,autoconf,automake,build-essential Python 3.8.10 (default, Jun 2 2021, 10:49:15) pip3 pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) new add &gt;&gt; java-jdk1.8.0_291 创建使用此镜像创建容器 # 事例, /home/sizworkhome/ 为要映射的主机文件夹目录 # /home/workhome/ 为容器中要映射的目录 # siztest1 为创建的容器名称 # sizaif2000/ubuntu2004v2:2.0 为远程的镜像名称以及版本 # -p 8080:80 $ docker run -dit -v /home/sizworkhome:/home/workhome --name siztest1 sizaif2000/ubuntu2004v2:2.0 docker 常见基本命令 常用命令 新增说明2.0! 在使用文件夹路径映射后, 需首先进入容器内使用chmod g+wxr /&lt;映射后的文件夹路径&gt; 给组添加权限,否则容器外创建用户会出现没有权限修改映射文件 说明 一: 容器 id 可以由 前三位id 简称代替 e.g: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS f586c498d512 sizaif2000/ubuntu2004v1:1.0 “bash” 14 hours ago Exited (255) 5 minutes ago 则f586c498d512 可以用f58代替, 例如: docker exec -it f58 /bin/bash 二: 带有[xxx] 命令样式的, 输入命令时不需要输入[ ] 查看镜像查看容器创建新的容器启动容器进入容器容器与主机间的数据拷贝删除容器#列出本地images $ docker images #含中间映像层 $ docker images -a#查看正在运行的容器 $ docker ps #查看正在运行+历史运行过的容器 $ docker ps -a #查看正在运行的容器的ID $ docker ps -q #显示运行容器总文件大小 $ docker ps -s新增说明2.0! 在使用文件夹路径映射后, 需首先进入容器内使用chmod g+wxr /&lt;映射后的文件夹路径&gt; 给组添加权限,否则容器外创建用户会出现没有权限修改映射文件 # docker run -dit -p 主机端口:容器中端口 -v 主机中要映射的文件夹绝对目录:容器里映射路径 --name 起个名字 ubuntu:你的镜像tag（默认是latest） # 如果不需要端口映射 就不需要加 -p 参数 # e.g: docker run -dit -v /home/whxiang/workdir:/home/workdir --name whx_test sizaif2000/ubuntu2004v1:1.0 当在进行测试的时候发现一个新的问题: 即组内普通用户创建的文件在容器中因为没有相应的uid:gid 映射, 并且容器中的root用户的权限很低时(组管理员拥有sudo权限,但需要输入sudo才可以; 而容器中时没有sudo命令的,所有说这里的root权限很低)在这种情况下: 就会出现普通用户创建的文件,在容器中被识别为: `nobody ,nogroups 现象 暂时的解决方法 普通用户删除私有组,即让普通用户的主组为(docker容器映射的管理员所在的组)​ 例如: 本文演示小组管理员为siz, 组名为(siz) 则让 普通用户test&lt;xxx&gt; 的主组为siz# 命令: sudo usermod -g &lt;小组管理员名称> &lt;普通用户名称> # 将普通用户的主组从私有组改为小组管理员所在的组 $ sudo usermod -g test1 siz对宿主机(容器外)组成员中普通用户创建的文件或文件夹提升组权限目的: 使容器内root获得对这个文件夹拥有修改(w) 权限 $ chmod g+wxr &lt;xxx>对容器内root 创建的文件或文件夹提升组权限目的: 使宿主机(容器外) 组成员普通用户获得对这个文件夹拥有修改(w) 权限$ chmod g+wxr &lt;xxx>缺陷:当内外创建新的文件和文件夹使, 内外要不断的使用chmod 命令进行授权, $ docker start [container_id]# 常用进入命令 $ docker exec -it [container_id] /bin/bash # 或者使用attach 命令 # 注意!!!! 使用 attach命令时, 须在run创建容器的时候带有 -it 参数, 负责会出现进入容器后无法交互输入命令的情况 $ docker attach [container_id]#将容器中的某个路径下文件copy至主机本地路径 $ docker cp [container_id]:/[container_file_path] [local_path] #将主机文件copy至容器中的某个路径下 $ docker cp [local_file_path] [container_id]:/[container_file_path]/ #将主机文件copy至容器中中的某个路径下，目录重命名为[container_path]（注意与非重命名copy的区别） $ docker cp [local_file_path] [container_id]:/[container_file_path]$ docker rm [container_id] 镜像操作详细 拉取镜像推送镜像删除镜像#下载ubuntu官方最新镜像，相当于：docker pull ubuntu:latest $ docker pull ubuntu #下载仓库所有Redis镜像 $ docker pull -a ubuntu #下载私人仓库镜像 # docker pull dockerUserName/xxxx:tag # e.g: docker pull sizaif2000/ubuntu2004v1:1.0推送前,需要先打包成 dockerUserName/xxx:tag 如果从容器开始推送, 则需要先执行 $ docker commit [container_Id] dockerUserName/xxx:tag 如果从镜像开始推送,则需要执行$ docker tag imageName dockerUserName/xxx[:tag] # 将打包好的镜像推送的dockerhub中 $ docker push dockerUserName/xxx:tag#单个镜像删除，相当于：docker rmi ubuntu:latest $ docker rmi [image_name] #强制删除(针对基于镜像有运行的容器进程) $ docker rmi -f [image_name] #多个镜像删除，不同镜像间以空格间隔 $ docker rmi -f ubuntu tomcat nginx #删除本地全部镜像 $ docker rmi -f $(docker images -q) 容器操作详细 创建新的容器本地目录映射容器端口映射容器进入容器构建镜像删除容器新增说明2.0! 在使用文件夹路径映射后, 需首先进入容器内使用chmod g+wxr /&lt;映射后的文件夹路径&gt; 给组添加权限,否则容器外创建用户会出现没有权限修改映射文件 #新建并启动容器，参数：-i 以交互模式运行容器；-t 为容器重新分配一个伪输入终端; -d 已守护方式启动容器；--name 为容器指定一个名称 # 格式 docker run -dit --name [name] [images]:[tag] $ docker run -dit --name siztest sizaif2000/ubuntu20004v1:1.0 # docker run -dit -p 8080:80 -v /e/windowssrc:容器里映射路径 --name 起个名字 ubuntu:你的镜像tag（默认是latest）顾名思义: 映射本地目录, 即把主机本地目录映射到容器中指定目录中,实现在主机本地修改,在从容器中可同步查看修改 方式: 一般是在创建容器时,设置本地目录映射 创建时映射本地目录 # 格式 -v 主机文件夹目录:容器里映射路径 $ docker run -dit -v /e/windowssrc:/home/workhome --name siztest sizaif2000/ubuntu20004v1:1.0 一问一答 问题一: 如果我已经创建完容器了, 我再想映射本地目录如何实现?答:删掉容器重新创建(如果是刚开始)删除现有的容器重新创建容器查看容器的相信信息对现有容器构建镜像，再从这个镜像重新启动一个新的容器对现有的容器进行保存镜像删除原有的容器通过新镜像,生成新的容器查看新容器的相关配置信息更改现有容器的配置文件修改现有配置需要重启整个docker,会影响到其他正在运行的容器 一问一答 问题三: 我已经创建完容器了并设置了文件夹映射,但我想往这个文件夹里添加文件却提示没有权限怎么回事?答:​ 没有做创建完容器后进入容器,进入到映射后的路径,给这个文件夹赋予组权限(wxr)​ 例如:​ docker run -dit -v /home/siz/test1:/home/siz b19​ 做完映射后, 需执行$ docker attach &lt;新创建容器_id> $ cd /home/siz $ chmod g+wxr ./test1 # 执行完这个过程后, 在容器外的用户才有权限去修改创建文件!!!! 当在进行测试的时候发现一个新的问题: 即组内普通用户创建的文件在容器中因为没有相应的uid:gid 映射, 并且容器中的root用户的权限很低时(组管理员拥有sudo权限,但需要输入sudo才可以; 而容器中时没有sudo命令的,所有说这里的root权限很低)在这种情况下: 就会出现普通用户创建的文件,在容器中被识别为: `nobody ,nogroups 现象 暂时的解决方法 普通用户删除私有组,即让普通用户的主组为(docker容器映射的管理员所在的组)​ 例如: 本文演示小组管理员为siz, 组名为(siz) 则让 普通用户test&lt;xxx&gt; 的主组为siz# 命令: sudo usermod -g &lt;小组管理员名称> &lt;普通用户名称> # 将普通用户的主组从私有组改为小组管理员所在的组 $ sudo usermod -g test1 siz对宿主机(容器外)组成员中普通用户创建的文件或文件夹提升组权限目的: 使容器内root获得对这个文件夹拥有修改(w) 权限 $ chmod g+wxr &lt;xxx>对容器内root 创建的文件或文件夹提升组权限目的: 使宿主机(容器外) 组成员普通用户获得对这个文件夹拥有修改(w) 权限$ chmod g+wxr &lt;xxx>缺陷:当内外创建新的文件和文件夹使, 内外要不断的使用chmod 命令进行授权, 创建时开启端口映射 # 将 容器中的 80端口映射到本地的8080端口 # 格式 -p 8080:80 $ docker run -dit -p 8080:80 --name siztest sizaif2000/ubuntu20004v1:1.0 一问一答 问题二: 如果我已经创建完容器了, 我再想追加端口映射怎么实现?答:删掉容器重新创建(如果是刚开始)删除现有的容器重新创建容器查看容器的相信信息对现有容器构建镜像，再从这个镜像重新启动一个新的容器对现有的容器进行保存镜像删除原有的容器通过新镜像,生成新的容器查看新容器的相关配置信息更改现有容器的配置文件修改现有配置需要重启整个docker,会影响到其他正在运行的容器 #使用run方式在创建时进入 $ docker run -it centos /bin/bash #关闭容器并退出 $ exit #仅退出容器，不关闭 # 快捷键：Ctrl + P + Q #直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false 确保CTRL-D或CTRL-C不会关闭容器 $ docker attach --sig-proxy=false centos #在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i 即使没有附加也保持STDIN 打开；-t 分配一个伪终端 $ docker exec -i -t centos /bin/bash #以交互模式在容器中执行命令，结果返回到当前终端屏幕 $ docker exec -i -t centos ls -l /tmp #以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端 $ docker exec -d centos touch cache.txt # 常用进入命令 $ docker exec -it [container_id] /bin/bash # 或者 使用attach 命令 # 注意!!!! 使用 attach命令时, 须在run创建容器的时候带有 -it 参数, 负责会出现进入容器后无法交互输入命令的情况 $ docker attach [container_id]# 注：containerId为需要打包的容器id， # imagename 为 打包的镜像名称;可添加tag参数, 例如 testv1:1.0 $ docker commit [container_Id] imagename#停止一个运行中的容器 $ docker stop redis #杀掉一个运行中的容器 $ docker kill redis #删除一个已停止的容器 $ docker rm redis #删除一个运行中的容器 $ docker rm -f redis #删除多个容器 $ docker rm -f $(docker ps -a -q) $ docker ps -a -q | xargs docker rm # -l 移除容器间的网络连接，连接名为 db $ docker rm -l db # -v 删除容器，并删除容器挂载的数据卷 $ docker rm -v redis 修订历史 2021-09-23 修复映射文件夹路径权限问题 修复日志 2021-09-17 构建基础镜像ubuntu2004v2:2.0版本构建基础镜像ubuntu2004v1:2.0版本添加基础镜像latest版本增加启动镜像 2021-09-16 添加第一版手册"},{"title":"","date":"2021-08-06T15:58:57.000Z","updated":"2021-09-20T01:12:03.000Z","comments":true,"path":"page/about/index.html","permalink":"https://www.sizaif.com/page/about/","excerpt":"","text":"About Me 关于我统计占位自我评价 热爱生活，热爱技术 默默的程序猿，默默的做事 探索，查找，分享 … 说点什么 简单的记录分享科研探索中遇到的问题以及可能的相关解决方法. 分享+1 == 快乐+1 == 收获+1; 闭门造车+1 == 自闭+1 == 快乐-n 联系方式 echo \"c2l6YWlmMjAwMEBnbWFpbC5jb20Kc2l6YWlmMjAwMEAxNjMuY29t\" | base64 -d 春江花月夜 张若虚 春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰； 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年望相似。 不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月裴回，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。"},{"title":"Hexo_typora_ahk_bak","date":"2021-11-24T13:34:29.000Z","updated":"2021-11-24T13:39:49.000Z","comments":true,"path":"page/hexo_typora_ahk_bak/index.html","permalink":"https://www.sizaif.com/page/hexo_typora_ahk_bak/","excerpt":"","text":"; Typora ; 快捷设置兼容hexo格式 ; SendInput &#123;Text&#125; 解决中文输入法问题 #IfWinActive ahk_exe Typora.exe &#123; ; ctrl+1 tab ^1::addtabcode() ; ctrl+2 note ^2::addnotecode() ; ctrl+3 folding ^3::addfoldingcode() ; ctrl+4 link ^4::addlinkcode() ; ctrl+5 span ^5::addspancode() ; ctrl+6 radio ^6::addradiocode() ; Alt+1 橙色 !1::addFontColor(\"orange\") ; Alt+2 红色 !2::addFontColor(\"red\") ; Alt+3 浅蓝色 !3::addFontColor(\"cornflowerblue\") ; Alt+4 棕色 !4::addFontColor(\"brown\") ; Alt+5 绿色 !5::addFontColor(\"green\") ; Alt+6 紫色 !6::addFontColor(\"purple\") &#125; ; 快捷设置tab addtabcode()&#123; clipboard := \"&#123;% tabs tab-id %&#125;`n`t&lt;!-- tab 1 -->`nreplace`n&lt;!-- endtab -->`n&lt;!-- tab 2 -->`nreplace`n&lt;!-- endtab -->`n&#123;% endtabs %&#125;\" Send ^v return &#125; ; 快捷设置note addnotecode()&#123; clipboard := \"&#123;% note danger:: note error/danger %&#125;`n&#123;% note success:: note done/success %&#125;\" Send ^v return &#125; ; 快捷设置folding addfoldingcode()&#123; clipboard := \"&#123;% folding green:: code %&#125;`n&#123;% endfolding %&#125;\" Send ^v return &#125; ; 快捷设置link addlinkcode()&#123; clipboard := \"&#123;% link title:: link %&#125;\" Send ^v return &#125; ; 快捷设置span addspancode()&#123; clipboard := \"&#123;% span parm:: txt %&#125;\" Send ^v return &#125; ; 快捷设置radio addradiocode()&#123; clipboard := \"&#123;% radio green checked:: text %&#125;\" Send ^v return &#125; ; 快捷增加字体颜色 addFontColor(color)&#123; clipboard := \"\" ; 清空剪切板 Send &#123;ctrl down&#125;c&#123;ctrl up&#125; ; 复制 SendInput &#123;TEXT&#125;&lt;font color='%color%'> SendInput &#123;ctrl down&#125;v&#123;ctrl up&#125; ; 粘贴 If(clipboard = \"\")&#123; SendInput &#123;TEXT&#125;&lt;/font> ; Typora 在这不会自动补充 &#125;else&#123; SendInput &#123;TEXT&#125;&lt;/ ; Typora中自动补全标签 &#125; &#125;"},{"title":"建 站 史","date":"2021-08-07T05:00:34.000Z","updated":"2021-09-20T01:36:46.000Z","comments":true,"path":"page/history/index.html","permalink":"https://www.sizaif.com/page/history/","excerpt":"","text":"2021-09-20 修复每日说说界面 2021-09-19 添加暗黑模式,右键点击切换图片由png切换为webp,增加访问速度 2021-09-17 增加阅读模式简化背景图样式重构 2021-08-16 css优化,博文标题居中标签和归档整合到归档中 2021-08-14 尝试使用CDN加速将首页gitee图床背景图更换到本地,加快加载速度大量使用本地图片 2021-08-14 使用hexo-abbrlink插件,修改文章链接地址唯一 2021-08-13 更换评论系统由 valine 更换为 Waline, 增加图片上传功能 2021-08-10 部分博客从CSDN搬运过来 2021-08-09 图标样式修改 fas-&gt;fad添加友链(小伙伴界面)添加留言板功能添加每日心情(说说)功能添加关于(我) 界面 2021-08-08 配置代码高亮,代码背景块颜色绑定域名到 www.sizaif.com 2021-08-07 第一次建站采用 Volantis5.0.alpha 主题"},{"title":"","date":"2021-08-07T02:43:15.000Z","updated":"2021-08-09T09:00:36.000Z","comments":true,"path":"page/messages/index.html","permalink":"https://www.sizaif.com/page/messages/","excerpt":"","text":"请遵守相关法律法规，文明灌水，谢谢合作~"},{"title":"More","date":"2021-08-06T16:08:12.000Z","updated":"2021-08-07T01:18:25.000Z","comments":true,"path":"page/more/index.html","permalink":"https://www.sizaif.com/page/more/","excerpt":"","text":""},{"title":"笔记","date":"2021-08-06T15:48:11.000Z","updated":"2022-01-18T03:55:23.000Z","comments":true,"path":"page/notes/index.html","permalink":"https://www.sizaif.com/page/notes/","excerpt":"","text":"keyboard: 右键注册表备份vscode_bakhexo-typora_ahk_bak微软小鹤双拼 每周计划WIFI&WPA34G&5G LTE状态机学习TLS差分测试IOT 2022-01-01 -&gt; 2021-01-30 -&gt; 项目合作&amp;&amp;论文 项目：第三阶段计划&amp;4G&amp;5G A Comprehensive Formal Analysis of 5G Handover SCOPE_ An Open and Soft warized Prototyping Platform for NextG Systems 计划&amp;状态机 Coverage-guided binary fuzzing with rev.ng and llvm libfuzzer 模型学习与符号执行结合的安全协议代码分析技术 FlexTLS A Tool for Testing TLS Implementations EPF_ An Evolutionary, Protocol-Aware, and Coverage-Guided Network Fuzzing Framework Fuzzing the Internet of Things_ A Review on the Techniques and Challenges for Efficient Vulnerability Discovery in Embedded Systems ProXray_ Protocol Model Learning and Guided Firmware Analysis Reviewing IoT Security via Logic Bugs in IoT Platforms and Systems 整理&amp;完成： StateAFL: Greybox Fuzzing for Stateful Network Servers 基于模型检测的TLS协议实现库安全性分析 面向未知协议的流量识别技术研究_王旭东 模糊测试技术综述 2021-12-01 -&gt; 2021-12-30 -&gt; 项目合作&amp;&amp;论文 项目：第二阶段4G&amp;5G A Comprehensive Formal Analysis of 5G Handover Anonymous Device Authorization for Cellular Networks A Nationwide Census on WiFi Security Threats_ Prevalence, Riskiness, and the Economics CellScope_ Automatically Specifying and Verifying Cellular Network Protocols Discovering Emergency Call Pitfalls for Cellular Networks with Formal Methods Data-Plane Signaling in Cellular IoT_ Attacks and Defense DoLTEst In-depth Downlink Negative Testing Framework for LTE Devices Insecurity of Operational Cellular IoT Service_ New Vulnerabilities, Attacks, and Countermeasures Look Before You Leap_ Secure Connection Bootstrapping for 5G Networks to Defend Against Fake Base-Stations LTrack Stealthy Tracking of Mobile Phones in LTE SecureSIM_ Rethinking Authentication and Access Control for SIM_eSIM Security and privacy for 6G_ A survey on prospective technologies and challenges SCOPE_ An Open and Soft warized Prototyping Platform for NextG Systems Watching the Watchers Practical Video Identification Attack in LTE Networks 状态机： StateAFL: Greybox Fuzzing for Stateful Network Servers HVLearn_Automated_Black-Box_Analysis_of_Hostname_Verification_in_SSL_TLS_Implementations Combining Model Learning and Model Checking to Analyze TCP Implementations 2021-11-06 -&gt; 2021-11-30 -&gt; 项目合作 4G&amp;5G Noncompliance as Deviant Behavior_ An Automated Black-box Noncompliance Checker for 4G LTE Cellular Devices (DIKEUE) 5Greplay_ a 5G Network Traffic Fuzzer - Application to Attack Injection 5Greplay代码项目跟进 MMT-DPI NAS TS 24.501 协议规范 2021-10-29 -&gt; 2021-11-05 4G&amp;5G Nori: Concealing the Concealed Identifier in 5G 2021-10-23 -&gt; 2021-10-29 4G&amp;5G 5Greplay_ a 5G Network Traffic Fuzzer - Application to Attack Injection Secure Open Fronthaul Interface for 5G Networks Nori: Concealing the Concealed Identifier in 5G 2021-10-16 -&gt; 2021-10-22 IOT: Rise of the Machines On the Security of Cellular IoT Devices master thesis TLS差分测试 SADT_ Syntax-Aware Differential Testing of Certificate Validation in SSL_TLS Implementations Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations 计划 A Chosen Random Value Attack on WPA3 SAE authentication protocol 2019-801 Active Dictionary Attack on WPA3-SAE Cryptanalysis of the Dragonfly key exchange protocol Dragonblood_ Analyzing the DragonflyHandshake of WPA3 and EAP-pwd Model based fuzzing of the WPA3 Dragonfly handshake master thesis On the Provable Security of the Dragonfly Protocol Simultaneous Deauthentication of Equals Attack 2021-11-06 -&gt; 2021-11-19 4G&amp;5G 5Greplay_ a 5G Network Traffic Fuzzer - Application to Attack Injection 5Greplay代码项目跟进 MMT-DPI NAS TS 24.501 协议规范 5G系统架构5GS TS 23.501 协议规范 5G核心网5GC TS 23.502 协议规范 2021-10-29 -&gt; 2021-11-05 4G&amp;5G Nori: Concealing the Concealed Identifier in 5G 2021-10-23 -&gt; 2021-10-29 4G&amp;5G 5Greplay_ a 5G Network Traffic Fuzzer - Application to Attack Injection Secure Open Fronthaul Interface for 5G Networks Nori: Concealing the Concealed Identifier in 5G 2021-10-09 -&gt; 2021-10-15 比较对比两篇文献 Touching the Untouchables_ Dynamic Security Analysis of the LTE Control Plane Berserker ASN.1-based Fuzzing of Radio Resource Control Protocol for 4G and 5G 测试MAC协议: Fuzzing Radio Resource Control messages in 5G and LTE systems master thesis 使用深度学习与fuzzer结合起来测试工业以太网: SeqFuzzer_ An Industrial Protocol Fuzzing Framework from a Deep Learning Perspective 2021-09-17 -&gt; 2021-09-24 基于srsLTE(特定版本)修改rrc.c文件代码 CSAI: Open-Source Cellular Radio Access Network Security Analysis Instrument srsRAN https://github.com/srsran/srsRAN 2021-09-05 -&gt; 2021-09-24 总结LTE相关攻击;汇总成PPT报告. 2021-08-20 -&gt; 2021-08-31 小组行动小组行动:王 :Breaking LTE on Layer Two三种攻击方式:(被动攻击)身份映射攻击:将TMSI与RNTI匹配(被动攻击)网站指纹识别: (有限)识别网站访问(主动攻击)LTE用户数据操纵:(有限) DNS污染重定向杨:Bookworm Game Automatic Discovery of LTE Vulnerabilities Through Documentation An赵 :Touching the Untouchables_ Dynamic Security Analysis of the LTE Control Plane 2021-08-13 -&gt; 2021-08-20 形式化分析,从消息日志中提取构建有限状态机模型,使用NuXmv做模型检查和ProVerif做协议验证,从而发现漏洞 ProChecker-An-Automated-Security-and-Privacy-Analysis-Framework-for-4G-LTE-Protocol-Implementations 2021-08-07 -&gt; 2021-08-13 构建一个测试平台LEFT, 采用三种模糊方法: 黑盒测试,威胁模型感知模糊,RL引导模糊;采用客户端-服务器端架构,测试机密性,可用性,来验证LEFT平台的可用性 Emulation-Instrumented Fuzz Testing of 4G_LTE Android Mobile Devices Guided by Reinforcement Learning 2021-08-01 -&gt; 2021-08-06 对RRC消息进行消息内容/模式进行修改,进行模糊测试: Berserker ASN.1-based Fuzzing of Radio Resource Control Protocol for 4G and 5G 2021-07-23 -&gt; 2021-07-30 分配属性构建模型,做模型检查,检测LTE部署中的安全漏洞 On the Challenges of Automata Reconstruction in LTE Networks 2021-12-01 -&gt; 2021-12-02 ProFuzzBench/StateAFL A Greybox Fuzzer for Network Protocols ProFuzzBench: A Benchmark for Stateful Protocol Fuzzing StateAFL: Greybox Fuzzing for Stateful Network Servers 2021-07-11 -&gt; 2021-07-17 ProFuzzBench/AFLnet&amp;AFLnwe AFLNET: A Greybox Fuzzer for Network Protocols American fuzzy lop 2021-05-28 -&gt; 2021-06-11 TLS-Attacker Protocol state fuzzing of TLS implementations Analysis of DTLS Implementations Using Protocol State Fuzzing 2021-05-20 -&gt; 2021-05-27 改进计划第一次尝试 Protocol state fuzzing of TLS implementations Analysis of DTLS Implementations Using Protocol State Fuzzing 47 Systematic Fuzzing and Testing of TLS Libraries 2021-05-17 -&gt; 2021-05-20 IPSec_VPN安全性漏洞分析及验证_周益旻 2021-04-30 -&gt; 2021-05-17 了解TLS&amp;DTLS Protocol state fuzzing of TLS implementations Analysis of DTLS Implementations Using Protocol State Fuzzing 2021-04-23 -&gt; 2021-04-30 初识状态机 45 基于L_学习算法的安全协议自适应模型检测技术研究 基于模型学习的OpenVPN系统脆弱性分析 64 Model Learning and Model Checking of IPSec Implementations for Internet of Things 基于L学习算法的安全协议自适应模型检测技术研究检测 46 A Tale of the OpenSSL State Machine A Large-Scale Black-Box Analysis 51 Model Learning and Model Checking of SSH Implementations 47 Systematic Fuzzing and Testing of TLS Libraries 2021-10-16 -&gt; 2021-10-22 TLS协议.X.509证书,差分模糊测试:对证书结构内容修改 Using Frankencerts for Automated Adversarial Testing of Certificate Validation in SSL/TLS Implementations 对证书编码后DER内容进行修改 SADT: Syntax-Aware Differential Testing of Certificate Validation in SSL/TLS Implementations 2021-06-24 -&gt; 2021-07-01 TLS握手协议 ClientHello消息,差分模糊测试: Towards Fuzzing-Based Differential Black-Box Testing of TLS Implementations 2021-10-16 -&gt; 2021-10-22 Rise of the Machines On the Security of Cellular IoT Devices master thesis 2021-09-17 -&gt; 2021-09-24 王: A framework for automating security analysis of the internet of things On the automation of security testing for IoT constrained scenarios 杨: Automated Analysis of Secure Internet of Things Protocols"},{"title":"Vscode_bak","date":"2021-11-06T07:13:59.000Z","updated":"2021-11-06T07:15:16.000Z","comments":true,"path":"page/vscode_bak/index.html","permalink":"https://www.sizaif.com/page/vscode_bak/","excerpt":"","text":"sizaif.json.code-snippets &#123; // Place your 全局 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is // used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. // Placeholders with the same ids are connected. // Example: // \"Print to console\": &#123; // \"scope\": \"javascript,typescript\", // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // &#125; \"Print to method1\": &#123; \"scope\": \"java,c,h,cpp\", \"prefix\": \"start\", \"body\": [ \"/**\", \" * @Author: sizaif\", \" * @Date: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;\", \" * @Description: $0\", \" * ***********\", \" * start\", \" * ***********\", \"* */\" ], \"description\": \"注释，start\" &#125;, \"Print to method2\": &#123; \"scope\": \"java,c,h,cpp\", \"prefix\": \"end\", \"body\": [ \"/**\", \" * @Author: sizaif\", \" * @Date: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;\", \" * @Description: $0\", \" * ***********\", \" * end\", \" * ***********\", \"* */\" ], \"description\": \"注释，end\" &#125;, \"Print to method3\": &#123; \"scope\": \"java,c,h,cpp\", \"prefix\": \"ann\", \"body\": [ \"/**\", \" * @Author: sizaif\", \" * @Date: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;\", \" * @Description: $0\", \"* */\" ], \"description\": \"注释\" &#125; &#125;"},{"title":"Reg_bak","date":"2021-11-06T07:01:30.000Z","updated":"2021-11-06T07:03:25.000Z","comments":true,"path":"page/reg_bak/index.html","permalink":"https://www.sizaif.com/page/reg_bak/","excerpt":"","text":"Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Item0] \"MUIVerb\"=\"sizaif\" \"SubCommands\"=\"Item0;Item1;Item2\" \"Icon\"=\"imageres.dll,193\" \"Position\"=\"top\" [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Item0] \"MUIVerb\"=\"此处打开mintty\" \"Icon\"=\"C:\\\\cygwin64\\\\bin\\\\mintty.exe ,0\" [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Item0\\command] @=\"C:\\\\cygwin64\\\\bin\\\\mintty.exe -e /bin/bash --login -i -c \\\"cd '%V';exec bash\" [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Item1] \"MUIVerb\"=\"此处打开IDEA\" \"Icon\"=\"Q:\\\\fast_software\\\\IntelliJ IDEA 2021.2\\\\bin\\\\idea64.exe,0\" [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Item1\\command] @=\"\\\"Q:\\\\fast_software\\\\IntelliJ IDEA 2021.2\\\\bin\\\\idea64.exe\\\" \\\"%V%\\\"\" [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Item2] \"MUIVerb\"=\"此处打开Pycharm\" \"Icon\"=\"Q:\\\\PyCharm 2021.2\\\\bin\\\\pycharm64.exe,0\" [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Item2\\command] @=\"\\\"Q:\\\\PyCharm 2021.2\\\\bin\\\\pycharm64.exe\\\" \\\"%V%\\\"\""},{"title":"","date":"2021-08-07T14:36:59.000Z","updated":"2021-09-20T01:32:03.000Z","comments":true,"path":"page/shuoshuo/index.html","permalink":"https://www.sizaif.com/page/shuoshuo/","excerpt":"","text":""},{"title":"Wiki","date":"2021-08-06T15:47:59.000Z","updated":"2021-08-06T15:47:59.000Z","comments":true,"path":"page/wiki/index.html","permalink":"https://www.sizaif.com/page/wiki/","excerpt":"","text":""},{"title":"Xnheulpb","date":"2021-12-02T02:21:52.000Z","updated":"2021-12-02T02:22:54.000Z","comments":true,"path":"page/xnheulpb/index.html","permalink":"https://www.sizaif.com/page/xnheulpb/","excerpt":"","text":"Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\InputMethod\\Settings\\CHS] \"EnableExtraDomainType\"=dword:00000001 \"Enable Double Pinyin\"=dword:00000001 \"DoublePinyinScheme\"=dword:0000000a \"UserDefinedDoublePinyinScheme0\"=\"flypy*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt\""}],"posts":[{"title":"LLVM -Learn-Work3","slug":"LLVM-Learn-Work3","date":"2022-05-03T14:10:28.000Z","updated":"2022-05-03T14:15:53.000Z","comments":true,"path":"posts/4ebd022f/","link":"","permalink":"https://www.sizaif.com/posts/4ebd022f/","excerpt":"","text":"LLVM -Learn-Work3 @2022-05-03 18:54:36 @sizaif Work3：插入一个函数并调用。函数用于检查加法结果，如果大于 100，则取 余 100。此函数会修改加法结果。(函数操作) //main.c #define _GNU_SOURCE #include &lt;stdio.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;stdlib.h> int main() &#123; puts(\"plz input two numbers\"); size_t bufsize = 100; char* buf = malloc(bufsize); getline(&amp;buf, &amp;bufsize, stdin); double f1 = atof(buf); getline(&amp;buf, &amp;bufsize, stdin); double f2 = atof(buf); printf(\"%.2f + %.2f = %.2f \\n\", f1, f2, f1+f2); free(buf); return 0; &#125; 一) 思路 第一种一种思路： 创建一个全局变量fdd_res, 添加store指令， 将fadd指令的结果存储到全局变量中， 构造函数，读取全局变量的值，如果大于100，则对100取余，否则什么都不做 修改printf函数第三个参数为全局变量fadd_res 第二种一种思路： 构造函数work_fn，其函数传参(fadd)的结果值 函数拿到其值，做取余操作，并返回结果 主函数存储work_fn返回结果，并修改printf函数的参数。 二) 思路一执行 2.1) 读取IR LLVMContext context; IRBuilder&lt;> builder(context); std::unique_ptr&lt;Module> M; std::unique_ptr&lt;MIRParser> MIR; SMDiagnostic Err; /** * #include \"llvm/IRReader/IRReader.h\" * 2022-04-26 03:04:32 * TODO: * from IR file get Moudle class * */ M = parseIRFile(StringRef(argv[1]),Err,context); if(M)&#123; std::cout&lt;&lt;\"debug: M is not null\"&lt;&lt;std::endl; // M->print(llvm::outs(),nullptr); &#125; else&#123; std::cout&lt;&lt;\"M is null\"&lt;&lt;std::endl; Err.print(argv[0],errs()); &#125; 2.2) 找到fadd指令与fadd后一个指令 /** * 2022-04-26 03:25:52 * TODO: * 获取main函数 * */ auto main_fn = M->getFunction(StringRef(\"main\")); /** * 2022-04-28 02:14:46 * TODO: * 找到fadd指令,与fadd的后一个指令 * */ Instruction *in_fadd,*in_prt; for (inst_iterator I = inst_begin(*main_fn), E = inst_end(*main_fn); I != E; ++I)&#123; if(I->isBinaryOp() &amp;&amp; I->getOpcode()==Instruction::FAdd)&#123; // outs() &lt;&lt; *I &lt;&lt; \"\\n\"; in_fadd = &amp;*I; in_prt = &amp;*(I.operator++()); &#125; &#125; 2.3) 创建全局变量，添加必要的指令 /** * 2022-04-28 02:42:32 * TODO: * %20 = load double, double* %5, align 8 * %21 = fadd double %19, %20 * 1. 创建全局变量fadd_res * 2. 存入常量100 * 3. 将ADD结果存入内存中 * */ auto f32 = builder.getDoubleTy(); // 创建初始值0与100 auto const_100 = ConstantFP::get(f32,double(100)); auto const_0 = ConstantFP::get(f32,double(0)); auto in_alloc02 = new GlobalVariable(*M, f32, false, GlobalValue::PrivateLinkage, const_0, \"fadd_res\"); // 设置对齐方式 in_alloc02->setAlignment(MaybeAlign(8)); // 插入基本指令，将FADD结果,存到fadd_res中 builder.SetInsertPoint(in_prt); auto in_alloc01 = builder.CreateAlloca(f32,0,\"ina1\"); auto in_store01 = builder.CreateStore(const_100,in_alloc01); auto in_store02 = builder.CreateStore(in_fadd,in_alloc02); 2.4) 构造函数读取结果进行修改 /** * 2022-05-03 16:33:58 * TODO: * 新建一个函数: * void work03_fn()&#123; * if(fdd_res > 100) * fdd_res = fdd_res %100; * &#125; * */ // 创建函数 auto fn_prototype = FunctionType::get(builder.getVoidTy(), true); auto work03_fn = Function::Create(fn_prototype, Function::ExternalLinkage, \"work03_fn\", M.get()); // 创建基本块 auto work03_fn_defaut= BasicBlock::Create(context, \"work03_fn_defaut\", work03_fn); auto work03_fn_change = BasicBlock::Create(context, \"work03_fn_change\", work03_fn); auto work03_fn_nothing = BasicBlock::Create(context, \"work03_fn_nothing\", work03_fn); // 默认基本块 指令操作 builder.SetInsertPoint(work03_fn_defaut); auto work03_de_load_01 = builder.CreateLoad(f32,in_alloc02); auto work03_de_fcmp_01 = builder.CreateFCmpUGT(work03_de_load_01,const_100); auto work03_de_br_01 = builder.CreateCondBr(work03_de_fcmp_01, work03_fn_change, work03_fn_nothing); // 取余 指令操作 builder.SetInsertPoint(work03_fn_change); auto work03_ch_load_01 = builder.CreateLoad(f32,in_alloc02); auto work03_ch_frem_01 = builder.CreateFRem(work03_ch_load_01,const_100); auto work03_ch_store_01 = builder.CreateStore(work03_ch_frem_01,in_alloc02); builder.CreateRetVoid(); // 第三个基本块什么都不做 builder.SetInsertPoint(work03_fn_nothing); builder.CreateRetVoid(); 2.5) 修改printf参数 /** * 2022-05-03 18:27:56 * TODO: * 在调用prtinf 函数之前插入调用函数指令 * 以及读取fadd_res, 修改printf 第三个参数 * */ builder.SetInsertPoint(in_prt); builder.CreateCall(work03_fn); auto in_load03 = builder.CreateLoad(f32,in_alloc02); in_prt->setOperand(3,in_load03); 2.6) Module验证与存到文件 /** * #include \"llvm/IR/Verifier.h\" * 2022-05-02 11:43:34 * TODO: * 修改完Module后进行验证Module的完整性 * verifyModule(*M,&amp;errs()): true if the module is broken. * */ if(!llvm::verifyModule(*M,&amp;errs()))&#123; outs()&lt;&lt;\"debug: Module verify is ok \\n\"; M->print(outs(),nullptr); &#125; /** * #include \"llvm/Bitcode/BitcodeWriter.h\" * 2022-05-03 12:55:33 * TODO: * 将修改后的IR 存储到文件中， 执行 * */ std::error_code EC; llvm::raw_fd_ostream OS(\"aftermain.bc\", EC,llvm::sys::fs::OpenFlags()); llvm::WriteBitcodeToFile(*M,OS,true); OS.flush(); 2.7) 全部源码 /** * 2022-05-03 16:16:19 * sizaif * Work3：插入一个函数并调用。函数用于检查加法结果，如果大于 100，则取余 100。此函数会修改加法结果。(函数操作) * clang++ $(llvm-config --cxxflags --ldflags --system-libs --libs) -o main main.cpp * ./main main.ll * lli aftermain.bc * */ #include \"llvm/Transforms/Utils/BasicBlockUtils.h\" #include &lt;llvm/IR/IRBuilder.h> #include \"llvm/IR/LLVMContext.h\" #include \"llvm/IR/Module.h\" #include \"llvm/IR/InstIterator.h\" #include \"llvm/IR/Instruction.h\" #include \"llvm/IR/Instructions.h\" #include \"llvm/IR/InstrTypes.h\" #include \"llvm/IR/Verifier.h\" #include \"llvm/IRReader/IRReader.h\" #include \"llvm/CodeGen/MIRParser/MIRParser.h\" #include \"llvm/Support/InitLLVM.h\" #include \"llvm/Support/Debug.h\" #include \"llvm/Support/TargetSelect.h\" #include \"llvm/Support/SourceMgr.h\" #include &lt;llvm/Support/raw_os_ostream.h> #include \"llvm/Bitcode/BitcodeWriter.h\" #include &lt;iostream> #include &lt;string> #include &lt;fstream> #include &lt;cstdio> using namespace llvm; int main(int argc,char **argv)&#123; LLVMContext context; IRBuilder&lt;> builder(context); std::unique_ptr&lt;Module> M; std::unique_ptr&lt;MIRParser> MIR; SMDiagnostic Err; /** * #include \"llvm/IRReader/IRReader.h\" * 2022-04-26 03:04:32 * TODO: * from IR file get Moudle class * */ M = parseIRFile(StringRef(argv[1]),Err,context); if(M)&#123; std::cout&lt;&lt;\"debug: M is not null\"&lt;&lt;std::endl; // M->print(llvm::outs(),nullptr); &#125; else&#123; std::cout&lt;&lt;\"M is null\"&lt;&lt;std::endl; Err.print(argv[0],errs()); &#125; /** * 2022-04-26 03:25:52 * TODO: * 获取main函数 * */ auto main_fn = M->getFunction(StringRef(\"main\")); /** * 2022-04-28 02:14:46 * TODO: * 找到fadd指令,与fadd的后一个指令 * */ Instruction *in_fadd,*in_prt; for (inst_iterator I = inst_begin(*main_fn), E = inst_end(*main_fn); I != E; ++I)&#123; if(I->isBinaryOp() &amp;&amp; I->getOpcode()==Instruction::FAdd)&#123; // outs() &lt;&lt; *I &lt;&lt; \"\\n\"; in_fadd = &amp;*I; in_prt = &amp;*(I.operator++()); &#125; &#125; /** * 2022-04-28 02:42:32 * TODO: * %20 = load double, double* %5, align 8 * %21 = fadd double %19, %20 * 1. 创建全局变量fadd_res * 2. 存入常量100 * 3. 将ADD结果存入内存中 * */ auto f32 = builder.getDoubleTy(); auto const_100 = ConstantFP::get(f32,double(100)); // 创建初始值0 auto const_0 = ConstantFP::get(f32,double(0)); auto in_alloc02 = new GlobalVariable(*M,f32,false,GlobalValue::PrivateLinkage,const_0,\"fadd_res\"); // 设置对齐方式 in_alloc02->setAlignment(MaybeAlign(8)); // 插入基本指令，将FADD结果,存到fadd_res中 builder.SetInsertPoint(in_prt); auto in_alloc01 = builder.CreateAlloca(f32,0,\"ina1\"); auto in_store01 = builder.CreateStore(const_100,in_alloc01); auto in_store02 = builder.CreateStore(in_fadd,in_alloc02); /** * 2022-05-03 16:33:58 * TODO: * 新建一个函数: * void work03_fn()&#123; * if(fdd_res > 100) * fdd_res = fdd_res %100; * &#125; * */ // 创建函数 auto fn_prototype = FunctionType::get(builder.getVoidTy(), true); auto work03_fn = Function::Create(fn_prototype,Function::ExternalLinkage,\"work03_fn\",M.get()); // 创建基本块 auto work03_fn_defaut= BasicBlock::Create(context, \"work03_fn_defaut\", work03_fn); auto work03_fn_change = BasicBlock::Create(context, \"work03_fn_change\", work03_fn); auto work03_fn_nothing = BasicBlock::Create(context, \"work03_fn_nothing\", work03_fn); // 默认基本块 指令操作 builder.SetInsertPoint(work03_fn_defaut); auto work03_de_load_01 = builder.CreateLoad(f32,in_alloc02); auto work03_de_fcmp_01 = builder.CreateFCmpUGT(work03_de_load_01,const_100); auto work03_de_br_01 = builder.CreateCondBr(work03_de_fcmp_01,work03_fn_change,work03_fn_nothing); // 取余 指令操作 builder.SetInsertPoint(work03_fn_change); auto work03_ch_load_01 = builder.CreateLoad(f32,in_alloc02); auto work03_ch_frem_01 = builder.CreateFRem(work03_ch_load_01,const_100); auto work03_ch_store_01 = builder.CreateStore(work03_ch_frem_01,in_alloc02); builder.CreateRetVoid(); // 第三个基本块什么都不做 builder.SetInsertPoint(work03_fn_nothing); builder.CreateRetVoid(); /** * 2022-05-03 18:27:56 * TODO: * 在调用prtinf 函数之前插入调用函数指令 * 以及读取fadd_res, 修改printf 第三个参数 * */ builder.SetInsertPoint(in_prt); builder.CreateCall(work03_fn); auto in_load03 = builder.CreateLoad(f32,in_alloc02); in_prt->setOperand(3,in_load03); // M->print(outs(),nullptr); /** * #include \"llvm/IR/Verifier.h\" * 2022-05-02 11:43:34 * TODO: * 修改完Module后进行验证Module的完整性 * verifyModule(*M,&amp;errs()): true if the module is broken. * */ if(!llvm::verifyModule(*M,&amp;errs()))&#123; outs()&lt;&lt;\"debug: Module verify is ok \\n\"; // M->print(outs(),nullptr); &#125; /** * #include \"llvm/Bitcode/BitcodeWriter.h\" * 2022-05-03 12:55:33 * TODO: * 将修改后的IR 存储到文件中， 执行 * */ std::error_code EC; llvm::raw_fd_ostream OS(\"aftermain.bc\", EC,llvm::sys::fs::OpenFlags()); llvm::WriteBitcodeToFile(*M,OS,true); OS.flush(); return 0; &#125; 2.8) 效果 修改后IR如下： ./main main.ll debug: M is not null debug: Module verify is ok ; ModuleID = 'main.ll' source_filename = \"t.c\" target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-unknown-linux-gnu\" %struct._IO_FILE = type &#123; i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, %struct._IO_codecvt*, %struct._IO_wide_data*, %struct._IO_FILE*, i8*, i64, i32, [20 x i8] &#125; %struct._IO_marker = type opaque %struct._IO_codecvt = type opaque %struct._IO_wide_data = type opaque @.str = private unnamed_addr constant [22 x i8] c\"plz input two numbers\\00\", align 1 @stdin = external dso_local global %struct._IO_FILE*, align 8 @.str.1 = private unnamed_addr constant [21 x i8] c\"%.2f + %.2f = %.2f \\0A\\00\", align 1 @fadd_res = private global double 0.000000e+00, align 8 ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 = alloca i32, align 4 %2 = alloca i64, align 8 %3 = alloca i8*, align 8 %4 = alloca double, align 8 %5 = alloca double, align 8 store i32 0, i32* %1, align 4 %6 = call i32 @puts(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str, i64 0, i64 0)) store i64 100, i64* %2, align 8 %7 = load i64, i64* %2, align 8 %8 = call noalias i8* @malloc(i64 noundef %7) #4 store i8* %8, i8** %3, align 8 %9 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8 %10 = call i64 @getline(i8** noundef %3, i64* noundef %2, %struct._IO_FILE* noundef %9) %11 = load i8*, i8** %3, align 8 %12 = call double @atof(i8* noundef %11) #5 store double %12, double* %4, align 8 %13 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8 %14 = call i64 @getline(i8** noundef %3, i64* noundef %2, %struct._IO_FILE* noundef %13) %15 = load i8*, i8** %3, align 8 %16 = call double @atof(i8* noundef %15) #5 store double %16, double* %5, align 8 %17 = load double, double* %4, align 8 %18 = load double, double* %5, align 8 %19 = load double, double* %4, align 8 %20 = load double, double* %5, align 8 %21 = fadd double %19, %20 %ina1 = alloca double, align 8 store double 1.000000e+02, double* %ina1, align 8 store double %21, double* @fadd_res, align 8 call void (...) @work03_fn() %22 = load double, double* @fadd_res, align 8 %23 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.1, i64 0, i64 0), double noundef %17, double noundef %18, double noundef %22) %24 = load i8*, i8** %3, align 8 call void @free(i8* noundef %24) #4 ret i32 0 &#125; declare dso_local i32 @puts(i8* noundef) #1 ; Function Attrs: nounwind declare dso_local noalias i8* @malloc(i64 noundef) #2 declare dso_local i64 @getline(i8** noundef, i64* noundef, %struct._IO_FILE* noundef) #1 ; Function Attrs: nounwind readonly willreturn declare dso_local double @atof(i8* noundef) #3 declare dso_local i32 @printf(i8* noundef, ...) #1 ; Function Attrs: nounwind declare dso_local void @free(i8* noundef) #2 define void @work03_fn(...) &#123; work03_fn_defaut: %0 = load double, double* @fadd_res, align 8 %1 = fcmp ugt double %0, 1.000000e+02 br i1 %1, label %work03_fn_change, label %work03_fn_nothing work03_fn_change: ; preds = %work03_fn_defaut %2 = load double, double* @fadd_res, align 8 %3 = frem double %2, 1.000000e+02 store double %3, double* @fadd_res, align 8 ret void work03_fn_nothing: ; preds = %work03_fn_defaut ret void &#125; attributes #0 = &#123; noinline nounwind optnone uwtable \"frame-pointer\"=\"all\" \"min-legal-vector-width\"=\"0\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" &#125; attributes #1 = &#123; \"frame-pointer\"=\"all\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" &#125; attributes #2 = &#123; nounwind \"frame-pointer\"=\"all\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" &#125; attributes #3 = &#123; nounwind readonly willreturn \"frame-pointer\"=\"all\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" &#125; attributes #4 = &#123; nounwind &#125; attributes #5 = &#123; nounwind readonly willreturn &#125; !llvm.module.flags = !&#123;!0, !1, !2&#125; !llvm.ident = !&#123;!3&#125; !0 = !&#123;i32 1, !\"wchar_size\", i32 4&#125; !1 = !&#123;i32 7, !\"uwtable\", i32 1&#125; !2 = !&#123;i32 7, !\"frame-pointer\", i32 2&#125; !3 = !&#123;!\"clang version 14.0.0\"&#125; 三) 思路二执行 2.1) -2.2) 同上 添加相关必要指令 /** * 2022-04-28 02:42:32 * TODO: * 1. 创建常量100 * 2. 插入基本指令，存储最终的修改fadd结果 * */ auto f32 = builder.getDoubleTy(); auto const_100 = ConstantFP::get(f32,double(100)); // 插入基本指令，存储最终的修改fadd结果 builder.SetInsertPoint(in_prt); auto in_alloc02 = builder.CreateAlloca(f32,0,\"ia01\"); 2.3) 构造函数 /** * 2022-05-03 22:05:01 * TODO: * 新建一个函数: * double work03_fn(double fdd_res)&#123; * if(fdd_res > 100) * return fdd_res = fdd_res %100; * &#125;else&#123; * return fdd_res; * &#125; * */ // 创建函数的参数 std::vector&lt;Type*>parms; parms.push_back(f32); ArrayRef&lt;Type*>fn_parm(parms); // 创建函数 auto fn_prototype = FunctionType::get(builder.getDoubleTy(),fn_parm,true); auto work03_fn = Function::Create(fn_prototype,Function::ExternalLinkage,\"work03_fn\",M.get()); // 创建传的实参 std::vector&lt;Value*>args; args.push_back(in_fadd); ArrayRef&lt;Value*> argRef(args); // 创建基本块 auto work03_fn_defaut= BasicBlock::Create(context, \"work03_fn_defaut\", work03_fn); auto work03_fn_change = BasicBlock::Create(context, \"work03_fn_change\", work03_fn); auto work03_fn_nothing = BasicBlock::Create(context, \"work03_fn_nothing\", work03_fn); // 默认基本块 指令操作 builder.SetInsertPoint(work03_fn_defaut); // 拿到函数参数 auto work03_de_alloc_01 = builder.CreateAlloca(f32,0,\"ial02\"); Function::arg_iterator argsit = work03_fn->arg_begin(); auto work03_de_p1 = argsit; auto work03_de_store_01 = builder.CreateStore(work03_de_p1,work03_de_alloc_01); // 比较大小 auto work03_de_load_01 = builder.CreateLoad(f32,work03_de_alloc_01); auto work03_de_fcmp_01 = builder.CreateFCmpUGT(work03_de_load_01,const_100); auto work03_de_br_01 = builder.CreateCondBr(work03_de_fcmp_01,work03_fn_change,work03_fn_nothing); // 取余 指令操作 builder.SetInsertPoint(work03_fn_change); auto work03_ch_load_01 = builder.CreateLoad(f32,work03_de_alloc_01); auto work03_ch_frem_01 = builder.CreateFRem(work03_ch_load_01,const_100); auto work03_ch_store_01 = builder.CreateStore(work03_ch_frem_01,work03_de_alloc_01); auto work03_ch_load02 = builder.CreateLoad(f32,work03_de_alloc_01); builder.CreateRet(work03_ch_load02); // 第三个基本块 不做修改，返回从参数种拿到的值 builder.SetInsertPoint(work03_fn_nothing); auto work03_no_load01 = builder.CreateLoad(f32,work03_de_alloc_01); builder.CreateRet(work03_no_load01); 2.4) 修改printf函数 /** * 2022-05-03 18:27:56 * TODO: * 在调用prtinf 函数之前插入调用函数指令 * 以及读取fadd_res, 修改printf 第三个参数 * */ builder.SetInsertPoint(in_prt); auto in_call_01 = builder.CreateCall(work03_fn,argRef); auto in_store03 = builder.CreateStore(in_call_01,in_alloc02); auto in_load03 = builder.CreateLoad(f32,in_alloc02); in_prt->setOperand(3,in_load03); 2.5)-2.6) 验证与写入 /** * #include \"llvm/IR/Verifier.h\" * 2022-05-02 11:43:34 * TODO: * 修改完Module后进行验证Module的完整性 * verifyModule(*M,&amp;errs()): true if the module is broken. * */ if(!llvm::verifyModule(*M,&amp;errs()))&#123; outs()&lt;&lt;\"debug: Module verify is ok \\n\"; M->print(outs(),nullptr); &#125; /** * #include \"llvm/Bitcode/BitcodeWriter.h\" * 2022-05-03 12:55:33 * TODO: * 将修改后的IR 存储到文件中， 执行 * */ std::error_code EC; llvm::raw_fd_ostream OS(\"aftermain2.bc\", EC,llvm::sys::fs::OpenFlags()); llvm::WriteBitcodeToFile(*M,OS,true); OS.flush(); 2.7) 全部源码 /** * 2022-05-03 16:16:19 * sizaif * Work3：插入一个函数并调用。函数用于检查加法结果，如果大于 100，则取余 100。此函数会修改加法结果。(函数操作) * * clang++ $(llvm-config --cxxflags --ldflags --system-libs --libs) -o main2 main2.cpp * ./main2 main.ll * lli aftermain2.bc * */ #include \"llvm/Transforms/Utils/BasicBlockUtils.h\" #include &lt;llvm/IR/IRBuilder.h> #include \"llvm/IR/LLVMContext.h\" #include \"llvm/IR/Module.h\" #include \"llvm/IR/InstIterator.h\" #include \"llvm/IR/Instruction.h\" #include \"llvm/IR/Instructions.h\" #include \"llvm/IR/InstrTypes.h\" #include \"llvm/IR/Verifier.h\" #include \"llvm/IRReader/IRReader.h\" #include \"llvm/CodeGen/MIRParser/MIRParser.h\" #include \"llvm/Support/InitLLVM.h\" #include \"llvm/Support/Debug.h\" #include \"llvm/Support/TargetSelect.h\" #include \"llvm/Support/SourceMgr.h\" #include &lt;llvm/Support/raw_os_ostream.h> #include \"llvm/Bitcode/BitcodeWriter.h\" #include &lt;iostream> #include &lt;string> #include &lt;fstream> #include &lt;cstdio> using namespace llvm; int main(int argc,char **argv)&#123; LLVMContext context; IRBuilder&lt;> builder(context); std::unique_ptr&lt;Module> M; std::unique_ptr&lt;MIRParser> MIR; SMDiagnostic Err; /** * #include \"llvm/IRReader/IRReader.h\" * 2022-04-26 03:04:32 * TODO: * from IR file get Moudle class * */ M = parseIRFile(StringRef(argv[1]),Err,context); if(M)&#123; std::cout&lt;&lt;\"debug: M is not null\"&lt;&lt;std::endl; // M->print(llvm::outs(),nullptr); &#125; else&#123; std::cout&lt;&lt;\"M is null\"&lt;&lt;std::endl; Err.print(argv[0],errs()); &#125; /** * 2022-04-26 03:25:52 * TODO: * 获取main函数 * */ auto main_fn = M->getFunction(StringRef(\"main\")); /** * 2022-04-28 02:14:46 * TODO: * 找到fadd指令,与fadd的后一个指令 * */ Instruction *in_fadd,*in_prt; for (inst_iterator I = inst_begin(*main_fn), E = inst_end(*main_fn); I != E; ++I)&#123; if(I->isBinaryOp() &amp;&amp; I->getOpcode()==Instruction::FAdd)&#123; // outs() &lt;&lt; *I &lt;&lt; \"\\n\"; in_fadd = &amp;*I; in_prt = &amp;*(I.operator++()); &#125; &#125; /** * 2022-04-28 02:42:32 * TODO: * 1. 创建常量100 * 2. 插入基本指令，存储最终的修改fadd结果 * */ auto f32 = builder.getDoubleTy(); auto const_100 = ConstantFP::get(f32,double(100)); // 插入基本指令，存储最终的修改fadd结果 builder.SetInsertPoint(in_prt); auto in_alloc02 = builder.CreateAlloca(f32,0,\"ia01\"); /** * 2022-05-03 22:05:01 * TODO: * 新建一个函数: * double work03_fn(double fdd_res)&#123; * if(fdd_res > 100) * return fdd_res = fdd_res %100; * &#125;else&#123; * return fdd_res; * &#125; * */ // 创建函数的参数 std::vector&lt;Type*>parms; parms.push_back(f32); ArrayRef&lt;Type*>fn_parm(parms); // 创建函数 auto fn_prototype = FunctionType::get(builder.getDoubleTy(),fn_parm,true); auto work03_fn = Function::Create(fn_prototype,Function::ExternalLinkage,\"work03_fn\",M.get()); // 创建传的实参 std::vector&lt;Value*>args; args.push_back(in_fadd); ArrayRef&lt;Value*> argRef(args); // 创建基本块 auto work03_fn_defaut= BasicBlock::Create(context, \"work03_fn_defaut\", work03_fn); auto work03_fn_change = BasicBlock::Create(context, \"work03_fn_change\", work03_fn); auto work03_fn_nothing = BasicBlock::Create(context, \"work03_fn_nothing\", work03_fn); // 默认基本块 指令操作 builder.SetInsertPoint(work03_fn_defaut); // 拿到函数参数 auto work03_de_alloc_01 = builder.CreateAlloca(f32,0,\"ial02\"); Function::arg_iterator argsit = work03_fn->arg_begin(); auto work03_de_p1 = argsit; auto work03_de_store_01 = builder.CreateStore(work03_de_p1,work03_de_alloc_01); // 比较大小 auto work03_de_load_01 = builder.CreateLoad(f32,work03_de_alloc_01); auto work03_de_fcmp_01 = builder.CreateFCmpUGT(work03_de_load_01,const_100); auto work03_de_br_01 = builder.CreateCondBr(work03_de_fcmp_01,work03_fn_change,work03_fn_nothing); // 取余 指令操作 builder.SetInsertPoint(work03_fn_change); auto work03_ch_load_01 = builder.CreateLoad(f32,work03_de_alloc_01); auto work03_ch_frem_01 = builder.CreateFRem(work03_ch_load_01,const_100); auto work03_ch_store_01 = builder.CreateStore(work03_ch_frem_01,work03_de_alloc_01); auto work03_ch_load02 = builder.CreateLoad(f32,work03_de_alloc_01); builder.CreateRet(work03_ch_load02); // 第三个基本块 不做修改，返回从参数种拿到的值 builder.SetInsertPoint(work03_fn_nothing); auto work03_no_load01 = builder.CreateLoad(f32,work03_de_alloc_01); builder.CreateRet(work03_no_load01); /** * 2022-05-03 18:27:56 * TODO: * 在调用prtinf 函数之前插入调用函数指令 * 以及读取fadd_res, 修改printf 第三个参数 * */ builder.SetInsertPoint(in_prt); auto in_call_01 = builder.CreateCall(work03_fn,argRef); auto in_store03 = builder.CreateStore(in_call_01,in_alloc02); auto in_load03 = builder.CreateLoad(f32,in_alloc02); in_prt->setOperand(3,in_load03); // M->print(outs(),nullptr); /** * #include \"llvm/IR/Verifier.h\" * 2022-05-02 11:43:34 * TODO: * 修改完Module后进行验证Module的完整性 * verifyModule(*M,&amp;errs()): true if the module is broken. * */ if(!llvm::verifyModule(*M,&amp;errs()))&#123; outs()&lt;&lt;\"debug: Module verify is ok \\n\"; M->print(outs(),nullptr); &#125; /** * #include \"llvm/Bitcode/BitcodeWriter.h\" * 2022-05-03 12:55:33 * TODO: * 将修改后的IR 存储到文件中， 执行 * */ std::error_code EC; llvm::raw_fd_ostream OS(\"aftermain2.bc\", EC,llvm::sys::fs::OpenFlags()); llvm::WriteBitcodeToFile(*M,OS,true); OS.flush(); return 0; &#125; 2.8) 效果 修改后IR代码如下： ; ModuleID = 'main.ll' source_filename = \"t.c\" target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-unknown-linux-gnu\" %struct._IO_FILE = type &#123; i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, %struct._IO_codecvt*, %struct._IO_wide_data*, %struct._IO_FILE*, i8*, i64, i32, [20 x i8] &#125; %struct._IO_marker = type opaque %struct._IO_codecvt = type opaque %struct._IO_wide_data = type opaque @.str = private unnamed_addr constant [22 x i8] c\"plz input two numbers\\00\", align 1 @stdin = external dso_local global %struct._IO_FILE*, align 8 @.str.1 = private unnamed_addr constant [21 x i8] c\"%.2f + %.2f = %.2f \\0A\\00\", align 1 ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 = alloca i32, align 4 %2 = alloca i64, align 8 %3 = alloca i8*, align 8 %4 = alloca double, align 8 %5 = alloca double, align 8 store i32 0, i32* %1, align 4 %6 = call i32 @puts(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str, i64 0, i64 0)) store i64 100, i64* %2, align 8 %7 = load i64, i64* %2, align 8 %8 = call noalias i8* @malloc(i64 noundef %7) #4 store i8* %8, i8** %3, align 8 %9 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8 %10 = call i64 @getline(i8** noundef %3, i64* noundef %2, %struct._IO_FILE* noundef %9) %11 = load i8*, i8** %3, align 8 %12 = call double @atof(i8* noundef %11) #5 store double %12, double* %4, align 8 %13 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8 %14 = call i64 @getline(i8** noundef %3, i64* noundef %2, %struct._IO_FILE* noundef %13) %15 = load i8*, i8** %3, align 8 %16 = call double @atof(i8* noundef %15) #5 store double %16, double* %5, align 8 %17 = load double, double* %4, align 8 %18 = load double, double* %5, align 8 %19 = load double, double* %4, align 8 %20 = load double, double* %5, align 8 %21 = fadd double %19, %20 %ia01 = alloca double, align 8 %22 = call double (double, ...) @work03_fn(double %21) store double %22, double* %ia01, align 8 %23 = load double, double* %ia01, align 8 %24 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.1, i64 0, i64 0), double noundef %17, double noundef %18, double noundef %23) %25 = load i8*, i8** %3, align 8 call void @free(i8* noundef %25) #4 ret i32 0 &#125; declare dso_local i32 @puts(i8* noundef) #1 ; Function Attrs: nounwind declare dso_local noalias i8* @malloc(i64 noundef) #2 declare dso_local i64 @getline(i8** noundef, i64* noundef, %struct._IO_FILE* noundef) #1 ; Function Attrs: nounwind readonly willreturn declare dso_local double @atof(i8* noundef) #3 declare dso_local i32 @printf(i8* noundef, ...) #1 ; Function Attrs: nounwind declare dso_local void @free(i8* noundef) #2 define double @work03_fn(double %0, ...) &#123; work03_fn_defaut: %ial02 = alloca double, align 8 store double %0, double* %ial02, align 8 %1 = load double, double* %ial02, align 8 %2 = fcmp ugt double %1, 1.000000e+02 br i1 %2, label %work03_fn_change, label %work03_fn_nothing work03_fn_change: ; preds = %work03_fn_defaut %3 = load double, double* %ial02, align 8 %4 = frem double %3, 1.000000e+02 store double %4, double* %ial02, align 8 %5 = load double, double* %ial02, align 8 ret double %5 work03_fn_nothing: ; preds = %work03_fn_defaut %6 = load double, double* %ial02, align 8 ret double %6 &#125; attributes #0 = &#123; noinline nounwind optnone uwtable \"frame-pointer\"=\"all\" \"min-legal-vector-width\"=\"0\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" &#125; attributes #1 = &#123; \"frame-pointer\"=\"all\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" &#125; attributes #2 = &#123; nounwind \"frame-pointer\"=\"all\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" &#125; attributes #3 = &#123; nounwind readonly willreturn \"frame-pointer\"=\"all\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" &#125; attributes #4 = &#123; nounwind &#125; attributes #5 = &#123; nounwind readonly willreturn &#125; !llvm.module.flags = !&#123;!0, !1, !2&#125; !llvm.ident = !&#123;!3&#125; !0 = !&#123;i32 1, !\"wchar_size\", i32 4&#125; !1 = !&#123;i32 7, !\"uwtable\", i32 1&#125; !2 = !&#123;i32 7, !\"frame-pointer\", i32 2&#125; !3 = !&#123;!\"clang version 14.0.0\"&#125; 四) 总结 涉及到创建全局变量操作, 创建时需要初始化其值。 一种时直接构造创建，或使用Module类中getOrInsertGlobal方法。 auto in_alloc02 = new GlobalVariable(*M,f32,false,GlobalValue::PrivateLinkage,const_0,\"fadd_res\"); GlobalVariable::GlobalVariable(Module &amp;M, Type *Ty, bool constant, LinkageTypes Link, Constant *InitVal, const Twine &amp;Name, GlobalVariable *Before, ThreadLocalMode TLMode, Optional&lt;unsigned> AddressSpace, bool isExternallyInitialized) // Overload to construct a global variable using its constructor's defaults. Constant *Module::getOrInsertGlobal(StringRef Name, Type *Ty) &#123; return getOrInsertGlobal(Name, Ty, [&amp;] &#123; return new GlobalVariable(*this, Ty, false, GlobalVariable::ExternalLinkage, nullptr, Name); &#125;); &#125; 创建函数操作， 先指定返回类型与函数的参数 构造函数 创建基本块 遍历函数的参数并读取 基本块插入指令 添加返回指令，即使函数为void，也应添加ret void指令","categories":[],"tags":[{"name":"标签二","slug":"标签二","permalink":"https://www.sizaif.com/tags/%E6%A0%87%E7%AD%BE%E4%BA%8C/"},{"name":"标签一","slug":"标签一","permalink":"https://www.sizaif.com/tags/%E6%A0%87%E7%AD%BE%E4%B8%80/"}],"author":"sizaif"},{"title":"LLVM -Learn-Work2","slug":"LLVM-Learn-Work2","date":"2022-05-03T14:10:20.000Z","updated":"2022-05-03T14:16:35.000Z","comments":true,"path":"posts/39ba32b9/","link":"","permalink":"https://www.sizaif.com/posts/39ba32b9/","excerpt":"","text":"LLVM -Learn-Work2 @2022-04-28 03:05:00 @sizaif Work2：如果加法结果大于 100，则将结果改为 100。(基本块操作) //main.c #define _GNU_SOURCE #include &lt;stdio.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;stdlib.h> int main() &#123; puts(\"plz input two numbers\"); size_t bufsize = 100; char* buf = malloc(bufsize); getline(&amp;buf, &amp;bufsize, stdin); double f1 = atof(buf); getline(&amp;buf, &amp;bufsize, stdin); double f2 = atof(buf); printf(\"%.2f + %.2f = %.2f \\n\", f1, f2, f1+f2); free(buf); return 0; &#125; 一) 思路 整体思想为： 获得fadd指令的结果，if语句判断一下结果与100的大小，如果大于100，则修改指令为100 一种思想： ​ 先找到fadd 指令与fadd指令的后一个指令call printf 根据源码，main 只有一个默认基本块 在fadd 指令前，先存入常数值100.0 在fadd 指令后面(call printf指令前添加 fcmp判断指令 从call printf指令开始将默认块一分为: defaut 块和defaut_ret 块 插入两个新的基本块change_prt 和 defaut_prt change_prt基本块的内容为读取100, 调用printf函数输出新的值，跳转到defaut_ret free内存 defaut_prt基本块的内容为读取fadd的结果，调用printf函数输出，跳转到defaut_ret free内存 关系图如下： 原来IR代码 %20 = load double, double* %5, align 8 %21 = fadd double %19, %20 %22 = call i32 (i8*, ...) @printf(8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.1, i64 0, i64 0), double noundef %17, double noundef %18, double noundef %21) %23 = load i8*, i8** %3, align 8 call void @free(i8* noundef %23) #4 ret i32 0 目标IR代码 ····· store double %15, double* %4, align 8 %16 = load double, double* %3, align 8 %17 = load double, double* %4, align 8 %18 = load double, double* %3, align 8 %19 = load double, double* %4, align 8 %ina1 = alloca double, align 8 store double 1.000000e+02, double* %ina1, align 8 %20 = fadd double %18, %19 %inf1 = fcmp ugt double %20, 1.000000e+02 br i1 %inf1, label %change_prt, label %defaut_prt defaut_ret: ; preds = %defaut_prt, %change_prt %21 = load i8*, i8** %2, align 8 call void @free(i8* noundef %21) #4 ret i32 0 change_prt: ; preds = %defaut %22 = load double, double* %ina1, align 8 %23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @0, i32 0, i32 0), double %16, double %17, double %22) br label %defaut_ret defaut_prt: ; preds = %defaut %24 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @0, i32 0, i32 0), double %16, double %17, double %20) br label %defaut_ret &#125; ····· 二) 执行 2.1 初始化(前置) LLVMContext context; IRBuilder&lt;> builder(context); std::unique_ptr&lt;Module> M; std::unique_ptr&lt;MIRParser> MIR; SMDiagnostic Err; /** * #include \"llvm/IRReader/IRReader.h\" * 2022-04-26 03:04:32 * TODO: * from IR file get Moudle class * */ M = parseIRFile(StringRef(argv[1]),Err,context); if(M)&#123; std::cout&lt;&lt;\"debug: M is not null\"&lt;&lt;std::endl; // M->print(llvm::outs(),nullptr); &#125; else&#123; std::cout&lt;&lt;\"M is null\"&lt;&lt;std::endl; Err.print(argv[0],errs()); &#125; 2.2 找到fadd指令并添加相关必要指令 /** * 2022-04-26 03:25:52 * TODO: * 获取main函数 * */ auto main_fn = M->getFunction(StringRef(\"main\")); /** * 2022-04-28 02:14:46 * TODO: * 找到fadd指令,与fadd的后一个指令 * */ Instruction *in_fadd,*in_prt; for (inst_iterator I = inst_begin(*main_fn), E = inst_end(*main_fn); I != E; ++I)&#123; if(I->isBinaryOp() &amp;&amp; I->getOpcode()==Instruction::FAdd)&#123; // outs() &lt;&lt; *I &lt;&lt; \"\\n\"; in_fadd = &amp;*I; in_prt = &amp;*(I.operator++()); &#125; &#125; /** * 2022-04-28 02:42:32 * TODO: * %20 = load double, double* %5, align 8 * %21 = fadd double %19, %20 * 在fadd指令前面 * 添加以下两个指令: * &lt;x> = alloca double, align 8 * store double 1.000000e+02, double* &lt;x>, align 8 * * */ auto f32 = builder.getDoubleTy(); auto const100 = ConstantFP::get(f32,double(100)); builder.SetInsertPoint(in_fadd); auto in_alloc = builder.CreateAlloca(f32,0,\"ina1\"); auto in_store = builder.CreateStore(const100,in_alloc); /** * 2022-05-03 12:47:30 * TODO: * 在printf指令前添加条件判断(fcmp)指令 * %21 = call i32 (i8*, ...) @printf(i8* noundef ···· * fcmp: * &lt;x> = fcmp ugt double &lt;fadd>, 1.000000e+02 * */ builder.SetInsertPoint(in_prt); auto in_fcmp = builder.CreateFCmpUGT(in_fadd,const100,\"inf1\"); 2.3 切割基本块 /** * 2022-05-03 12:49:38 * TODO: * 将main中默认块分为2块: 主体块和默认ret块 * 并添加两个新块: 修改输出块和默认输出块 * */ auto oldblk = &amp;main_fn->getEntryBlock(); oldblk->setName(\"defaut\"); auto bb2 = SplitBlock(oldblk,in_prt); if(!bb2)&#123; errs()&lt;&lt;\"debug: split block wrong! \\n\"; &#125;else&#123; bb2->setName(\"defaut_ret\"); &#125; BasicBlock *change_prt = BasicBlock::Create(context, \"change_prt\", main_fn); BasicBlock *defaut_prt = BasicBlock::Create(context, \"defaut_prt\", main_fn); 切割基本块SplitBlock(oldblk,in_prt);函数，此时切割效果如下： # auto bb2 = SplitBlock(oldblk,in_prt); ······· store double %15, double* %4, align 8 %16 = load double, double* %3, align 8 %17 = load double, double* %4, align 8 %18 = load double, double* %3, align 8 %19 = load double, double* %4, align 8 %ina1 = alloca double, align 8 store double 1.000000e+02, double* %ina1, align 8 %20 = fadd double %18, %19 %inf1 = fcmp ugt double %20, 1.000000e+02 br label %.split .split: ; preds = %0 %21 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.1, i64 0, i64 0), double noundef %18, double noundef %19, double noundef %20) %22 = load i8*, i8** %3, align 8 call void @free(i8* noundef %23) #4 ret i32 0 &#125; 补充后效果如下： defuat ····· store double %15, double* %4, align 8 %16 = load double, double* %3, align 8 %17 = load double, double* %4, align 8 %18 = load double, double* %3, align 8 %19 = load double, double* %4, align 8 %ina1 = alloca double, align 8 store double 1.000000e+02, double* %ina1, align 8 %20 = fadd double %18, %19 %inf1 = fcmp ugt double %20, 1.000000e+02 br label %.split defaut_ret: ; preds = %defaut %21 = load i8*, i8** %2, align 8 call void @free(i8* noundef %21) #4 ret i32 0 change_prt: ; defaut_prt: ; &#125; ····· 2.4 在块中填充内容 /** * 2022-05-03 12:51:10 * TODO: * 修改输出块： * 读取前面存储默认100值, * 构造printf函数输出 * */ builder.SetInsertPoint(change_prt); auto in_load = builder.CreateLoad(f32,in_alloc); auto i32p = builder.getIntPtrTy(M->getDataLayout(),0); auto printf_prototype = FunctionType::get(i32p, true); auto printf_fn = M->getFunction(\"printf\"); if(!printf_fn)&#123; printf_fn = Function::Create(printf_prototype,Function::ExternalLinkage, \"printf\", M.get()); &#125; auto format_str = builder.CreateGlobalStringPtr(\"%.2f + %.2f = %.2f \\n\"); builder.CreateCall(printf_fn, &#123;format_str,in_prt->getOperand(1),in_prt->getOperand(2),in_load&#125;); builder.CreateBr(bb2); /** * 2022-05-03 12:51:57 * TODO: * 默认输出块： * 构造printf默认函数输出 * */ builder.SetInsertPoint(defaut_prt); builder.CreateCall(printf_fn, &#123;format_str,in_prt->getOperand(1),in_prt->getOperand(2),in_fadd&#125;); builder.CreateBr(bb2); /** * 2022-05-03 12:52:18 * TODO: * 构造新的br跳转指令替换默认分块指令 * br label defaue_ret -> br &lt;cond> label A lable B * */ auto old_cond_br = &amp;*(oldblk->getIterator()->rbegin()); auto new_cond_br = BranchInst::Create(change_prt,defaut_prt,in_fcmp); ReplaceInstWithInst(old_cond_br,new_cond_br); /** * 2022-05-03 14:54:46 * TODO: * 删除原先printf的调用指令 * */ in_prt->eraseFromParent(); 2.5 修改后Module验证并写入文件中 /** * #include \"llvm/IR/Verifier.h\" * 2022-05-02 11:43:34 * TODO: * 修改完Module后进行验证Module的完整性 * verifyModule(*M,&amp;errs()): true if the module is broken. * */ if(!llvm::verifyModule(*M,&amp;errs()))&#123; outs()&lt;&lt;\"debug: Module verify is ok \\n\"; // M->print(outs(),nullptr); &#125; /** * #include \"llvm/Bitcode/BitcodeWriter.h\" * 2022-05-03 12:55:33 * TODO: * 将修改后的IR 存储到文件中， 执行 * */ std::error_code EC; llvm::raw_fd_ostream OS(\"aftermain.bc\", EC,llvm::sys::fs::OpenFlags()); llvm::WriteBitcodeToFile(*M,OS,true); OS.flush(); 2.x) 全部源码 /** * 2022-04-26 01:02:37 * 2022-05-03 15:55:43 * sizaif * * clang++ $(llvm-config --cxxflags --ldflags --system-libs --libs) -o main main.cpp * ./main main.ll * lli aftermain.bc * */ #include \"llvm/Transforms/Utils/BasicBlockUtils.h\" #include &lt;llvm/IR/IRBuilder.h> #include \"llvm/IR/LLVMContext.h\" #include \"llvm/IR/Module.h\" #include \"llvm/IR/InstIterator.h\" #include \"llvm/IR/Instruction.h\" #include \"llvm/IR/Instructions.h\" #include \"llvm/IR/InstrTypes.h\" #include \"llvm/IR/Verifier.h\" #include \"llvm/IRReader/IRReader.h\" #include \"llvm/CodeGen/MIRParser/MIRParser.h\" #include \"llvm/Support/InitLLVM.h\" #include \"llvm/Support/Debug.h\" #include \"llvm/Support/TargetSelect.h\" #include \"llvm/Support/SourceMgr.h\" #include &lt;llvm/Support/raw_os_ostream.h> #include \"llvm/Bitcode/BitcodeWriter.h\" #include &lt;iostream> #include &lt;string> #include &lt;fstream> #include &lt;cstdio> using namespace llvm; int main(int argc,char **argv)&#123; LLVMContext context; IRBuilder&lt;> builder(context); std::unique_ptr&lt;Module> M; std::unique_ptr&lt;MIRParser> MIR; SMDiagnostic Err; /** * #include \"llvm/IRReader/IRReader.h\" * 2022-04-26 03:04:32 * TODO: * from IR file get Moudle class * */ M = parseIRFile(StringRef(argv[1]),Err,context); if(M)&#123; std::cout&lt;&lt;\"debug: M is not null\"&lt;&lt;std::endl; // M->print(llvm::outs(),nullptr); &#125; else&#123; std::cout&lt;&lt;\"M is null\"&lt;&lt;std::endl; Err.print(argv[0],errs()); &#125; /** * 2022-04-26 03:25:52 * TODO: * 获取main函数 * */ auto main_fn = M->getFunction(StringRef(\"main\")); /** * 2022-04-28 02:14:46 * TODO: * 找到fadd指令,与fadd的后一个指令 * */ Instruction *in_fadd,*in_prt; for (inst_iterator I = inst_begin(*main_fn), E = inst_end(*main_fn); I != E; ++I)&#123; if(I->isBinaryOp() &amp;&amp; I->getOpcode()==Instruction::FAdd)&#123; // outs() &lt;&lt; *I &lt;&lt; \"\\n\"; in_fadd = &amp;*I; in_prt = &amp;*(I.operator++()); &#125; /** * 2022-04-28 02:42:32 * TODO: * %20 = load double, double* %5, align 8 * %21 = fadd double %19, %20 * 在fadd指令前面 * 添加以下两个指令: * &lt;x> = alloca double, align 8 * store double 1.000000e+02, double* &lt;x>, align 8 * * */ auto f32 = builder.getDoubleTy(); auto const100 = ConstantFP::get(f32,double(100)); builder.SetInsertPoint(in_fadd); auto in_alloc = builder.CreateAlloca(f32,0,\"ina1\"); auto in_store = builder.CreateStore(const100,in_alloc); /** * 2022-05-03 12:47:30 * TODO: * 在printf指令前添加条件判断(fcmp)指令 * %21 = call i32 (i8*, ...) @printf(i8* noundef ···· * fcmp: * &lt;x> = fcmp ugt double &lt;fadd>, 1.000000e+02 * */ builder.SetInsertPoint(in_prt); auto in_fcmp = builder.CreateFCmpUGT(in_fadd,const100,\"inf1\"); outs()&lt;&lt;\"debug: fadd op : \"&lt;&lt;*in_fadd&lt;&lt;\" \\n\"; outs()&lt;&lt;\"debug: alloc op : \"&lt;&lt;*in_alloc&lt;&lt;\" \\n\"; outs()&lt;&lt;\"debug: store op : \"&lt;&lt;*in_store&lt;&lt;\" \\n\"; outs()&lt;&lt;\"debug: fcmp op : \"&lt;&lt;*in_fcmp&lt;&lt;\" \\n\"; /** * 2022-05-03 12:49:38 * TODO: * 将main中默认块分为2块: 主体块和默认ret块 * 并添加两个新块: 修改输出块和默认输出块 * */ auto oldblk = &amp;main_fn->getEntryBlock(); oldblk->setName(\"defaut\"); auto bb2 = SplitBlock(oldblk,in_prt); if(!bb2)&#123; errs()&lt;&lt;\"debug: split block wrong! \\n\"; &#125;else&#123; bb2->setName(\"defaut_ret\"); &#125; BasicBlock *change_prt = BasicBlock::Create(context, \"change_prt\", main_fn); BasicBlock *defaut_prt = BasicBlock::Create(context, \"defaut_prt\", main_fn); /** * 2022-05-03 12:51:10 * TODO: * 修改输出块： * 读取前面存储默认100值, * 构造printf函数输出 * */ builder.SetInsertPoint(change_prt); auto in_load = builder.CreateLoad(f32,in_alloc); auto i32p = builder.getIntPtrTy(M->getDataLayout(),0); auto printf_prototype = FunctionType::get(i32p, true); auto printf_fn = M->getFunction(\"printf\"); if(!printf_fn)&#123; printf_fn = Function::Create(printf_prototype,Function::ExternalLinkage, \"printf\", M.get()); &#125; auto format_str = builder.CreateGlobalStringPtr(\"%.2f + %.2f = %.2f \\n\"); builder.CreateCall(printf_fn, &#123;format_str,in_prt->getOperand(1),in_prt->getOperand(2),in_load&#125;); builder.CreateBr(bb2); /** * 2022-05-03 12:51:57 * TODO: * 默认输出块： * 构造printf默认函数输出 * */ builder.SetInsertPoint(defaut_prt); builder.CreateCall(printf_fn, &#123;format_str,in_prt->getOperand(1),in_prt->getOperand(2),in_fadd&#125;); builder.CreateBr(bb2); /** * 2022-05-03 12:52:18 * TODO: * 构造新的br跳转指令替换默认分块指令 * br label defaue_ret -> br &lt;cond> label A lable B * */ auto old_cond_br = &amp;*(oldblk->getIterator()->rbegin()); outs()&lt;&lt;\"debug: old cond br : \"&lt;&lt;*old_cond_br&lt;&lt;\" \\n\"; auto new_cond_br = BranchInst::Create(change_prt,defaut_prt,in_fcmp); outs()&lt;&lt;\"debug: new cond br : \"&lt;&lt;*new_cond_br&lt;&lt;\" \\n\"; ReplaceInstWithInst(old_cond_br,new_cond_br); /** * 2022-05-03 14:54:46 * TODO: * 删除原先printf的调用指令 * */ in_prt->eraseFromParent(); /** * #include \"llvm/IR/Verifier.h\" * 2022-05-02 11:43:34 * TODO: * 修改完Module后进行验证Module的完整性 * verifyModule(*M,&amp;errs()): true if the module is broken. * */ if(!llvm::verifyModule(*M,&amp;errs()))&#123; outs()&lt;&lt;\"debug: Module verify is ok \\n\"; // M->print(outs(),nullptr); &#125; /** * #include \"llvm/Bitcode/BitcodeWriter.h\" * 2022-05-03 12:55:33 * TODO: * 将修改后的IR 存储到文件中， 执行 * */ std::error_code EC; llvm::raw_fd_ostream OS(\"aftermain.bc\", EC,llvm::sys::fs::OpenFlags()); llvm::WriteBitcodeToFile(*M,OS,true); OS.flush(); return 0; &#125; 2.6 效果 三) 总结 基本块操作涉及到： 对基本块的遍历(迭代器应用) 对基本块的拆分， 基本块的拆分时，根据方法的使用会将当前指令放到新基本块或旧基本块(注意区分) 构造指令插入(可以使用IRbuilder) 来构造基本指令与函数或基本块 指令删除操作 相应的修改后Module 需要进行验证","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"LLVM","slug":"Master/LLVM","permalink":"https://www.sizaif.com/navigation/categories/Master/LLVM/"}],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"LLVM","slug":"LLVM","permalink":"https://www.sizaif.com/tags/LLVM/"}],"author":"sizaif"},{"title":"LLVM -Learn-Work1","slug":"LLVM-Learn-Work1","date":"2022-05-02T04:16:30.000Z","updated":"2022-05-03T14:17:18.000Z","comments":true,"path":"posts/a0b36303/","link":"","permalink":"https://www.sizaif.com/posts/a0b36303/","excerpt":"","text":"LLVM -Learn-Work1 @2022-04-27 16:33:55 @sizaif Work1：将其浮点数加法改为减法。(指令操作) //main.c #define _GNU_SOURCE #include &lt;stdio.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;stdlib.h> int main() &#123; puts(\"plz input two numbers\"); size_t bufsize = 100; char* buf = malloc(bufsize); getline(&amp;buf, &amp;bufsize, stdin); double f1 = atof(buf); getline(&amp;buf, &amp;bufsize, stdin); double f2 = atof(buf); printf(\"%.2f + %.2f = %.2f \\n\", f1, f2, f1+f2); free(buf); return 0; &#125; 一) 思路 使用Clang生成IR文件 clang -emit-llvm -S main.c -o main.ll 从IR文件中读取到Module类中 拿到main函数 找到fadd指令，构造新的fsub指令，添加到当前fadd指令后，并删除fadd指令 法一: 通过main函数拿到所有的BasicBlockList() 遍历所有basicblock块的所有指令(Instruction) 查找fadd 指令 法二： 使用指令迭代器(inst_iterator),遍历所有main函数的指令找到fadd 验证修改后的Module类 存入到新的IR文件中,执行lli aftermain.bc 二) 执行 2.1) 从IR文件中读取到Module类中 /** * 2022-04-26 03:20:02 * 从IR中获取Module类 * */ M = parseIRFile(StringRef(argv[1]),Err,context); if(M)&#123; std::cout&lt;&lt;\"M is not null\"&lt;&lt;std::endl; // M->print(llvm::outs(),nullptr); &#125; else&#123; std::cout&lt;&lt;\"M is null\"&lt;&lt;std::endl; Err.print(argv[0],errs()); &#125; 2.2) 拿到main函数 /** * 2022-04-26 03:25:52 * 获取main函数 * */ auto main_fn = M->getFunction(StringRef(\"main\")); 2.3) 找到fadd指令，构造fsub替换掉 法一： /** * 2022-04-26 16:56:34 * 方法一: 通过获得basicblock块list 进而获得指令 * 遍历查询inst指令，找到fadd * %19 = load double, double* %4, align 8 * %20 = load double, double* %5, align 8 * %21 = fadd double %19, %20 * */ auto bkl = &amp;main_fn->getBasicBlockList(); for (auto it = bkl->begin(); it != bkl->end();it++) &#123; auto instl = &amp;it->getInstList(); for(auto inst = instl->begin(); inst != instl->end();inst++)&#123; if(inst->isBinaryOp() &amp;&amp; inst->getOpcode() == Instruction::FAdd )&#123; new_inst = BinaryOperator::CreateFSub( inst->getOperand(0), inst->getOperand(1), \"\"); old_inst = &amp;*inst; &#125; &#125; &#125; 法二： /** * 2022-04-27 15:52:04 * 方法二: 指令迭代器遍历查找 * */ Instruction *old_inst,*new_inst; for (inst_iterator I = inst_begin(*main_fn), E = inst_end(*main_fn); I != E; ++I)&#123; if(I->isBinaryOp() &amp;&amp; I->getOpcode()==Instruction::FAdd)&#123; new_inst = BinaryOperator::CreateFSub( I->getOperand(0), I->getOperand(1), \"\"); old_inst = &amp;*I; &#125; &#125; /** * 2022-05-02 11:49:30 * #include \"llvm/Transforms/Utils/BasicBlockUtils.h\" * 指令替换 * */ outs() &lt;&lt;\" new op: \"&lt;&lt; *new_inst&lt;&lt;\" \\n\"; outs() &lt;&lt;\" old op: \"&lt;&lt; *old_inst &lt;&lt; \" \\n\"; ReplaceInstWithInst(old_inst,new_inst); 2.4) 验证修改后的Module类 /** * #include \"llvm/IR/Verifier.h\" * 2022-05-02 11:43:34 * 修改完Module后进行验证Module的完整性 * verifyModule(*M,&amp;errs()): true if the module is broken. * 即如果验证正确返回一个false, 若存在问题则返回true * */ if(!llvm::verifyModule(*M,&amp;errs()))&#123; outs()&lt;&lt;\"verify is ok \\n\"; // M->print(outs(),nullptr); &#125; 2.5) 存入到新的IR文件中,执行lli aftermain.ll /** * 将修改后的IR 存储到文件中， 执行 * */ std::error_code EC; llvm::raw_fd_ostream OS(\"aftermain.bc\", EC,llvm::sys::fs::OpenFlags()); llvm::WriteBitcodeToFile(*M,OS,true); OS.flush(); 2.6) 全部源码 /** * 2022-04-26 01:02:37 * sizaif * * clang++ $(llvm-config --cxxflags --ldflags --system-libs --libs) -o main main.cpp * ./main main.ll * lli aftermain.bc * */ #include &lt;llvm/IR/IRBuilder.h> #include \"llvm/IR/LLVMContext.h\" #include \"llvm/IR/Module.h\" #include \"llvm/IR/InstIterator.h\" #include \"llvm/IR/Verifier.h\" #include \"llvm/IR/Instruction.h\" #include \"llvm/IR/DataLayout.h\" #include \"llvm/IRReader/IRReader.h\" #include \"llvm/Support/Debug.h\" #include \"llvm/Support/SourceMgr.h\" #include &lt;llvm/Support/raw_os_ostream.h> #include \"llvm/Support/WithColor.h\" #include \"llvm/Transforms/Utils/BasicBlockUtils.h\" #include \"llvm/Bitcode/BitcodeWriter.h\" #include &lt;iostream> #include &lt;string> #include &lt;fstream> using namespace llvm; int main(int argc,char **argv)&#123; /** * #include &lt;llvm/IR/IRBuilder.h> * #include \"llvm/IR/LLVMContext.h\" * #include \"llvm/IR/Module.h\" * #include \"llvm/Support/SourceMgr.h\" * 初始化 * */ LLVMContext context; IRBuilder&lt;> builder(context); std::unique_ptr&lt;Module> M; SMDiagnostic Err; /** * 2022-04-26 03:20:02 * 从IR中获取Module类 * */ M = parseIRFile(StringRef(argv[1]),Err,context); if(M)&#123; std::cout&lt;&lt;\"M is not null\"&lt;&lt;std::endl; // M->print(llvm::outs(),nullptr); &#125; else&#123; std::cout&lt;&lt;\"M is null\"&lt;&lt;std::endl; Err.print(argv[0],errs()); &#125; /** * 2022-04-26 03:25:52 * 获取main函数 * */ auto main_fn = M->getFunction(\"main\"); /** * #include \"llvm/IR/InstIterator.h\" * 2022-04-27 15:52:04 * 方法二: 指令迭代器遍历查找,找到fadd指令 * * */ Instruction *old_inst,*new_inst; // for (inst_iterator I = inst_begin(*main_fn), E = inst_end(*main_fn); I != E; ++I)&#123; // if(I->isBinaryOp() &amp;&amp; I->getOpcode()==Instruction::FAdd)&#123; // new_inst = BinaryOperator::CreateFSub( // I->getOperand(0), // I->getOperand(1), // \"\"); // old_inst = &amp;*I; // &#125; // &#125; /** * * 2022-04-26 16:56:34 * 方法一: 通过获得basicblock块list 进而获得指令 * 遍历查询inst指令，找到fadd * %19 = load double, double* %4, align 8 * %20 = load double, double* %5, align 8 * %21 = fadd double %19, %20 * */ auto bkl = &amp;main_fn->getBasicBlockList(); for (auto it = bkl->begin(); it != bkl->end();it++) &#123; auto instl = &amp;it->getInstList(); for(auto inst = instl->begin(); inst != instl->end();inst++)&#123; if(inst->isBinaryOp() &amp;&amp; inst->getOpcode() == Instruction::FAdd )&#123; new_inst = BinaryOperator::CreateFSub( inst->getOperand(0), inst->getOperand(1), \"\"); old_inst = &amp;*inst; &#125; &#125; &#125; /** * #include \"llvm/Transforms/Utils/BasicBlockUtils.h\" * 2022-05-02 11:49:30 * 指令替换 * */ outs() &lt;&lt;\" new op: \"&lt;&lt; *new_inst&lt;&lt;\" \\n\"; outs() &lt;&lt;\" old op: \"&lt;&lt; *old_inst &lt;&lt; \" \\n\"; outs()&lt;&lt;\"before replace InstructionCount(): \" &lt;&lt;main_fn->getInstructionCount()&lt;&lt;\"\\n\"; ReplaceInstWithInst(old_inst,new_inst); outs()&lt;&lt;\"after replace InstructionCount(): \" &lt;&lt;main_fn->getInstructionCount()&lt;&lt;\"\\n\"; /** * #include \"llvm/IR/Verifier.h\" * 2022-05-02 11:43:34 * 修改完Module后进行验证Module的完整性 * verifyModule(*M,&amp;errs()): true if the module is broken. * */ if(!llvm::verifyModule(*M,&amp;errs()))&#123; outs()&lt;&lt;\"verify is ok \\n\"; M->print(outs(),nullptr); &#125; /** * #include \"llvm/Bitcode/BitcodeWriter.h\" * 2022-05-02 12:11:57 * 将修改后的IR 存储到文件中， 执行 * */ std::error_code EC; llvm::raw_fd_ostream OS(\"aftermain.bc\", EC,llvm::sys::fs::OpenFlags()); llvm::WriteBitcodeToFile(*M,OS,true); OS.flush(); return 0; &#125; 2.7) 效果 三) 总结 指令操作 核心是首先要找到对应的指令所在的位置； 构建新的指令，替换掉原来的指令操作， a）构建新的操作指令使用BinaryOperator::CreateXXX 不需要指定插入位置 如果使用`BinaryOperator::Create`&lt;font color='cornflowerblue'&gt;则需要指定插入位置&lt;/font&gt; b）替换指令操作使用ReplaceInstWithInst() 设计头文件`&quot;llvm/Transforms/Utils/BasicBlockUtils.h&quot;` 相应的替换操作还有很多， 像`ReplaceInstWithValue` c）将修改后的文件以bitcode形式存放到文件中， 写入之前最好进行Module的验证 这个过程中涉及到： 1. 文件读入到Module类； 2. 迭代器的使用 3. 获取指令的操作数 4. 创建新的指令 5. 指令替换 6. Module验证 7. 写入文件","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"LLVM","slug":"Master/LLVM","permalink":"https://www.sizaif.com/navigation/categories/Master/LLVM/"}],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"LLVM","slug":"LLVM","permalink":"https://www.sizaif.com/tags/LLVM/"}],"author":"sizaif"},{"title":"LLVM 学习(一) 初识LLVM","slug":"LLVM-学习-一-初识LLVM","date":"2022-04-20T11:19:36.000Z","updated":"2022-05-03T14:17:37.000Z","comments":true,"path":"posts/69383cde/","link":"","permalink":"https://www.sizaif.com/posts/69383cde/","excerpt":"","text":"LLVM 学习(一) 初识LLVM @2022-04-16 10:09:06 @sizaif LLVM安装&amp;环境搭建 官网下载预编译的二进制文件 修改环境变量指向 export PATH=&quot;$PATH:/usr/local/clang+llvm/bin&quot; 检查使用 root@0187031113b5:/home/workhome# env | grep PATH PATH=/usr/local/clang+llvm/bin:/root/.cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin root@0187031113b5:/home/workhome# clang --version clang version 14.0.0 Target: x86_64-unknown-linux-gnu Thread model: posix InstalledDir: /usr/local/clang+llvm/bin root@0187031113b5:/home/workhome# llvm-as --version LLVM (http://llvm.org/): LLVM version 14.0.0 Optimized build. Default target: x86_64-unknown-linux-gnu Host CPU: skylake root@0187031113b5:/home/workhome# LLVM架构 使用可重用的组件构建的新的编译器体系结构 将现有语言重新设置到JIT或静态编译 其主要组件是前端，优化器和后端。前端解析源代码，检查其错误，并构建特定于语言的抽象语法树（AST）以表示输入代码。AST可选地将其转换为新的优化表示，并且优化器和后端在代码上运行。 优化器负责进行各种各样的转换，以改进代码的运行时间，例如消除冗余计算，并且通常或多或少地独立于语言和目标。 后端(也称为代码生成器)然后将代码映射到目标指令集。除了编写正确的代码外，它还负责生成利用受支持体系结构的特殊特性的好代码。编译器后端的公共部分包括指令选择、寄存器分配和指令调度。 LLVM的设计架构 支持一种新的编程语言只需重新实现一个前端，支持一种新的目标架构只需重新实现一个后端，前端和后端连接枢纽就是LLVM IR。 LLVM的含义 在不同的语义环境下，LLVM具有以下几种不同的含义： LLVM基础架构：即一个完整编译器项目的集合，包括但不限于前端、后端、优化器、汇编器、链接器、libcpp标准库、Compiler-RT和JIT引擎 基于LLVM构建的编译器：部分或完全使用LLVM构建的编译器 LLVM库：LLVM基础架构可重用代码部分 LLVM核心：在LLVM IR上进行的优化和后端算法 LLVM IR：LLVM中间表示 LLVM基础架构的组成部分 前端：将程序源代码转换为LLVM IR的编译器步骤，包括词法分析器、语法分析器、语义分析器、LLVM IR生成器。Clang执行了所有与前端相关的步骤，并提供了一个插件接口和一个单独的静态分析工具来进行更深入的分析 中间表示：LLVM IR可以以可读文本代码和二进制代码两种形式呈现。LLVM库中提供了对IR进行构造、组装和拆卸的接口。LLVM优化器也在IR上进行操作，并在IR上进行了大部分优化。 后端：负责汇编码或机器码生成的步骤，将LLVM IR转换为特定机器架构的汇编代码或而二进制代码，包括寄存器分配、循环转换、窥视孔优化器、特定机器架构的优化和转换等步骤 下面这张图展示了使用LLVM基础架构时各个组件之间的关系 除此之外，各个组件之间的协作关系也可以以下面这种方式组织 两种方式的主要区别是程序源代码内部的链接是由LLVM或系统链接器完成的还是由LLVM IR链接器完成的，前者是默认方式，后者一般在开启链接优化（Link-Time Optimization）时采用 LLVM GCC 4.2 设计 链接LLVM和GCC编译的代码 可以安全地在编译器之间混合和匹配.o文件 可以安全地调用到与其他编译器一起构建的库中 链接时间优化 使用-O4对文件进行优化（例如内联、固定折叠等） 可以跨语言边界进行优化 LLVM中间数据结构 在LLVM中并不只存在LLVM IR一种中间表现形式，LLVM在不同编译阶段采用以下不同的中间数据结构： LLVM IR： 抽象语法树（AST）：将源代码转换为LLVM IR时，Clang前端语法分析器和语义分析器的产出数据结构 有向无环图（DAG）：将LLVM IR转换为特定机器架构的汇编代码时，LLVM首先将其转换为有向无环图（DAG）的形式，以方便进行指令选择，然后将其转换回三地址码的形式以进行指令调度 MCModule类：为了实现汇编器和链接器，LLVM使用MCModule类将程序表示保存在对象文件（可重定向文件的一种，通常文件名以.o结尾）的上下文中 不同编译阶段的中间数据结构有以下两种存在方式： 内存中：需要编译驱动程序的帮助，将一个阶段的输出数据结构作为下一个阶段的输入数据结构 文件中：独立命令之间多数以文件为媒介进行交互，比如汇编器与链接器通过可重定向的.o对象文件进行交互 LLVM IR (Intermediate Representation，IR) LLVM的中间表示，本质上一种与源编程语言和目标机器架构无关的通用中间表示 LLVM IR是一种类似于RISC的低级虚拟指令集 LLVM是使用简单类型系统的强类型(例如，i32是一个32位整数，i32** 是指向32位整数的指针) LLVM IR 不使用一组固定的命名寄存器,它使用一个名为%字符的无限临时集合 LLVM IR代被设计成三种不同的形式:内存编译器IR，磁盘二进制.bc表示(适合于即时编译器的快速加载)，可读的汇编语言.ll c代码 unsigned add1(unsigned a, unsigned b) &#123; return a+b; &#125; // Perhaps not the most efficient way to add two numbers. unsigned add2(unsigned a, unsigned b) &#123; if (a == 0) return b; return add2(a-1, b+1); &#125; 对应 llvmIR .ll文件 define i32 @add1(i32 %a, i32 %b) &#123; entry: %tmp1 &#x3D; add i32 %a, %b ret i32 %tmp1 &#125; define i32 @add2(i32 %a, i32 %b) &#123; entry: %tmp1 &#x3D; icmp eq i32 %a, 0 br i1 %tmp1, label %done, label %recurse recurse: %tmp2 &#x3D; sub i32 %a, 1 %tmp3 &#x3D; add i32 %b, 1 %tmp4 &#x3D; call i32 @add2(i32 %tmp2, i32 %tmp3) ret i32 %tmp4 done: ret i32 %b &#125; LLVM IR结构 Module（模块）是一份LLVM IR的顶层容器，对应于编译前端的每个翻译单元（TranslationUnit）。每个模块由目标机器信息、全局符号（全局变量和函数）及元信息组成。 Function（函数）就是编程语言中的函数，包括函数签名和若干个基本块，函数内的第一个基本块叫做入口基本块。 BasicBlock（基本块）是一组顺序执行的指令集合，只有一个入口和一个出口，非头尾指令执行时不会违背顺序跳转到其他指令上去。每个基本块最后一条指令一般是跳转指令（跳转到其它基本块上去），函数内最后一个基本块的最后条指令是函数返回指令。 Instruction（指令）是LLVM IR中的最小可执行单位，每一条指令都单占一行 LLVM IR头部是一些Target Information， ; ModuleID = 'add.c' source_filename = \"add.c\" target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-apple-macosx10.14.0\" 每一行分别是， ModuleID：编译器用于区分不同模块的ID source_filename：源文件名 target datalayout：目标机器架构数据布局 target triple：用于描述目标机器信息的一个元组，一般形式是&lt;architecture&gt;-&lt;vendor&gt;-&lt;system&gt;[-extra-info] 需要关注的是target datalayout，它由-分隔的一列规格组成 e：内存存储模式为小端模式 m:o：目标文件的格式是Mach格式 i64:64：64位整数的对齐方式是64位，即8字节对齐 f80:128：80位扩展精度浮点数的对齐方式是128位，即16字节对齐 n8:16:32:64：整型数据有8位的、16位的、32位的和64位的 S128：128位栈自然对齐 详细 https://llvm.org/docs/LangRef.html#data-layout","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"LLVM","slug":"Master/LLVM","permalink":"https://www.sizaif.com/navigation/categories/Master/LLVM/"}],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"LLVM","slug":"LLVM","permalink":"https://www.sizaif.com/tags/LLVM/"}],"author":"sizaif"},{"title":"LLVM 学习(三) -样例学习","slug":"LLVM-学习-三-样例学习","date":"2022-04-20T11:19:19.000Z","updated":"2022-05-03T14:11:17.000Z","comments":true,"path":"posts/9d5c50c6/","link":"","permalink":"https://www.sizaif.com/posts/9d5c50c6/","excerpt":"","text":"LLVM 学习(三) -样例学习 @2022-04-17 09:28:38 @sizaif LLVM IR 样例学习 1. 基本语法 编写c代码 # hello.c #include &lt;stdio.h> int add(int a,int b)&#123; return a + b; &#125; int main() &#123; int a = 10; int b = 22; printf(\"%d\\n\",add(a,b)); return 0; &#125; 将c源码转换为LLVM IR-ll格式 $ clang -emit-llvm -S hello.c -o hello.ll 生成的hello.ll内容如下 ; ModuleID &#x3D; &#39;hello.c&#39; source_filename &#x3D; &quot;hello.c&quot; target datalayout &#x3D; &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot; target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot; @.str &#x3D; private unnamed_addr constant [4 x i8] c&quot;%d\\0A\\00&quot;, align 1 ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @add(i32 noundef %0, i32 noundef %1) #0 &#123; %3 &#x3D; alloca i32, align 4 %4 &#x3D; alloca i32, align 4 store i32 %0, i32* %3, align 4 store i32 %1, i32* %4, align 4 %5 &#x3D; load i32, i32* %3, align 4 %6 &#x3D; load i32, i32* %4, align 4 %7 &#x3D; add nsw i32 %5, %6 ret i32 %7 &#125; ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 &#x3D; alloca i32, align 4 %2 &#x3D; alloca i32, align 4 %3 &#x3D; alloca i32, align 4 store i32 0, i32* %1, align 4 store i32 10, i32* %2, align 4 store i32 22, i32* %3, align 4 %4 &#x3D; load i32, i32* %2, align 4 %5 &#x3D; load i32, i32* %3, align 4 %6 &#x3D; call i32 @add(i32 noundef %4, i32 noundef %5) %7 &#x3D; call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %6) ret i32 0 &#125; declare dso_local i32 @printf(i8* noundef, ...) #1 attributes #0 &#x3D; &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #1 &#x3D; &#123; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; !llvm.module.flags &#x3D; !&#123;!0, !1, !2&#125; !llvm.ident &#x3D; !&#123;!3&#125; !0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125; !1 &#x3D; !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125; !2 &#x3D; !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125; !3 &#x3D; !&#123;!&quot;clang version 14.0.0&quot;&#125; 注解是以 ; 分隔且直到当前行的结尾 @代表全局标识符（函数，全局变量）； %代表局部标识符（寄存器名称也就是局部变量，类型）。 alloca指令：用于分配内存堆栈给当前执行的函数,当这个函数返回其调用者时自动释放, ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @add(i32 noundef %0, i32 noundef %1) #0 &#123; %3 &#x3D; alloca i32, align 4 ; 分配一个内存到局部变量%3，4字节对齐 %4 &#x3D; alloca i32, align 4 ; 分配一个内存到局部变量%4，4字节对齐 store i32 %0, i32* %3, align 4 ; 将i32类型的变量%0存到内存%3中, 4字节对齐 store i32 %1, i32* %4, align 4 ; 将i32类型的变量%1存到内存%4中, 4字节对齐 %5 &#x3D; load i32, i32* %3, align 4 ; 读取变量%3内存中的数据存放到临时变量%5中，4字节对齐 %6 &#x3D; load i32, i32* %4, align 4 ; 读取变量%4内存中的数据存放到临时变量%6中，4字节对齐 %7 &#x3D; add nsw i32 %5, %6 ; 将变量%5,%6中的数据进行add运算,结构存到%7中 ret i32 %7 ; 返回i32类型的%7 &#125; hello.ll转回hello.bc bitcode格式 $ llvm-as hello.ll -o hello.bc root@0187031113b5:/home/workhome/llvm_test# ll total 20 drwxr-xr-x 2 root root 4096 Apr 17 02:09 ./ drwxr-xr-x 1 root root 4096 Apr 16 06:51 ../ -rw-r--r-- 1 root root 2456 Apr 17 02:09 hello.bc -rw-r--r-- 1 root root 142 Apr 17 02:06 hello.c -rw-r--r-- 1 root root 1838 Apr 17 02:06 hello.ll 执行hello.bc $ lli hello.bc root@0187031113b5:/home/workhome/llvm_test# lli hello.bc 32 2. if 语句 # if.c #include &lt;stdio.h> int main() &#123; int a = 11; if(a%2 == 0) return 0; else return 1; &#125; # if.ll ; ModuleID &#x3D; &#39;if.c&#39; source_filename &#x3D; &quot;if.c&quot; target datalayout &#x3D; &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot; target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot; ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 &#x3D; alloca i32, align 4 %2 &#x3D; alloca i32, align 4 store i32 0, i32* %1, align 4 store i32 11, i32* %2, align 4 %3 &#x3D; load i32, i32* %2, align 4 %4 &#x3D; srem i32 %3, 2 ; srem 带符号整数求余 %5 &#x3D; icmp eq i32 %4, 0 ; 比较 %4 与0 是否相等 br i1 %5, label %6, label %7 ; 分支选择，根据%5结果跳转到%6或%7 6: ; preds &#x3D; %0 store i32 0, i32* %1, align 4 br label %8 7: ; preds &#x3D; %0 store i32 1, i32* %1, align 4 br label %8 8: ; preds &#x3D; %7, %6 %9 &#x3D; load i32, i32* %1, align 4 ret i32 %9 &#125; attributes #0 &#x3D; &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; !llvm.module.flags &#x3D; !&#123;!0, !1, !2&#125; !llvm.ident &#x3D; !&#123;!3&#125; !0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125; !1 &#x3D; !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125; !2 &#x3D; !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125; !3 &#x3D; !&#123;!&quot;clang version 14.0.0&quot;&#125; 通过icmp指令进行比较，产生一个结果值 br指令根据结果值，跳转到相应的分支入口 分支执行完成后，根据br无条件分支跳转到结束分支 3. While 语句 # while.c #include &lt;stdio.h> int main() &#123; int a = 0, b = 1; while(a &lt; 10) &#123; a++; b *= a; &#125; return b; &#125; #while.ll ; ModuleID &#x3D; &#39;while.c&#39; source_filename &#x3D; &quot;while.c&quot; target datalayout &#x3D; &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot; target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot; ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 &#x3D; alloca i32, align 4 %2 &#x3D; alloca i32, align 4 %3 &#x3D; alloca i32, align 4 store i32 0, i32* %1, align 4 store i32 0, i32* %2, align 4 store i32 1, i32* %3, align 4 br label %4 ; 进入标签%4, 进入while循环入口 ; 进入while循环入口 4: ; preds &#x3D; %7, %0 %5 &#x3D; load i32, i32* %2, align 4 %6 &#x3D; icmp slt i32 %5, 10 ; 比较%5 小于10 br i1 %6, label %7, label %13 ; 根据%6 比较的结果分支进入%7 或%13 ; while 循环 body 7: ; preds &#x3D; %4 %8 &#x3D; load i32, i32* %2, align 4 ; 从%2中读取值 以i32类型存到%8中 %9 &#x3D; add nsw i32 %8, 1 ; %9 &#x3D; %8 +1 store i32 %9, i32* %2, align 4 ; 将%9 存到%2中 %10 &#x3D; load i32, i32* %2, align 4 ; 从%2中读取值 以i32类型存到%10中 %11 &#x3D; load i32, i32* %3, align 4 ; 从%3中读取值 以i32类型存到%11中 %12 &#x3D; mul nsw i32 %11, %10 ; %12 &#x3D; %11 * %10 store i32 %12, i32* %3, align 4 ; 将%12 存到%3中 br label %4, !llvm.loop !4 13: ; preds &#x3D; %4 %14 &#x3D; load i32, i32* %3, align 4 ret i32 %14 &#125; attributes #0 &#x3D; &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; !llvm.module.flags &#x3D; !&#123;!0, !1, !2&#125; !llvm.ident &#x3D; !&#123;!3&#125; !0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125; !1 &#x3D; !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125; !2 &#x3D; !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125; !3 &#x3D; !&#123;!&quot;clang version 14.0.0&quot;&#125; !4 &#x3D; distinct !&#123;!4, !5&#125; !5 &#x3D; !&#123;!&quot;llvm.loop.mustprogress&quot;&#125; 通过icmp指令进行循环条件比较 通过br指令进行控制跳转 loop循环，直到 跳出到while.end 4. for 语句 #for.c #include &lt;stdio.h> int main()&#123; int i = 1; int a = 0; for(; i &lt;= 50; i++)&#123; a += i; &#125; printf(\"%d\\n\",a); return 0; &#125; #for.ll ; ModuleID &#x3D; &#39;for.c&#39; source_filename &#x3D; &quot;for.c&quot; target datalayout &#x3D; &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot; target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot; @.str &#x3D; private unnamed_addr constant [4 x i8] c&quot;%d\\0A\\00&quot;, align 1 ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 &#x3D; alloca i32, align 4 %2 &#x3D; alloca i32, align 4 %3 &#x3D; alloca i32, align 4 store i32 0, i32* %1, align 4 store i32 1, i32* %2, align 4 store i32 0, i32* %3, align 4 br label %4 ; 跳转到for循环入口 ; for 循环入口 4: ; preds &#x3D; %11, %0 %5 &#x3D; load i32, i32* %2, align 4 %6 &#x3D; icmp sle i32 %5, 50 br i1 %6, label %7, label %14 ; 循环loop控制 ; for 循环 body 7: 1 ; preds &#x3D; %4 %8 &#x3D; load i32, i32* %2, align 4 %9 &#x3D; load i32, i32* %3, align 4 %10 &#x3D; add nsw i32 %9, %8 store i32 %10, i32* %3, align 4 br label %11 ; for 循环 第三部分操作 11: ; preds &#x3D; %7 %12 &#x3D; load i32, i32* %2, align 4 %13 &#x3D; add nsw i32 %12, 1 store i32 %13, i32* %2, align 4 br label %4, !llvm.loop !4 14: ; preds &#x3D; %4 %15 &#x3D; load i32, i32* %3, align 4 %16 &#x3D; call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %15) ret i32 0 &#125; declare dso_local i32 @printf(i8* noundef, ...) #1 attributes #0 &#x3D; &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #1 &#x3D; &#123; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; !llvm.module.flags &#x3D; !&#123;!0, !1, !2&#125; !llvm.ident &#x3D; !&#123;!3&#125; !0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125; !1 &#x3D; !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125; !2 &#x3D; !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125; !3 &#x3D; !&#123;!&quot;clang version 14.0.0&quot;&#125; !4 &#x3D; distinct !&#123;!4, !5&#125; !5 &#x3D; !&#123;!&quot;llvm.loop.mustprogress&quot;&#125; if,for,while 三个结构类型， 即 条件判断+循环控制 5. Switch #switch.c #include &lt;stdio.h> int main()&#123; int i = 1; int a = 0; for(; i &lt;= 50; i++)&#123; a += i; switch(a)&#123; case 15: printf(\"a = 25, i = %d\\n \",i); break; case 105: printf(\"a = 105, i= %d\\n \",i); break; case 990: printf(\"a = 990, i = %d\\n \",i); break; &#125; &#125; printf(\"%d\\n\",a); return 0; &#125; #switch.ll ; ModuleID &#x3D; &#39;switch.c&#39; source_filename &#x3D; &quot;switch.c&quot; target datalayout &#x3D; &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot; target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot; @.str &#x3D; private unnamed_addr constant [18 x i8] c&quot;a &#x3D; 25, i &#x3D; %d\\0A \\00&quot;, align 1 @.str.1 &#x3D; private unnamed_addr constant [19 x i8] c&quot;a &#x3D; 105, i&#x3D; %d\\0A \\00&quot;, align 1 @.str.2 &#x3D; private unnamed_addr constant [19 x i8] c&quot;a &#x3D; 990, i &#x3D; %d\\0A \\00&quot;, align 1 @.str.3 &#x3D; private unnamed_addr constant [4 x i8] c&quot;%d\\0A\\00&quot;, align 1 ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 &#x3D; alloca i32, align 4 %2 &#x3D; alloca i32, align 4 %3 &#x3D; alloca i32, align 4 store i32 0, i32* %1, align 4 store i32 1, i32* %2, align 4 store i32 0, i32* %3, align 4 br label %4 ; 进入for循环入口 # for循环入口 4: ; preds &#x3D; %22, %0 %5 &#x3D; load i32, i32* %2, align 4 %6 &#x3D; icmp sle i32 %5, 50 br i1 %6, label %7, label %25 ; for循环 body 7: ; preds &#x3D; %4 %8 &#x3D; load i32, i32* %2, align 4 %9 &#x3D; load i32, i32* %3, align 4 %10 &#x3D; add nsw i32 %9, %8 store i32 %10, i32* %3, align 4 %11 &#x3D; load i32, i32* %3, align 4 switch i32 %11, label %21 [ ; switch 判断a i32 15, label %12 i32 105, label %15 i32 990, label %18 ] ; label %12 12: ; preds &#x3D; %7 %13 &#x3D; load i32, i32* %2, align 4 %14 &#x3D; call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i64 0, i64 0), i32 noundef %13) br label %21 ; label %12 15: ; preds &#x3D; %7 %16 &#x3D; load i32, i32* %2, align 4 %17 &#x3D; call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([19 x i8], [19 x i8]* @.str.1, i64 0, i64 0), i32 noundef %16) br label %21 ; label %12 18: ; preds &#x3D; %7 %19 &#x3D; load i32, i32* %2, align 4 %20 &#x3D; call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([19 x i8], [19 x i8]* @.str.2, i64 0, i64 0), i32 noundef %19) br label %21 21: ; preds &#x3D; %7, %18, %15, %12 br label %22 ; for 循环尾部+1 22: ; preds &#x3D; %21 %23 &#x3D; load i32, i32* %2, align 4 %24 &#x3D; add nsw i32 %23, 1 store i32 %24, i32* %2, align 4 br label %4, !llvm.loop !4 25: ; preds &#x3D; %4 %26 &#x3D; load i32, i32* %3, align 4 %27 &#x3D; call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3, i64 0, i64 0), i32 noundef %26) ret i32 0 &#125; declare dso_local i32 @printf(i8* noundef, ...) #1 attributes #0 &#x3D; &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #1 &#x3D; &#123; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; !llvm.module.flags &#x3D; !&#123;!0, !1, !2&#125; !llvm.ident &#x3D; !&#123;!3&#125; !0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125; !1 &#x3D; !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125; !2 &#x3D; !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125; !3 &#x3D; !&#123;!&quot;clang version 14.0.0&quot;&#125; !4 &#x3D; distinct !&#123;!4, !5&#125; !5 &#x3D; !&#123;!&quot;llvm.loop.mustprogress&quot;&#125; 6. 结构体 //struct.c #include&lt;stdio.h> #include&lt;stdlib.h> #include&lt;unistd.h> #include&lt;string.h> struct People&#123; char *num; int age; char name[10]; &#125;; struct Class&#123; int id; struct People people; &#125;; int main()&#123; struct Class class; class.id = 1; class.people.num = \"211501\"; class.people.age = 22; strcpy(class.people.name, \"test\"); printf(\"id = %d ; age = %d ; num = %s; name = %s\\n\",class.id,class.people.age,class.people.num,class.people.name); return 0; &#125; 可读struct.ll文件 ; ModuleID &#x3D; &#39;struct.c&#39; source_filename &#x3D; &quot;struct.c&quot; target datalayout &#x3D; &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot; target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot; %struct.Class &#x3D; type &#123; i32, %struct.People &#125; %struct.People &#x3D; type &#123; i8*, i32, [10 x i8] &#125; ; i32类型 10*i8的空间 @.str &#x3D; private unnamed_addr constant [7 x i8] c&quot;211501\\00&quot;, align 1 @.str.1 &#x3D; private unnamed_addr constant [5 x i8] c&quot;test\\00&quot;, align 1 @.str.2 &#x3D; private unnamed_addr constant [42 x i8] c&quot;id &#x3D; %d ; age &#x3D; %d ; num &#x3D; %s; name &#x3D; %s\\0A\\00&quot;, align 1 ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 &#x3D; alloca i32, align 4 %2 &#x3D; alloca %struct.Class, align 8 ; 分配%struct.Class空间给%2 store i32 0, i32* %1, align 4 ; 指令来获得指向数组的元素和指向结构体成员的指针 ; 获取class第一个成员的指针给%3 即 int id; %3 &#x3D; getelementptr inbounds %struct.Class, %struct.Class* %2, i32 0, i32 0 ; 分配1给指针%3 即 class.id &#x3D; 1 store i32 1, i32* %3, align 8 ; 获取class的第二个成员指针给%4 即 struct People people; %4 &#x3D; getelementptr inbounds %struct.Class, %struct.Class* %2, i32 0, i32 1 ; 获取class.people结构体的第一个成员指针给%5 %5 &#x3D; getelementptr inbounds %struct.People, %struct.People* %4, i32 0, i32 0 ; 分配@.str的内容给%5 即 class.people.num &#x3D; &quot;211501&quot;; store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i8** %5, align 8 ; 获取class结构体的第二个成员指针给%6 即 struct People people; %6 &#x3D; getelementptr inbounds %struct.Class, %struct.Class* %2, i32 0, i32 1 ; 获取class.people结构体的第二个成员指针给%7 即 int age; %7 &#x3D; getelementptr inbounds %struct.People, %struct.People* %6, i32 0, i32 1 ; 分配 22 给 %7 指针指向地址 即 class.people.age &#x3D; 22; store i32 22, i32* %7, align 8 ; 获取class结构体的第二个成员指针给%8 即 struct People people; %8 &#x3D; getelementptr inbounds %struct.Class, %struct.Class* %2, i32 0, i32 1 ; 获取class.people结构体的第三个成员指针给%9 即 char name[10];; %9 &#x3D; getelementptr inbounds %struct.People, %struct.People* %8, i32 0, i32 2 ; 获取%9指针指向的第一个地址 %10 &#x3D; getelementptr inbounds [10 x i8], [10 x i8]* %9, i64 0, i64 0 ; 调用strcpy函数 分配@.str.1 %11 &#x3D; call i8* @strcpy(i8* noundef %10, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i64 0, i64 0)) #3 ; 为了输出printf 做准备 %12 &#x3D; getelementptr inbounds %struct.Class, %struct.Class* %2, i32 0, i32 0 %13 &#x3D; load i32, i32* %12, align 8 %14 &#x3D; getelementptr inbounds %struct.Class, %struct.Class* %2, i32 0, i32 1 %15 &#x3D; getelementptr inbounds %struct.People, %struct.People* %14, i32 0, i32 1 %16 &#x3D; load i32, i32* %15, align 8 %17 &#x3D; getelementptr inbounds %struct.Class, %struct.Class* %2, i32 0, i32 1 %18 &#x3D; getelementptr inbounds %struct.People, %struct.People* %17, i32 0, i32 0 %19 &#x3D; load i8*, i8** %18, align 8 %20 &#x3D; getelementptr inbounds %struct.Class, %struct.Class* %2, i32 0, i32 1 %21 &#x3D; getelementptr inbounds %struct.People, %struct.People* %20, i32 0, i32 2 %22 &#x3D; getelementptr inbounds [10 x i8], [10 x i8]* %21, i64 0, i64 0 %23 &#x3D; call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.2, i64 0, i64 0), i32 noundef %13, i32 noundef %16, i8* noundef %19, i8* noundef %22) ret i32 0 &#125; ; Function Attrs: nounwind declare dso_local i8* @strcpy(i8* noundef, i8* noundef) #1 declare dso_local i32 @printf(i8* noundef, ...) #2 attributes #0 &#x3D; &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #1 &#x3D; &#123; nounwind &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #2 &#x3D; &#123; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #3 &#x3D; &#123; nounwind &#125; !llvm.module.flags &#x3D; !&#123;!0, !1, !2&#125; !llvm.ident &#x3D; !&#123;!3&#125; !0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125; !1 &#x3D; !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125; !2 &#x3D; !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125; !3 &#x3D; !&#123;!&quot;clang version 14.0.0&quot;&#125; 结构体和数组需要现使用getelementptr 获取指向数组或结构成员的指针，然后根据指针指向的内容进行赋值或做运算 7. 牛刀小试 //main.c #define _GNU_SOURCE #include &lt;stdio.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;stdlib.h> int main() &#123; puts(\"plz input two numbers\"); size_t bufsize = 100; char* buf = malloc(bufsize); getline(&amp;buf, &amp;bufsize, stdin); double f1 = atof(buf); getline(&amp;buf, &amp;bufsize, stdin); double f2 = atof(buf); printf(\"%.2f + %.2f = %.2f \\n\", f1, f2, f1+f2); free(buf); return 0; &#125; 转换成可读 ll文件 $ clang -emit-llvm -S main.c -o main.ll ; ModuleID &#x3D; &#39;main.c&#39; source_filename &#x3D; &quot;main.c&quot; target datalayout &#x3D; &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot; target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot; %struct._IO_FILE &#x3D; type &#123; i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, %struct._IO_codecvt*, %struct._IO_wide_data*, %struct._IO_FILE*, i8*, i64, i32, [20 x i8] &#125; %struct._IO_marker &#x3D; type opaque %struct._IO_codecvt &#x3D; type opaque %struct._IO_wide_data &#x3D; type opaque @.str &#x3D; private unnamed_addr constant [22 x i8] c&quot;plz input two numbers\\00&quot;, align 1 @stdin &#x3D; external dso_local global %struct._IO_FILE*, align 8 @.str.1 &#x3D; private unnamed_addr constant [21 x i8] c&quot;%.2f + %.2f &#x3D; %.2f \\0A\\00&quot;, align 1 ; Function Attrs: noinline nounwind optnone uwtable define dso_local i32 @main() #0 &#123; %1 &#x3D; alloca i32, align 4 ; 分配空间 %2 &#x3D; alloca i64, align 8 ; 分配空间 %3 &#x3D; alloca i8*, align 8 ; 分配空间 %4 &#x3D; alloca double, align 8 ; 分配空间 %5 &#x3D; alloca double, align 8 ; 分配空间 store i32 0, i32* %1, align 4 ; 分配默认值0 ; 调用输出 %6 &#x3D; call i32 @puts(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str, i64 0, i64 0)) store i64 100, i64* %2, align 8 ; 存储100 到 i64指针%2 %7 &#x3D; load i64, i64* %2, align 8 %8 &#x3D; call noalias i8* @malloc(i64 noundef %7) #4 ; 动态分配内存大小为%7的空间 store i8* %8, i8** %3, align 8 ; 将分配的空间存到%3指针 %9 &#x3D; load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8 ; 输入的%9 %10 &#x3D; call i64 @getline(i8** noundef %3, i64* noundef %2, %struct._IO_FILE* noundef %9) %11 &#x3D; load i8*, i8** %3, align 8 %12 &#x3D; call double @atof(i8* noundef %11) #5 store double %12, double* %4, align 8 %13 &#x3D; load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8 %14 &#x3D; call i64 @getline(i8** noundef %3, i64* noundef %2, %struct._IO_FILE* noundef %13) %15 &#x3D; load i8*, i8** %3, align 8 %16 &#x3D; call double @atof(i8* noundef %15) #5 store double %16, double* %5, align 8 %17 &#x3D; load double, double* %4, align 8 %18 &#x3D; load double, double* %5, align 8 %19 &#x3D; load double, double* %4, align 8 %20 &#x3D; load double, double* %5, align 8 %21 &#x3D; fadd double %19, %20 %22 &#x3D; call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.1, i64 0, i64 0), double noundef %17, double noundef %18, double noundef %21) %23 &#x3D; load i8*, i8** %3, align 8 call void @free(i8* noundef %23) #4 ret i32 0 &#125; declare dso_local i32 @puts(i8* noundef) #1 ; Function Attrs: nounwind declare dso_local noalias i8* @malloc(i64 noundef) #2 declare dso_local i64 @getline(i8** noundef, i64* noundef, %struct._IO_FILE* noundef) #1 ; Function Attrs: nounwind readonly willreturn declare dso_local double @atof(i8* noundef) #3 declare dso_local i32 @printf(i8* noundef, ...) #1 ; Function Attrs: nounwind declare dso_local void @free(i8* noundef) #2 attributes #0 &#x3D; &#123; noinline nounwind optnone uwtable &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #1 &#x3D; &#123; &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #2 &#x3D; &#123; nounwind &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #3 &#x3D; &#123; nounwind readonly willreturn &quot;frame-pointer&quot;&#x3D;&quot;all&quot; &quot;no-trapping-math&quot;&#x3D;&quot;true&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;&#x3D;&quot;generic&quot; &#125; attributes #4 &#x3D; &#123; nounwind &#125; attributes #5 &#x3D; &#123; nounwind readonly willreturn &#125; !llvm.module.flags &#x3D; !&#123;!0, !1, !2&#125; !llvm.ident &#x3D; !&#123;!3&#125; !0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125; !1 &#x3D; !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125; !2 &#x3D; !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125; !3 &#x3D; !&#123;!&quot;clang version 14.0.0&quot;&#125;","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"LLVM","slug":"Master/LLVM","permalink":"https://www.sizaif.com/navigation/categories/Master/LLVM/"}],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"LLVM","slug":"LLVM","permalink":"https://www.sizaif.com/tags/LLVM/"}],"author":"sizaif"},{"title":"AFL(american Fuzzy Lop)学习二","slug":"AFL-american-fuzzy-lop-学习二","date":"2022-04-19T02:37:17.000Z","updated":"2022-04-19T02:42:24.000Z","comments":true,"path":"posts/3594e8de/","link":"","permalink":"https://www.sizaif.com/posts/3594e8de/","excerpt":"","text":"AFL(american fuzzy lop)学习二 @sizaif @2022-04-10 设计思想 覆盖率计算 改进边缘覆盖： 向目标程序注入以下工具来捕获分支(边缘)覆盖率和分支命中计数 一条边表示为当前基本块(分配了一个随机常数)与前一个基本块(即元组 (prev_location, cur_location))之间的 XOR 覆盖信息存储在一个紧凑共享的64KB的哈希表中，称为跟踪位图(bitmap) 当访问一条边时，通过增加与该特定边的哈希相对应的位图中的值来记录命中 cur_location &#x3D; &lt;COMPILE_TIME_RANDOM&gt;; # cur_location 值是随机生成的，以简化链接复杂项目的过程并保持 XOR 输出均匀分布。 shared_mem[cur_location ^ prev_location]++; # 由调用者传递给检测的二进制文件。 prev_location &#x3D; cur_location &gt;&gt; 1; # 保持元组的方向性 以区分 A^B 和 B^A ,并保持紧密循环的标识,区分A^A,B^B **简单块计算存在的问题：**对已执行的基本块进行技术会导致信息丢失 例如： 已执行 BB1-&gt;BB2-&gt;BB3-&gt;BB4， 新的路径： BB1-&gt;BB2-&gt;BB4, BB1-&gt;BB2-&gt;BB3 未被计入，路径丢失 相比简单的块覆盖计算：可以区分一下路径 BB1 -&gt; BB2 -&gt; BB3 -&gt; BBB4 (tuples: BB1BB2, BB2BB3, BB3BB4) BB1 -&gt; BB2 -&gt;BBB4 (tuples: BB1BB2, BB2BB4) BB1 -&gt; BB2 -&gt;BBB3 (tuples: BB1BB2, BB2BB3) 检测新行为 采用以下方法： fuzzer 维护先前执行中元组的全局映射；当一个变异的输入产生一个包含新元组的执行跟踪时，相应输入文件被保留等后续处理。 不触发执行跟踪中新的局部规模状态转换（即不产生新元组）的输入将被丢弃，即使它们的整体控制流序列是唯一的。 优势： 避免路径爆炸 达到较高的细粒度探索 不必对复杂的执行轨迹进行任何计算密集型和脆弱的全局比较 example: #2 存在(CA,AE)被认为是新路径， #1: A -&gt; B -&gt; C -&gt; D -&gt; E #2: A -&gt; B -&gt; C -&gt; A -&gt; E 处理路径#2 时,由于存在(CD,CA), 会出现以下的路径，但不会被视为新的路径 #3: A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E 除了检测新元组外，模糊器还考虑粗略的元组命中计数, 分为以下桶: 1、2、3、4-7、8-15、16-31、32-127、128+ 桶允许将仪器生成的 8 位计数器就地映射到 fuzzer 可执行文件依赖的 8 位位图，以跟踪已经看到的每个元组的执行计数 模糊策略 确定性策略包括： 具有不同长度和步距的连续位翻转，（Sequential bit flips with varying lengths and stepovers） 小整数的顺序加减法，（Sequential addition and subtraction of small integers） 已知有趣整数的顺序插入（0、1、INT_MAX 等），（Sequential insertion of known interesting integers (0, 1, INT_MAX, etc)) 非确定性步骤包括: 堆叠位翻转 (stacked bit flips) 插入 (insertions) 删除 (deletions) 算术 (arithmetics) 不同测试用例的拼接 (splicing of different test cases) afl-as.c 设计思想： 当使用 afl-gcc / afl-clang 编译程序时，工具链会自动寻找afl-as的位置，并调用此文件编译的程序afl-as。 此汇编包装器的目的是 预处理由GCC/clang生成的汇编文件 处理输入的参数命令，为调用真正的as汇编器准备。 并在分支处插桩 afl-as.h 中包含的检测位。 处理输入文件，生成 modified_file。 根据afl-as.h在合适的的地方插桩。 插桩执行代码： fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,R(MAP_SIZE)); 其本质上想捕获如下位置： ^main: - function entry point (always instrumented) ^.L0: - GCC branch label ^.LBB0_0: - clang branch label (but only in clang mode) ^\\tjnz foo - conditional branches 使用execvp调用as进行真正的汇编 execvp(as_params[0], (char**)as_params) afl-as.h 插桩部分 // 伪代码 cur_location = &lt;COMPILE_TIME_RANDOM>; # cur_location 值是随机生成的，以简化链接复杂项目的过程并保持 XOR 输出均匀分布。 shared_mem[cur_location ^ prev_location]++; # 由调用者传递给检测的二进制文件。 prev_location = cur_location >> 1; # 保持元组的方向性 以区分 A^B 和 B^A ,并保持紧密循环的标识,区分A^A,B^B 说明： 存储 XOR异或数据对： 1) 当前执行分支的标识符; 2)之前执行的分支的标识符。即TL，DR 执行 shm_trace_map[cur_loc ^ prev_loc]++ 插桩操作 fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,R(MAP_SIZE)); fprintf()将格式化字符串添加到汇编文件的相应位置，trampoline_fmt_64的具体内容如下： /** * 这一段汇编代码，主要的操作是： * 保存rdx等寄存器 * 将rcx的值设置为fprintf()所要打印的变量内容 * 调用方法__afl_maybe_log() * 恢复寄存器 */ static const u8* trampoline_fmt_64 = \"\\n\" \"/* --- AFL TRAMPOLINE (64-BIT) --- */\\n\" \"\\n\" \".align 4\\n\" \"\\n\" \"leaq -(128+24)(%%rsp), %%rsp\\n\" \"movq %%rdx, 0(%%rsp)\\n\" \"movq %%rcx, 8(%%rsp)\\n\" \"movq %%rax, 16(%%rsp)\\n\" \"movq $0x%08x, %%rcx\\n\" \"call __afl_maybe_log\\n\" \"movq 16(%%rsp), %%rax\\n\" \"movq 8(%%rsp), %%rcx\\n\" \"movq 0(%%rsp), %%rdx\\n\" \"leaq (128+24)(%%rsp), %%rsp\\n\" \"\\n\" \"/* --- END --- */\\n\" \"\\n\"; __afl_maybe_log作为插桩代码所执行的实际内容，分析&quot;movl $0x%08x, %%ecx\\n&quot;这条指令 R(MAP_SIZE)即为上述指令将rcx设置的值，即为。根据定义，宏MAP_SIZE为64K，；R(x)的定义是(random() % (x))，所以R(MAP_SIZE)即为0到MAP_SIZE之间的一个随机数。 因此，在处理到某个分支，需要插入桩代码时，afl-as会生成一个随机数，作为运行时保存在ecx中的值。而这个随机数，便是用于标识这个代码块的key。 检查 SHM 区域是否已映射 static const u8* main_payload_64 = ····· \" /* Check if SHM region is already mapped. */\\n\" \"\\n\" \" movq __afl_area_ptr(%rip), %rdx\\n\" \" testq %rdx, %rdx\\n\" \" je __afl_setup\\n\" \"\\n\" ····· 分支记录 static const u8* main_payload_64 = ······ \"__afl_store:\\n\" \"\\n\" \" /* Calculate and store hit for the code location specified in rcx. */\\n\" \"\\n\" #ifndef COVERAGE_ONLY \" xorq __afl_prev_loc(%rip), %rcx\\n\" \" xorq %rcx, __afl_prev_loc(%rip)\\n\" \" shrq $1, __afl_prev_loc(%rip)\\n\" #endif /* ^!COVERAGE_ONLY */ \"\\n\" #ifdef SKIP_COUNTS \" orb $1, (%rdx, %rcx, 1)\\n\" #else \" incb (%rdx, %rcx, 1)\\n\" #endif /* ^SKIP_COUNTS */ ····· 对应伪代码 shared_mem[cur_location ^ prev_location]++; 具体地，变量__afl_prev_loc保存的是前一次跳转的”位置”，其值与rcx做异或后，保存在rip中，并以rdx（共享内存）为基址，对rcx下标处进行加一操作。而rip的值右移1位后，保存在了变量__afl_prev_loc中。 则这里的rcx，保存的为伪代码中的cur_location。回忆之前介绍代码插桩的部分： static const u8* trampoline_fmt_64 = ······ \"movq $0x%08x, %%rcx\\n\" \"call __afl_maybe_log\\n\" ······ 在每个插桩处，afl-as会添加相应指令，将rcx的值设为0到MAP_SIZE之间的某个随机数，从而实现了伪代码中的cur_location = &lt;COMPILE_TIME_RANDOM&gt;; 因此，AFL为每个代码块生成一个随机数，作为其“位置”的记录；随后，对分支处的”源位置“和”目标位置“进行异或，并将异或的结果作为该分支的key，保存每个分支的执行次数。用于保存执行次数的实际上是一个哈希表，大小为MAP_SIZE=64K。 afl-gcc.c **设计思想: ** 当前系统路径中找到afl-as汇编器所在位置，调用afls-as , afl-as以as的别名形式存在 插桩检测位。编译器默认优先使用该路径中的汇编器和链接器，即 afl-as，实际的插桩工作发生在汇编的时候 读取输入的参数命令，根据输入的参数命令 CC&#x3D;%s&#x2F;afl-gcc .&#x2F;configure CXX&#x3D;%s&#x2F;afl-g++ .&#x2F;configure 1). 判断使用的afl编译器对应真实的编译器 gcc/g++ 或 clang/clang++ 将真实编译器填入cc_params[0]中 afl-gcc -&gt; gcc afl-g++ -&gt; g++ afl-clang++ -&gt;clang++ afl-clang -&gt; clang 2). 读取其他相应的参数，并填充到cc_params数组中 调用系统命令execvp 执行真实的编译器 execvp(cc_params[0], (char**)cc_params); execvp（）的基本语法 (Basic Syntax of execvp()) This function takes in the name of the UNIX command to run, as the first argument. 该函数将要运行的UNIX命令的名称作为第一个参数。 This is there in the &lt;unistd.h&gt; header file, so we must include it in our program. 该文件位于&lt;unistd.h&gt;头文件中，因此我们必须将其包含在程序中。 #include &lt;unistd.h> int execvp(const char* command, char* argv[]); Here, we refer to a “command” as any binary executable file that is a part of the PATH environment variable. So, if you want to run custom programs, make sure that you add it to your PATH variable! 在这里，我们将“命令”称为PATH环境变量一部分的任何二进制可执行文件。 因此，如果要运行自定义程序，请确保将其添加到PATH变量中！ The second argument (argv) represents the list of arguments to command. This is an array of char* strings. 第二个参数（ argv ）表示command的参数列表。 这是一个char*字符串数组。 Here, argv contains the complete command, along with it’s arguments. 在这里， argv包含完整的命令及其参数。","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"论文","slug":"Master/论文","permalink":"https://www.sizaif.com/navigation/categories/Master/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"AFL","slug":"AFL","permalink":"https://www.sizaif.com/tags/AFL/"},{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"论文","slug":"论文","permalink":"https://www.sizaif.com/tags/%E8%AE%BA%E6%96%87/"}],"author":"sizaif"},{"title":"AFL(american Fuzzy Lop)学习三","slug":"AFL-american-fuzzy-lop-学习三","date":"2022-04-19T02:36:54.000Z","updated":"2022-04-19T02:42:26.000Z","comments":true,"path":"posts/77c87ed3/","link":"","permalink":"https://www.sizaif.com/posts/77c87ed3/","excerpt":"","text":"AFL(american fuzzy lop)学习三 @sizaif @2022-04-11 fork Server 为了提高性能，afl-fuzz 使用“fork server”，其中模糊处理的进程只经过一次execve()、link和 libc 0initialization，然后通过利用写时复制从停止的进程映像中克隆。 **其基本思路是：**启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。这样设计的最大好处，就是不需要调用execve()，从而节省了载入目标文件和库、解析符号地址等重复性工作。 具体运行原理: 首先fuzzer执行fork()得到父进程和子进程，这里的父进程仍然为fuzzer，子进程则为target进程，即将来的fork server。 EXP_ST void init_forkserver(char** argv) &#123; ······ forksrv_pid = fork(); ······ &#125; 而父子进程之间，是通过管道进行通信。具体使用了2个管道，一个用于传递状态，另一个用于传递命令： int st_pipe[2], ctl_pipe[2]; 对于子进程（fork server），会进行一系列设置，其中包括将上述两个管道分配到预先指定的fd，并最终执行target： if (!forksrv_pid) &#123; ······ /* Set up control and status pipes, close the unneeded original fds. */ if (dup2(ctl_pipe[0], FORKSRV_FD) &lt; 0) PFATAL(\"dup2() failed\"); if (dup2(st_pipe[1], FORKSRV_FD + 1) &lt; 0) PFATAL(\"dup2() failed\"); ······ execv(target_path, argv); &#125; 对于父进程（fuzzer），则会读取状态管道的信息，如果一切正常，则说明fork server创建完成。 fsrv_st_fd = st_pipe[0]; ······ rlen = read(fsrv_st_fd, &amp;status, 4); ······ /* If we have a four-byte \"hello\" message from the server, we're all set. Otherwise, try to figure out what went wrong. */ if (rlen == 4) &#123; OKF(\"All right - fork server is up.\"); return; &#125; fork server与fuzzer通信 fork server侧的具体操作 方法__afl_maybe_log()中。首先，通过写入状态管道，fork server会通知fuzzer，其已经准备完毕，可以开始fork了，而这正是上面提到的父进程等待的信息： static const u8* main_payload_64 = ······ \"__afl_forkserver:\\n\" \"\\n\" \" /* Enter the fork server mode to avoid the overhead of execve() calls. We\\n\" \" push rdx (area ptr) twice to keep stack alignment neat. */\\n\" \"\\n\" \" pushq %rdx\\n\" \" pushq %rdx\\n\" \"\\n\" \" /* Phone home and tell the parent that we're OK. (Note that signals with\\n\" \" no SA_RESTART will mess it up). If this fails, assume that the fd is\\n\" \" closed because we were execve()d from an instrumented binary, or because\\n\" \" the parent doesn't want to use the fork server. */\\n\" \"\\n\" \" movq $4, %rdx /* length */\\n\" \" leaq __afl_temp(%rip), %rsi /* data */\\n\" \" movq $\" STRINGIFY((FORKSRV_FD + 1)) \", %rdi /* file desc */\\n\" CALL_L64(\"write\") \"\\n\" \" cmpq $4, %rax\\n\" \" jne __afl_fork_resume\\n\" ······ 接下来，fork server进入等待状态__afl_fork_wait_loop，读取命令管道，直到fuzzer通知其开始fork： static const u8* main_payload_64 = ······ \"__afl_fork_wait_loop:\\n\" \"\\n\" \" /* Wait for parent by reading from the pipe. Abort if read fails. */\\n\" \"\\n\" \" movq $4, %rdx /* length */\\n\" \" leaq __afl_temp(%rip), %rsi /* data */\\n\" \" movq $\" STRINGIFY(FORKSRV_FD) \", %rdi /* file desc */\\n\" CALL_L64(\"read\") \" cmpq $4, %rax\\n\" \" jne __afl_die\\n\" \"\\n\" ······ 一旦fork server接收到fuzzer的信息，便调用fork()，得到父进程和子进程： static const u8* main_payload_64 = ······ \" /* Once woken up, create a clone of our process. This is an excellent use\\n\" \" case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\\n\" \" caches getpid() results and offers no way to update the value, breaking\\n\" \" abort(), raise(), and a bunch of other things :-( */\\n\" \"\\n\" CALL_L64(\"fork\") \" cmpq $0, %rax\\n\" \" jl __afl_die\\n\" \" je __afl_fork_resume\\n\" \"\\n\" ······ 子进程是实际执行target的进程，其跳转到__afl_fork_resume。在这里会关闭不再需要的管道，并继续执行： static const u8* main_payload_64 = ······ \"__afl_fork_resume:\\n\" \"\\n\" \" /* In child process: close fds, resume execution. */\\n\" \"\\n\" \" movq $\" STRINGIFY(FORKSRV_FD) \", %rdi\\n\" CALL_L64(\"close\") \"\\n\" \" movq $\" STRINGIFY((FORKSRV_FD + 1)) \", %rdi\\n\" CALL_L64(\"close\") \"\\n\" \" popq %rdx\\n\" \" popq %rdx\\n\" \"\\n\" \" movq %r12, %rsp\\n\" \" popq %r12\\n\" \"\\n\" \" movq 0(%rsp), %rax\\n\" \" movq 8(%rsp), %rcx\\n\" \" movq 16(%rsp), %rdi\\n\" \" movq 32(%rsp), %rsi\\n\" \" movq 40(%rsp), %r8\\n\" \" movq 48(%rsp), %r9\\n\" \" movq 56(%rsp), %r10\\n\" \" movq 64(%rsp), %r11\\n\" \"\\n\" \" movq 96(%rsp), %xmm0\\n\" \" movq 112(%rsp), %xmm1\\n\" \" movq 128(%rsp), %xmm2\\n\" \" movq 144(%rsp), %xmm3\\n\" \" movq 160(%rsp), %xmm4\\n\" \" movq 176(%rsp), %xmm5\\n\" \" movq 192(%rsp), %xmm6\\n\" \" movq 208(%rsp), %xmm7\\n\" \" movq 224(%rsp), %xmm8\\n\" \" movq 240(%rsp), %xmm9\\n\" \" movq 256(%rsp), %xmm10\\n\" \" movq 272(%rsp), %xmm11\\n\" \" movq 288(%rsp), %xmm12\\n\" \" movq 304(%rsp), %xmm13\\n\" \" movq 320(%rsp), %xmm14\\n\" \" movq 336(%rsp), %xmm15\\n\" \"\\n\" \" leaq 352(%rsp), %rsp\\n\" \"\\n\" \" jmp __afl_store\\n\" ······ 父进程则仍然作为fork server运行，其会将子进程的pid通过状态管道发送给fuzzer，并等待子进程执行完毕；一旦子进程执行完毕，则再通过状态管道，将其结束状态发送给fuzzer；之后再次进入等待状态__afl_fork_wait_loop： static const u8* main_payload_64 = ······ \" /* In parent process: write PID to pipe, then wait for child. */\\n\" \"\\n\" \" movl %eax, __afl_fork_pid(%rip)\\n\" \"\\n\" \" movq $4, %rdx /* length */\\n\" \" leaq __afl_fork_pid(%rip), %rsi /* data */\\n\" \" movq $\" STRINGIFY((FORKSRV_FD + 1)) \", %rdi /* file desc */\\n\" CALL_L64(\"write\") \"\\n\" \" movq $0, %rdx /* no flags */\\n\" \" leaq __afl_temp(%rip), %rsi /* status */\\n\" \" movq __afl_fork_pid(%rip), %rdi /* PID */\\n\" CALL_L64(\"waitpid\") \" cmpq $0, %rax\\n\" \" jle __afl_die\\n\" \"\\n\" \" /* Relay wait status to pipe, then loop back. */\\n\" \"\\n\" \" movq $4, %rdx /* length */\\n\" \" leaq __afl_temp(%rip), %rsi /* data */\\n\" \" movq $\" STRINGIFY((FORKSRV_FD + 1)) \", %rdi /* file desc */\\n\" CALL_L64(\"write\") \"\\n\" \" jmp __afl_fork_wait_loop\\n\" ······ fuzzer侧的具体操作 在fork server启动完成后，一旦需要执行某个测试用例，则fuzzer会调用run_target()方法 run_target()方法中，通过命令管道，通知fork server准备fork；并通过状态管道，获取子进程pid： static u8 run_target(char** argv, u32 timeout) &#123; ······ s32 res; /* In non-dumb mode, we have the fork server up and running, so simply tell it to have at it, and then read back PID. */ if ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, 4)) != 4) &#123; if (stop_soon) return 0; RPFATAL(res, \"Unable to request new process from fork server (OOM?)\"); &#125; if ((res = read(fsrv_st_fd, &amp;child_pid, 4)) != 4) &#123; if (stop_soon) return 0; RPFATAL(res, \"Unable to request new process from fork server (OOM?)\"); &#125; if (child_pid &lt;= 0) FATAL(\"Fork server is misbehaving (OOM?)\"); ······ &#125; 随后，fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录。 static u8 run_target(char** argv, u32 timeout) &#123; ······ /* Report outcome to caller. */ if (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123; kill_signal = WTERMSIG(status); if (child_timed_out &amp;&amp; kill_signal == SIGKILL) return FAULT_TMOUT; return FAULT_CRASH; &#125; ······ &#125; hew","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"论文","slug":"Master/论文","permalink":"https://www.sizaif.com/navigation/categories/Master/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"AFL","slug":"AFL","permalink":"https://www.sizaif.com/tags/AFL/"},{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"论文","slug":"论文","permalink":"https://www.sizaif.com/tags/%E8%AE%BA%E6%96%87/"}],"author":"sizaif"},{"title":"LLVM 学习(二) -LLVM IR 语法理论学习","slug":"LLVM-学习-二-LLVM-IR-语法理论学习","date":"2022-04-19T02:32:46.000Z","updated":"2022-05-03T14:18:12.000Z","comments":true,"path":"posts/32795611/","link":"","permalink":"https://www.sizaif.com/posts/32795611/","excerpt":"","text":"LLVM 学习(二) -LLVM IR 语法理论学习 @create 2022-04-16 12:05:47 @sizaif LLVM IR 语法 https://llvm.org/docs/LangRef.html LLVM IR中的标识符有两种基本类型：全局标识符（以@开头）和局部标识符（以%开头） 1、命名值以字母序列开头，例如：%foo, @DivisionByZero, %a.really.long.identifier. 正则表达式为： ‘[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*‘. 2、非命名值以数字开头，例如： %12, @2, %44. 全局标识符，包括全局变量、全局常量和函数 局部标识符，即局部变量。LLVM IR中的局部变量有两种分类方案： 按照是否命名分类： 命名局部变量：顾名思义，比如%tmp 未命名局部变量：以带前缀的无符号数字值表示，比如%1、%2，按顺序编号，函数参数、未命名基本块都会增加计数 按照分配方式分类： 寄存器分配的局部变量：此类局部变量多采用%1 = some value形式进行分配，一般是接受指令返回结果的局部变量 ， 栈分配的局部变量：使用alloca指令在栈帧上分配的局部变量，比如%2 = alloca i32，%2也是个指针，访问或存储时必须使用load和store指令 define i32 @main() &#123; %1 = alloca i32, align 4 %tmp = alloca i32, align 4 store i32 1, i32* %1, align 4 store i64 2, i32* %tmp, align 8 %2 = add nsw i32 %1, %tmp %result = add nsw i32 %1, %2 &#125; 其中%1是栈分配的未命名局部变量，%tmp是栈分配的命名局部变量，%2是寄存器分配的未命名局部变量，%result是寄存器分配的命名局部变量 模块结构 LLVM程序由模块组成，每个模块由函数、全局变量和符号表条目组成。 ; Declare the string constant as a global constant. ; 全局变量 @.str = private unnamed_addr constant [13 x i8] c\"hello world\\0A\\00\" ; External declaration of the puts function ; 函数的外部声明 declare i32 @puts(i8* nocapture) nounwind ; Definition of main function ; 主函数 define i32 @main() &#123; ; i32()* ; Convert [13 x i8]* to i8*... %cast210 = getelementptr [13 x i8], [13 x i8]* @.str, i64 0, i64 0 ; Call puts function to write out the string to stdout. call i32 @puts(i8* %cast210) ret i32 0 &#125; ; Named metadata ; 元组数据 !0 = !&#123;i32 42, null, !\"string\"&#125; !foo = !&#123;!0&#125; Module：LLVM程序由模块组成，每个输入程序都对应一个模块，模块包括函数、全局变量和符号表。多个模块可以被LLVM 链接器（linker）组合在一起。可以将LLVM中的Module类比为C程序中的源文件。一个C源文件中包含函数和全局变量定义、外部函数和外部函数声明，一个Module中包含的内容也基本上如此，只不过C源文件中是源码来表示，Module中是用IR来表示。 Function：被Module所包含，LLVM的Function包含函数名、函数的返回值和参数类型，Function内部则包含BasicBlock。 BasicBlock：与编译技术中常见的基本块(basic block)的概念是一致的，BasicBlock必须有一个进入标签和一条结束指令。结束指令一般是br跳转指令或者ret返回执行。 Instruction：就是上面提到过的“指令”，LLVM IR的最基本的单位，Instruction被包含在BasicBlock中，一个BasicBlock可以有多条Instruction。 链接类型(Linkage Types) 全局的值（全局变量和函数）都由指向某个特定位置的指针表示，并且有一个链接类型： private private类型的全局变量只能被当前模块内的对象直接访问，私有 internal 与private类似，不过它的值会作为局部变量出现在目标文件中。类似C语言中static的概念。 available_externally 该类型的变量不会被输出到对应模块的目标文件中。对于链接者来说，该类型相当于一个外部声明。这种类型只允许在定义时使用，而不能在声明时使用。 linkonce 链接时，这种类型的变量会和其他同名变量merge。该类型的变量如果没被使用则可以被丢弃。这种类型的函数不允许优化器将其内联到调用者的函数体中，这个它有可能被重写。如果想允许内联或者其他优化，请使用linkonce_odr类型 weak 与linkonce类似，但即使不被使用，也不能丢弃。类似C语言中的weak类型的变量（多个变量拥有相同的名字不会造成冲突，只要其中一个是weak类型的。链接时，weak类型的定义被忽略而使用正常的定义，如果没有正常的定义，则使用weak的定义）。 common 与weak类似，用于C语言中的临时定义，比如全局作用域中的`int x;”。函数和别名没有common类型 appending 只用于数组类型的指针。两个这种类型的变量链接时，对应的全局数组被连接在一起。 只能用于LLVM.GLOBAL_CTORS等变量 extern_weak 这种类型在链接之前是weak的，如果不被链接，这个变量是null而不是undefined reference。 linkonce_odr, weak_odr。ODR（one definition rule） 只有等效的变量才能被merge。这个链接类型就表示只能跟等效的变量合并。 external 如果没有指定上面的任意类型，那么就是external的, 函数声明只能使用 external 或 extern_weak 调用约定(Calling Conventions) LLVM 支持调用约定如下 “ccc” - C调用约定 如果没有指定其他类型，那么就默认是这种类型, 这个类型支持可变参数的函数调用并且允许声明的原型和函数声明的实现之间有一些不匹配。 “fastcc” - 快速调用约定 使生成的目标代码尽可能快，可以使用任意tricks。不支持可变参数，并且原型和实现要严格匹配。 “coldcc” - 冷调用 假定这种调用不经常发生。不支持可变参数，并且原型和实现要严格匹配 “cc 10” - GHC调用 Glasgow Haskell Compiler (GHC).专用， “cc 11” - HiPE 调用约定 “webkit_jscc” - WebKit 的 JavaScript 调用约定 “anyregcc” - 代码修补的动态调用约定 “preserve_mostcc” - PreserveMost 调用约定 “preserve_allcc” - PreserveAll 调用约定 “cxx_fast_tlscc” - 访问函数的 CXX_FAST_TLS 调用约定 “tailcc” - 尾可调用调用约定 “swiftcc” - 此调用约定用于 Swift 语言。 “swifttailcc” “cfguard_checkcc” - Windows Control Flow Guard（检查机制） “cc &lt;n&gt;” - 编号约定 可见格式(Visibility Styles) 所有的全局变量和函数都有以下可见性样式之一 “default” - 默认格式 对于使用ELF（Executable and Linking Format）格式的目标文件，这种可见性样式意味着声明对其他模块可见；在共享库中，意味着声明的实体可以被重写；在Darwin，声明对其他模块可见。 “hidden” - Hidden style 具有这种可见性样式的声明引用相同的对象，如果它们在相同的共享对象中的话。通常，具有这种可见性样式的符号不会出现在动态符号表中，所有其他模块不能直接引用它。 “protected” - Protected style 对于ELF，这种样式表明符号会放置在动态符号表中，但是在定义这个符号的模块中的引用会绑定到局部变量，也就是说这个符号不能被其他模块重写。 具有内部(internal)或私有(private)链接的符号必须具有默认(default)可见性。 DLL存储类(DLL Storage Classes) 所有全局变量，函数和别名可以有以下DLL存储类之一 dllimport “dllimport”使编译器通过一个全局指针引用函数或变量，该指针是由导出符号的DLL设置的。在Microsoft Windows目标上，指针名称由imp和函数或变量名称组合而成。 dllexport dllexport使编译器提供一个指向DLL中的指针的全局指针，这样它就可以被dllimport属性引用。 在Microsoft Windows目标上，指针名称由imp和函数或变量名称组合而成。因为这个存储类是用来定义dll接口的，所以编译器、汇编器和链接器知道它是外部引用的，所以必须避免删除该符号。 全局变量(Global Variables) 全局变量定义在编译时间分配的内存区域而非运行时 全局变量定义必须初始化 其他翻译单元中的全局变量也可以声明，在这种情况下它们没有初始化器。 全局变量可以选择指定链接类型 变量可以定义为全局常量，这表明变量的内容永远不会被修改，但需要运行时初始化的变量不能标记为常量，因为变量有存储。 语法 @&lt;GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [ExternallyInitialized] &lt;global | constant> &lt;Type> [&lt;InitializerConstant>] [, section \"name\"] [, partition \"name\"] [, comdat [($name)]] [, align &lt;Alignment>] (, !name !N)* 函数(Functions) LLVM函数定义由define关键字组成 an optional linkage type, an optional runtime preemption specifier, an optional visibility style, an optional DLL storage class, an optional calling convention, an optional unnamed_addr attribute, a return type, an optional parameter attribute for the return type, a function name, a (possibly empty) argument list (each with optional parameter attributes), optional function attributes, an optional address space, an optional section, an optional alignment, an optional comdat, an optional garbage collector name, an optional prefix, an optional prologue, an optional personality, an optional list of attached metadata, an opening curly brace, a list of basic blocks, and a closing curly brace. LLVM函数声明由declare关键字组成 an optional linkage type, an optional visibility style, an optional DLL storage class, an optional calling convention, an optional unnamed_addr or local_unnamed_addr attribute, an optional address space, a return type, an optional parameter attribute for the return type, a function name, a possibly empty list of arguments, an optional alignment, an optional garbage collector name, an optional prefix, and an optional prologue. 如果给出了Unnamed_addr属性，则已知地址不是很大，并且可以合并两个相同的功能。 如果给出了local_unnamed_addr属性，则已知地址在模块中不显着。 如果未给出显式地址空间，则将默认为DataLayOut字符串的程序地址空间默认。 语法 define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass] [cconv] [ret attrs] &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list]) [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs] [section &quot;name&quot;] [partition &quot;name&quot;] [comdat [($name)]] [align N] [gc] [prefix Constant] [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125; 参数列表(argument list)是一个逗号分隔的参数序列，其中每个参数的形式如下 &lt;type&gt; [parameter Attrs] [name] Metadata(Metadata) LLVM IR允许元数据附加到程序中的指令和全局对象，该程序可以将关于代码的额外信息传达给优化器和代码生成器。 元数据没有类型，也不是值。如果从调用指令中引用，则使用元数据类型。 所有元数据在语法中都由感叹号(!)标识． Named Metadata(Named Metadata) 命名元数据是元数据的集合,元数据节点(Metadata nodes,但不是元数据字符串)是已命名元数据的唯一有效操作数 命名元数据表示为带有元数据前缀的字符串。元数据名称的规则与标识符相同，但不允许使用带引号的名称。&quot;\\xx&quot;类型转义仍然有效，它允许任何字符成为名称的一部分。 语法 ; Some unnamed metadata nodes, which are referenced by the named metadata. !0 &#x3D; !&#123;!&quot;zero&quot;&#125; !1 &#x3D; !&#123;!&quot;one&quot;&#125; !2 &#x3D; !&#123;!&quot;two&quot;&#125; ; A named metadata. !name &#x3D; !&#123;!0, !1, !2&#125; 控制指令含义(Terminator Instructions) ret 返回 返回 Syntax: ret &lt;type&gt; &lt;value&gt; ; Return a value from a non-void function ret void ; Return from void function Semantics: 当执行‘ret’ 指令时, 控制流返回到调用函数的上下文。 如果调用者是“call”指令，则在调用后的指令处继续执行。 如果调用者是“invoke”指令，则在“正常”目标块的开头继续执行。 如果指令返回一个值，该值应设置调用或调用指令的返回值。 Example: ret i32 5 ; Return an integer value of 5 ret void ; Return from a void function ret &#123; i32, i8 &#125; &#123; i32 4, i8 2 &#125; ; Return a struct of values 4 and 2 br 分支 二元有条件分支和无条件分支。 Syntax: br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt; br label &lt;dest&gt; ; Unconditional branch Semantics: 在执行条件br指令时，会评估i1参数。 如果值为 true，则控制流向 ``iftrue' label 参数。 如果cond为false，则控制流向iffalse,label`参数。 如果cond是poison或undef，则该指令具有未定义的行为。 Example: Test: %cond &#x3D; icmp eq i32 %a, %b br i1 %cond, label %IfEqual, label %IfUnequal IfEqual: ret i32 1 IfUnequal: ret i32 0 switch 多条件分支 多条件分支 Syntax: switch &lt;intty&gt; &lt;value&gt;, label &lt;defaultdest&gt; [ &lt;intty&gt; &lt;val&gt;, label &lt;dest&gt; ... ] Arguments: “switch”指令使用三个参数：一个整数比较值“value”，一个默认的“label”目的地，以及一个由成对的比较值常量和“label”组成的数组。 该表不允许包含重复的常量条目。 Semantics: switch 指令指定了一个值和目标表。 当执行’switch’指令时，将在该表中搜索给定值。 如果找到该值，则将控制流转移到相应的目的地； 否则，控制流将转移到默认目的地。 如果“value”是“poison”或“undef”，则该指令具有未定义的行为。 Example: ; Emulate a conditional br instruction %Val &#x3D; zext i1 %value to i32 switch i32 %Val, label %truedest [ i32 0, label %falsedest ] ; Emulate an unconditional br instruction switch i32 0, label %dest [ ] ; Implement a jump table: switch i32 %val, label %otherwise [ i32 0, label %onzero i32 1, label %onone i32 2, label %ontwo ] indirectbr 转移到指定地址 转移到地址参数中指定的块 Syntax: indirectbr &lt;somety&gt;* &lt;address&gt;, [ label &lt;dest1&gt;, label &lt;dest2&gt;, ... ] Overview: “indirectbr”指令实现了到当前函数内标签的间接分支，其地址由“address”指定。 地址必须从 blockaddress 常量派生。 Arguments: “地址”参数是要跳转到的标签的地址。 其余参数表示地址可能指向的全部可能目的地。 允许在目标列表中多次出现块，但这并不是特别有用。 此目标列表是必需的，以便数据流分析能够准确了解 CFG。 Semantics: 控制转移到地址参数中指定的块。 所有可能的目标块必须列在标签列表中，否则该指令具有未定义的行为。 这意味着跳转到其他函数中定义的标签也具有未定义的行为 如果address是 poison 或 undef, 则该指令具有未定义的行为。 Implementation: 这通常通过一个寄存器跳转来实现。 Example: indirectbr i8* %Addr, [ label %bb1, label %bb2, label %bb3 ] invoke 普通/带异常调用 普通/带异常调用 Syntax: &lt;result&gt; &#x3D; invoke [cconv] [ret attrs] [addrspace(&lt;num&gt;)] &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs] [operand bundles] to label &lt;normal label&gt; unwind label &lt;exception label&gt; Overview: 如果被调用函数返回“ret”指令，控制流将返回“normal”标签。 如果被调用者（或任何间接被调用者）通过“resume”指令或其他异常处理机制返回，则控制被中断并继续在 动态最近的“exception”标签。 Arguments: 该指令需要几个参数： 可选的cconv标记指示调用应该使用哪个调用约定。如果未指定，则调用默认使用 C 调用约定。 返回值的可选参数属性列表。只有zeroext,signext和inreg属性在这里是有效的。 可选的addrspace属性可以用来表示被调用函数的地址空间。如果未指定，将使用 datalayout string 中的程序地址空间。 ty：调用指令本身的类型，也是返回值的类型。不返回值的函数被标记为“void”。 fnty：应该是被调用函数的签名。参数类型必须与此签名所暗示的类型相匹配。如果函数不是可变参数，则可以省略此类型。 fnptrval：一个 LLVM 值，包含一个指向要调用的函数的指针。在大多数情况下，这是一个直接的函数调用，但间接的invoke也是尽可能的，调用一个指向函数值的任意指针。 function args：类型与函数签名参数类型和参数属性匹配的参数列表。所有参数必须是 first class 类型。如果函数签名表明函数接受可变数量的参数，则可以指定额外的参数。 normal label：被调用函数执行ret指令时到达的标签。 exception label：被调用者通过resume指令或其他异常处理机制返回时到达的标签。 可选的函数属性列表。 可选的操作数包列表。 Semantics: 在大多数情况下，该指令旨在作为标准的call指令运行。 主要区别在于它建立了与标签的关联，运行时库使用该标签来展开堆栈。 Example: %retval &#x3D; invoke i32 @Test(i32 15) to label %Continue unwind label %TestCleanup ; i32:retval set %retval &#x3D; invoke coldcc i32 %Testfnptr(i32 15) to label %Continue unwind label %TestCleanup ; i32:retval set callbr 调用分支 Syntax: &lt;result&gt; &#x3D; callbr [cconv] [ret attrs] [addrspace(&lt;num&gt;)] &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs] [operand bundles] to label &lt;fallthrough label&gt; [indirect labels] Overview: ‘callbr’指令使控制转移到指定的函数. 可以控制流传输到‘fallthrough’ 标签或indirect’标签之一。 该指令仅用于实现 gcc 样式内联汇编的goto特性。 任何其他用法都是 IR 验证程序中的错误。 Arguments: 该指令需要几个参数： 可选的cconv标记指示调用应该使用哪个调用约定。如果未指定，则调用默认使用 C 调用约定。 返回值的可选参数属性列表。只有zeroext,signext和inreg属性在这里是有效的。 可选的addrspace属性可以用来表示被调用函数的地址空间。如果未指定，将使用 datalayout string 中的程序地址空间。 ty：调用指令本身的类型，也是返回值的类型。不返回值的函数被标记为“void”。 fnty：应该是被调用函数的签名。参数类型必须与此签名所暗示的类型相匹配。如果函数不是可变参数，则可以省略此类型。 fnptrval：一个 LLVM 值，包含一个指向要调用的函数的指针。在大多数情况下，这是一个直接的函数调用，但间接的invoke也是尽可能的，调用一个指向函数值的任意指针。 ‘function args：类型与函数签名参数类型和参数属性匹配的参数列表。所有参数必须是 first class 类型。如果函数签名表明函数接受可变数量的参数，则可以指定额外的参数。 ‘fallthrough label’: 内联汇编执行退出底部时到达的标签。 ‘indirect labels’: 当被调用者将控制权转移到fallthrough label以外的位置时到达的标签。 这些的块地址常量也应该在function args列表中。 可选的函数属性列表。 可选的操作数包列表。 Semantics: 在大多数情况下，该指令旨在作为标准的“调用”指令运行。 主要区别在于它建立了与附加标签的关联，以定义控制流在调用之后的去向。 callbr指令的输出值只对fallthrough’块有效，对任何‘indirect’块无效。 这样做的唯一用途是实现 gcc 内联汇编的“goto”功能，其中可以提供额外的标签作为内联汇编跳转到的位置。 Example: ; &quot;asm goto&quot; without output constraints. callbr void asm &quot;&quot;, &quot;r,X&quot;(i32 %x, i8 *blockaddress(@foo, %indirect)) to label %fallthrough [label %indirect] ; &quot;asm goto&quot; with output constraints. &lt;result&gt; &#x3D; callbr i32 asm &quot;&quot;, &quot;&#x3D;r,r,X&quot;(i32 %x, i8 *blockaddress(@foo, %indirect)) to label %fallthrough [label %indirect] resume 抛出异常 抛出异常 Syntax: resume &lt;type&gt; &lt;value&gt; Overview: resume指令是没有后继的终止指令。 Arguments: “resume”指令需要一个参数，该参数必须与同一函数中任何“landingpad”指令的结果类型相同。 Semantics: resume指令恢复一个现有（进行中）异常的传播，该异常的展开被 landingpad 指令中断。 Example: resume &#123; i8*, i32 &#125; %exn catchswitch 异常处理 LLVM异常处理 Syntax: &lt;resultval&gt; &#x3D; catchswitch within &lt;parent&gt; [ label &lt;handler1&gt;, label &lt;handler2&gt;, ... ] unwind to caller &lt;resultval&gt; &#x3D; catchswitch within &lt;parent&gt; [ label &lt;handler1&gt;, label &lt;handler2&gt;, ... ] unwind label &lt;default&gt; Overview: LLVM 的异常处理系统 使用 ‘catchswitch’ 指令来描述可能由 EH 特性执行的捕获处理程序集 例程。 Arguments: parent 参数是包含 catchswitch 指令的 funclet 的标记。 如果 catchswitch 不在 funclet 内，则此操作数可能是标记 none。 default 参数是另一个以 cleanuppad 或 catchswitch 指令开头的基本块的标签。 如 异常处理文档 中所述，此展开目标必须是与“parent”链接相关的合法目标。 handlers 是一个后继块的非空列表，每个后继块都以 catchpad 指令开头。 Semantics: 执行此指令将控制权转移到handlers中的后继者之一， 如果合适，或通过展开标签（如果存在）继续展开。 catchswitch 既是终止符又是 “pad” 指令，这意味着它必须是基本块中的第一条非 phi 指令和最后一条指令。 因此，它必须是块中唯一的非 phi 指令。 Example: dispatch1: %cs1 &#x3D; catchswitch within none [label %handler0, label %handler1] unwind to caller dispatch2: %cs2 &#x3D; catchswitch within %parenthandler [label %handler0] unwind label %cleanup catchret 处理返回 Syntax: catchret from &lt;token&gt; to label &lt;normal&gt; Overview: catchret指令是具有单个后继的终止指令。 Arguments: The first argument to a ‘catchret’ indicates which catchpad it exits. It must be a catchpad. The second argument to a ‘catchret’ specifies where control will transfer to next. ‘catchret’ 的第一个参数指示它退出哪个 catchpad。 它必须是 catchpad。 ‘catchret’ 的第二个参数指定控制将转移到下一个位置。 Semantics: ‘catchret’ 指令结束一个现有的（正在进行的）异常，其展开被 catchpad 指令中断。 personality function 有机会执行任意代码，例如销毁活动异常。 然后控制转移到 normal. token 参数必须是由 catchpad 指令生成的标记。 如果指定的 catchpad 不是最近输入的尚未退出的 funclet pad（如 EH 文档 中所述） , catchret 的行为是未定义的。 Example: catchret from %catch to label %continue cleanupret Syntax: cleanupret from &lt;value&gt; unwind label &lt;continue&gt; cleanupret from &lt;value&gt; unwind to caller Overview cleanupret指令是具有可选后继的终止指令。 Arguments: cleanupret 指令需要一个参数，指示它退出哪个 cleanuppad，并且必须是 cleanuppad。 如果指定的 cleanuppad 不是最近进入的尚未退出的 funclet pad（如 EH 文档 中所述） , cleanupret 的行为是未定义的。 The ‘cleanupret’ instruction also has an optional successor, continue, which must be the label of another basic block beginning with either a cleanuppad or catchswitch instruction. This unwind destination must be a legal target with respect to the parent links, as described in the exception handling documentation. cleanupret指令还有一个可选的后继指令continue，它必须是另一个以cleanuppad或catchswitch指令开头的基本块的标签。 如 异常处理文档 中所述，此展开目标必须是与parent链接相关的合法目标。 Semantics: cleanupret指令向 personality function 指示一个 [cleanuppad](https://llvm.org/docs/LangRef.html #i-cleanuppad) 将控制权转移到已结束。 它将控制转移到continue或退出函数。 Example: cleanupret from %cleanup unwind to caller cleanupret from %cleanup unwind label %continue unreachable 不可到达 不可到达 Syntax: unreachable Overview: unreachable指令没有定义的语义。 该指令用于通知优化器代码的特定部分不可访问。 这可以用来表示无法到达无返回函数之后的代码，以及其他事实。 一元操作 (Unary Operations) fneg 求逆 求逆 Syntax: &lt;result&gt; &#x3D; fneg [fast-math flags]* &lt;ty&gt; &lt;op1&gt; ; yields ty:result Arguments: fneg指令的参数必须是 floating-point 或 [vector](https://llvm.org/ docs/LangRef.html#t-vector) 的浮点值。 &lt;ty&gt; &lt;op1&gt;是操作数类型，必须是浮点类型或者浮点向量。 Semantics: 产生的值是操作数的副本，其符号位被翻转。 该指令还可以采用任意数量的 fast-math flags，它们是启用其他不安全浮点优化的优化提示： Example: &lt;result&gt; &#x3D; fneg float %val ; yields float:result &#x3D; -%var 二进制操作指令(Binary Operations) 运算\\类型 无符号整数 带符号整数 浮点数 + add fadd - sub fsub * mul fmul / udiv sdiv fdiv % urem srem frem add 加 nuw 和 nsw 分别代表No Unsigned Wrap和No Signed Wrap。 如果存在 nuw 或nsw关键字，则如果分别发生无符号或有符号溢出，则 add 的结果值是 poison value （错误值) &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;，两个操作数的类型相同且必须是整型类型或者整型向量。 #Syntax &lt;result&gt; &#x3D; add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; add nuw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; add nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; add nuw nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; add i32 4, %var ; yields i32:result &#x3D; 4 + %var fadd 浮点加 #Syntax &lt;result&gt; &#x3D; fadd [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; fadd float 4.0, %var ; yields float:result &#x3D; 4.0 + %var sub 减 #Syntax &lt;result&gt; &#x3D; sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; sub nuw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; sub nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; sub nuw nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; sub i32 4, %var ; yields i32:result &#x3D; 4 - %var &lt;result&gt; &#x3D; sub i32 0, %val ; yields i32:result &#x3D; -%var fsub 浮点减 #Syntax &lt;result&gt; &#x3D; fsub [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; fsub float 4.0, %var ; yields float:result &#x3D; 4.0 - %var &lt;result&gt; &#x3D; fsub float -0.0, %val ; yields float:result &#x3D; -%var mul 乘 #Syntax &lt;result&gt; &#x3D; mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; mul nuw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; mul nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; mul nuw nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; mul i32 4, %var ; yields i32:result &#x3D; 4 * %var fmul 浮点乘 #Syntax &lt;result&gt; &#x3D; fmul [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; fmul float 4.0, %var ; yields float:result &#x3D; 4.0 * %var udiv 无符号整数除 #Syntax &lt;result&gt; &#x3D; udiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; udiv exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; udiv i32 4, %var ; yields i32:result &#x3D; 4 &#x2F; %var sdiv 带符号整数除 #Syntax &lt;result&gt; &#x3D; sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; sdiv exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; sdiv i32 4, %var ; yields i32:result &#x3D; 4 &#x2F; %var fdiv 浮点除 #Syntax &lt;result&gt; &#x3D; fdiv [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; fdiv float 4.0, %var ; yields float:result &#x3D; 4.0 &#x2F; %var urem 无符号整数求余 #Syntax &lt;result&gt; &#x3D; urem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; urem i32 4, %var ; yields i32:result &#x3D; 4 % %var srem 带符号整数求余 #Syntax &lt;result&gt; &#x3D; srem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; srem i32 4, %var ; yields i32:result &#x3D; 4 % %var frem 浮点数求余 #Syntax &lt;result&gt; &#x3D; frem [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; frem float 4.0, %var ; yields float:result &#x3D; 4.0 % %var 位二进制操作指令 (Bitwise Binary Operations) shl 逻辑左移 返回向左移位指定的结果 即 $op1 * 2^{op2} mod (2^n)$, n为result的宽度 &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;，两个操作数的类型相同且必须是整型类型或者整型向量，&lt;op2&gt;作为无符号值来处理。如果&lt;op1&gt;是向量，&lt;op2&gt;将会按照&lt;op1&gt;的元素逐个移动 如果存在nuw关键字，则如果移位任何非零位，则移位将产生一个poison value(是错误操作的结果)。 如果nsw关键字存在，则如果移位与生成的符号位不一致的任何位，则移位将产生一个poison value(是错误操作的结果)。 #Syntax &lt;result&gt; &#x3D; shl &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; shl nuw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; shl nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; shl nuw nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; shl i32 4, %var ; yields i32: 4 &lt;&lt; %var &lt;result&gt; &#x3D; shl i32 4, 2 ; yields i32: 16 &lt;result&gt; &#x3D; shl i32 1, 10 ; yields i32: 1024 &lt;result&gt; &#x3D; shl i32 1, 32 ; undefined &lt;result&gt; &#x3D; shl &lt;2 x i32&gt; &lt; i32 1, i32 1&gt;, &lt; i32 1, i32 2&gt; ; yields: result&#x3D;&lt;2 x i32&gt; &lt; i32 2, i32 4&gt; lshr 逻辑右移 返回向右移指定零填充位的结果 lshr指令的两个参数必须是相同的整数或整数类型的向量。op2被视为无符号值。 的最高有效位在移位后将被零位填充。 &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;，两个操作数的类型相同且必须是整型类型或者整型向量，作为无符号值来处理。如果是向量，将会按照的元素逐个移动。 如果exact关键字存在，如果移出的任何位都是非零的，那么LSHR的结果值就返回一个poison value(是错误操作的结果)。 #Syntax &lt;result&gt; &#x3D; lshr &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; lshr exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; lshr i32 4, 1 ; yields i32:result &#x3D; 2 &lt;result&gt; &#x3D; lshr i32 4, 2 ; yields i32:result &#x3D; 1 &lt;result&gt; &#x3D; lshr i8 4, 3 ; yields i8:result &#x3D; 0 &lt;result&gt; &#x3D; lshr i8 -2, 1 ; yields i8:result &#x3D; 0x7F &lt;result&gt; &#x3D; lshr i32 1, 32 ; undefined &lt;result&gt; &#x3D; lshr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt; i32 1, i32 2&gt; ; yields: result&#x3D;&lt;2 x i32&gt; &lt; i32 0x7FFFFFFF, i32 1&gt; ashr 算数右移 ashr指令(算术右移)通过符号扩展返回向右移指定位数。 的最高有效位将被op1的符号位填充。 &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;，两个操作数的类型相同且必须是整型类型或者整型向量，作为无符号值来处理。如果是向量，将会按照的元素逐个移动。 如果exact关键字存在，如果移出的任何位都是非零，ashr的结果值返回一个poison value(是错误操作的结果)。 #Syntax &lt;result&gt; &#x3D; ashr &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result &lt;result&gt; &#x3D; ashr exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; ashr i32 4, 1 ; yields i32:result &#x3D; 2 &lt;result&gt; &#x3D; ashr i32 4, 2 ; yields i32:result &#x3D; 1 &lt;result&gt; &#x3D; ashr i8 4, 3 ; yields i8:result &#x3D; 0 &lt;result&gt; &#x3D; ashr i8 -2, 1 ; yields i8:result &#x3D; -1 &lt;result&gt; &#x3D; ashr i32 1, 32 ; undefined &lt;result&gt; &#x3D; ashr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt; i32 1, i32 3&gt; ; yields: result&#x3D;&lt;2 x i32&gt; &lt; i32 -1, i32 0&gt; and 与 In0 In1 Out 0 0 0 0 1 0 1 0 0 1 1 1 #Syntax &lt;result&gt; &#x3D; and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; and i32 4, %var ; yields i32:result &#x3D; 4 &amp; %var &lt;result&gt; &#x3D; and i32 15, 40 ; yields i32:result &#x3D; 8 &lt;result&gt; &#x3D; and i32 4, 8 ; yields i32:result &#x3D; 0 or 或 In0 In1 Out 0 0 0 0 1 1 1 0 1 1 1 1 , ，两个操作数的类型相同且必须是整型类型或者整型向量。 #Syntax &lt;result&gt; &#x3D; or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; or i32 4, %var ; yields i32:result &#x3D; 4 | %var &lt;result&gt; &#x3D; or i32 15, 40 ; yields i32:result &#x3D; 47 &lt;result&gt; &#x3D; or i32 4, 8 ; yields i32:result &#x3D; 12 xor 异或 In0 In1 Out 0 0 0 0 1 1 1 0 1 1 1 0 , ，两个操作数的类型相同且必须是整型类型或者整型向量。 #Syntax &lt;result&gt; &#x3D; xor &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields ty:result #example &lt;result&gt; &#x3D; xor i32 4, %var ; yields i32:result &#x3D; 4 ^ %var &lt;result&gt; &#x3D; xor i32 15, 40 ; yields i32:result &#x3D; 39 &lt;result&gt; &#x3D; xor i32 4, 8 ; yields i32:result &#x3D; 12 &lt;result&gt; &#x3D; xor i32 %V, -1 ; yields i32:result &#x3D; ~%V 向量运算(Vector Operations) extractelement extractelement指令从指定索引处的向量中提取单个矢量元素。 #Syntax: &lt;result&gt; &#x3D; extractelement &lt;n x &lt;ty&gt;&gt; &lt;val&gt;, &lt;ty2&gt; &lt;idx&gt; ; yields &lt;ty&gt; &lt;result&gt; &#x3D; extractelement &lt;vscale x n x &lt;ty&gt;&gt; &lt;val&gt;, &lt;ty2&gt; &lt;idx&gt; ; yields &lt;ty&gt; Arguments: 提取指令的第一个操作数是 vector 类型的值。第二个操作数是指示从何处提取元素的位置的索引。索引可以是任何整数类型的变量。 &lt;ty2&gt; &lt;idx&gt;索引值大于等于零，小于向量的长度。 Semantics: 结果是与 val 的元素类型相同类型的矢量。 它的值是 val idx 位置的值。 如果idx超过了固定长度向量的val的长度，结果将是一个poison value(是错误操作的结果)。 对于可伸缩的向量，如果idx的值超过了向量的运行时长度，则结果是一个poison value(是错误操作的结果)。 # Example: &lt;result&gt; &#x3D; extractelement &lt;4 x i32&gt; %vec, i32 0 ; yields i32 insertelement insertelement指令将矢量元素插入到指定索引处的向量中。 Syntax: &lt;result&gt; &#x3D; insertelement &lt;n x &lt;ty&gt;&gt; &lt;val&gt;, &lt;ty&gt; &lt;elt&gt;, &lt;ty2&gt; &lt;idx&gt; ; yields &lt;n x &lt;ty&gt;&gt; &lt;result&gt; &#x3D; insertelement &lt;vscale x n x &lt;ty&gt;&gt; &lt;val&gt;, &lt;ty&gt; &lt;elt&gt;, &lt;ty2&gt; &lt;idx&gt; ; yields &lt;vscale x n x &lt;ty&gt;&gt; Arguments: insertelement指令的第一个操作数是 vector 类型的值。 第二个操作数是一个矢量值，其类型必须等于第一个操作数的元素类型。 第三个操作数是指示插入值的位置的索引。 索引可以是任何整数类型的变量。 Semantics: 结果是一个与 val 类型相同的向量。 它的元素值是val的值，除了位置 idx，它在该位置获得值 elt。 如果 idx 超过固定长度向量的 val 长度，则结果是poison value. 对于可伸缩向量，如果idx的值超过了向量的运行时长度，则结果是poison value. # Example: &lt;result&gt; &#x3D; insertelement &lt;4 x i32&gt; %vec, i32 1, i32 0 ; yields &lt;4 x i32&gt; shufflevector shufflevector指令从两个输入向量构造元素的排列，返回一个与输入具有相同元素类型且长度与shuffle mask相同的向量。 # Syntax: &lt;result&gt; &#x3D; shufflevector &lt;n x &lt;ty&gt;&gt; &lt;v1&gt;, &lt;n x &lt;ty&gt;&gt; &lt;v2&gt;, &lt;m x i32&gt; &lt;mask&gt; ; yields &lt;m x &lt;ty&gt;&gt; &lt;result&gt; &#x3D; shufflevector &lt;vscale x n x &lt;ty&gt;&gt; &lt;v1&gt;, &lt;vscale x n x &lt;ty&gt;&gt; v2, &lt;vscale x m x i32&gt; &lt;mask&gt; ; yields &lt;vscale x m x &lt;ty&gt;&gt; Arguments: 指令的结果是一个向量，其长度与shuffle mask相同，其元素类型与前两个操作数的元素类型相同。 shufflevector指令的前两个操作数是相同类型的向量。 第三个参数是一个shuffle mask向量常量，其元素类型为i32。 掩码向量元素必须是常量整数或undef值。 &lt;n x &lt;ty&gt;&gt; &lt;v1&gt;, &lt;n x &lt;ty&gt;&gt; &lt;v2&gt;两个输入向量，如果输入向量中未定义的元素被选中，则新向量对应的元素也是未定义。 &lt;m x i32&gt; &lt;mask&gt;调整掩码(shuffle mask)，如果调整掩码是未定义的，则新向量就是未定义的。 Semantics: 两个输入向量的元素在两个向量中从左到右编号。 对于结果向量的每个元素，随机掩码从输入向量之一中选择一个元素以复制到结果中。 掩码中的非负元素表示连接输入向量对的索引。 If the shuffle mask is undefined, the result vector is undefined. If the shuffle mask selects an undefined element from one of the input vectors, the resulting element is undefined. An undefined element in the mask vector specifies that the resulting element is undefined. An undefined element in the mask vector prevents a poisoned vector element from propagating. 对于可伸缩矢量, the only valid mask values at present are zeroinitializer and undef, since we cannot write all indices as literals for a vector with a length unknown at compile time. Example: &lt;result&gt; &#x3D; shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; %v2, &lt;4 x i32&gt; &lt;i32 0, i32 4, i32 1, i32 5&gt; ; yields &lt;4 x i32&gt; &lt;result&gt; &#x3D; shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; undef, &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt; ; yields &lt;4 x i32&gt; - Identity shuffle. &lt;result&gt; &#x3D; shufflevector &lt;8 x i32&gt; %v1, &lt;8 x i32&gt; undef, &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt; ; yields &lt;4 x i32&gt; &lt;result&gt; &#x3D; shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; %v2, &lt;8 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 &gt; ; yields &lt;8 x i32&gt; 聚合操作(Aggregate Operations) extractvalue extractvalue指令从 aggregate 值中提取成员字段的值。 #Syntax: &lt;result&gt; &#x3D; extractvalue &lt;aggregate type&gt; &lt;val&gt;, &lt;idx&gt;&#123;, &lt;idx&gt;&#125;* Arguments: &lt;aggregate type&gt; &lt;val&gt;聚合类型，数组或结构体。 &lt;idx&gt;&#123;, &lt;idx&gt;&#125;*常量索引值，提取指定索引处的元素。 extractvalue’指令的第一个操作数是 struct 或 [array](https://llvm.org/ docs/LangRef.html#t-array) 类型。 其他操作数是常量索引，用于指定以与getelementptr指令中的索引类似的方式提取哪个值。 与getelementptr 索引的主要区别是： 由于被索引的值不是指针，所以第一个索引被省略并假定为零。 必须至少指定一个索引。 不仅结构索引而且数组索引也必须在范围内。 Semantics: 结果是索引操作数指定的聚合中位置处的值。 #Example: &lt;result&gt; &#x3D; extractvalue &#123;i32, float&#125; %agg, 0 ; yields i32 insertvalue insertvalue’指令将一个值插入到 aggregate 值的成员字段中。 #Syntax: &lt;result&gt; &#x3D; insertvalue &lt;aggregate type&gt; &lt;val&gt;, &lt;ty&gt; &lt;elt&gt;, &lt;idx&gt;&#123;, &lt;idx&gt;&#125;* ; yields &lt;aggregate type&gt; Arguments: &lt;aggregate type&gt; &lt;val&gt;聚合类型，数组或结构体。 &lt;ty&gt; &lt;elt&gt;要插入的数据， &lt;idx&gt;&#123;, &lt;idx&gt;&#125;*常量索引值，提取指定索引处的元素。 insertvalue’指令的第一个操作数是 struct 或 [array](https://llvm.org/ docs/LangRef.html#t-array) 类型。 第二个操作数是要插入的一等值。 以下操作数是常量索引，指示插入值的位置，其方式与extractvalue指令中的索引类似。 要插入的值必须与索引标识的值具有相同的类型。 Semantics: The result is an aggregate of the same type as val. Its value is that of val except that the value at the position specified by the indices is that of elt. 结果是与 val 类型相同的聚合。 它的值是val的值，只是索引指定位置的值是elt的值。 #Example: %agg1 &#x3D; insertvalue &#123;i32, float&#125; undef, i32 1, 0 ; yields &#123;i32 1, float undef&#125; %agg2 &#x3D; insertvalue &#123;i32, float&#125; %agg1, float %val, 1 ; yields &#123;i32 1, float %val&#125; %agg3 &#x3D; insertvalue &#123;i32, &#123;float&#125;&#125; undef, float %val, 1, 0 ; yields &#123;i32 undef, &#123;float %val&#125;&#125; 内存访问和寻址操作(Memory Access and Addressing Operations) alloca alloca指令在当前执行函数的栈帧上分配内存 &lt;type&gt;指令返回的指针类型，可以是任何类型。 &lt;ty&gt; &lt;NumElements&gt;要分配的内存数量，分配的内存大小就是该数量*单个类型空间，如果没有指定，默认情况下该值为1。 align &lt;alignment&gt;内存对齐值。如果指定了对齐值，对齐值不能大于1 &lt;&lt; 29，且保证分配的值结果至少与该边界对齐；如果没有指定或者对齐值为零，目标可以选择在任何与类型兼容的范围内对齐分配。 #Syntax &lt;result&gt; &#x3D; alloca [inalloca] &lt;type&gt; [, &lt;ty&gt; &lt;NumElements&gt;] [, align &lt;alignment&gt;] [, addrspace(&lt;num&gt;)] ; yields type addrspace(num)*:result #Example %ptr &#x3D; alloca i32 ; yields i32*:ptr %ptr &#x3D; alloca i32, i32 4 ; yields i32*:ptr %ptr &#x3D; alloca i32, i32 4, align 1024 ; yields i32*:ptr %ptr &#x3D; alloca i32, align 1024 ; yields i32*:ptr load load指令用于从内存中读取。 &lt;result&gt;是一个变量，变量的值是从内存中加载出来的值。 load &lt;ty&gt;加载类型，也就是前面变量的类型。 &lt;ty&gt;* &lt;pointer&gt;是一个指针，指向要加载的内存，指针的类型必须是不包含不透明结构(opaque structural type)的first class type类型。 #Syntax: &lt;result&gt; &#x3D; load [volatile] &lt;ty&gt;, &lt;ty&gt;* &lt;pointer&gt;[, align &lt;alignment&gt;][, !nontemporal !&lt;nontemp_node&gt;][, !invariant.load !&lt;empty_node&gt;][, !invariant.group !&lt;empty_node&gt;][, !nonnull !&lt;empty_node&gt;][, !dereferenceable !&lt;deref_bytes_node&gt;][, !dereferenceable_or_null !&lt;deref_bytes_node&gt;][, !align !&lt;align_node&gt;][, !noundef !&lt;empty_node&gt;] &lt;result&gt; &#x3D; load atomic [volatile] &lt;ty&gt;, &lt;ty&gt;* &lt;pointer&gt; [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;ordering&gt;, align &lt;alignment&gt; [, !invariant.group !&lt;empty_node&gt;] !&lt;nontemp_node&gt; &#x3D; !&#123; i32 1 &#125; !&lt;empty_node&gt; &#x3D; !&#123;&#125; !&lt;deref_bytes_node&gt; &#x3D; !&#123; i64 &lt;dereferenceable_bytes&gt; &#125; !&lt;align_node&gt; &#x3D; !&#123; i64 &lt;value_alignment&gt; &#125; #Example %ptr &#x3D; alloca i32 ; yields i32*:ptr store i32 3, i32* %ptr ; yields void %val &#x3D; load i32, i32* %ptr ; yields i32:val &#x3D; i32 3 store store 指令用于写入内存。 存储指令有两个参数：要存储的值和存储它的地址。 &lt;ty&gt; &lt;value&gt;要存入的值，值的类型必须是已知长度的first class type。 &lt;ty&gt;* &lt;pointer&gt;是一个指针，指向一块存值的地址。 #Syntax: store [volatile] &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt;[, align &lt;alignment&gt;][, !nontemporal !&lt;nontemp_node&gt;][, !invariant.group !&lt;empty_node&gt;] ; yields void store atomic [volatile] &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt; [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;ordering&gt;, align &lt;alignment&gt; [, !invariant.group !&lt;empty_node&gt;] ; yields void !&lt;nontemp_node&gt; &#x3D; !&#123; i32 1 &#125; !&lt;empty_node&gt; &#x3D; !&#123;&#125; # Example %ptr &#x3D; alloca i32 ; yields i32*:ptr store i32 3, i32* %ptr ; yields void %val &#x3D; load i32, i32* %ptr ; yields i32:val &#x3D; i32 3 fence fence指令带有一个排序参数，它定义了与它们添加的边同步的内容。 只能给它们acquire, release, acq_rel, seq_cst排序。 #Syntax fence [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;ordering&gt; ; yields void #Exmaple fence acquire ; yields void fence syncscope(&quot;singlethread&quot;) seq_cst ; yields void fence syncscope(&quot;agent&quot;) seq_cst ; yields void cmpxchg cmpxchg指令用于原子地修改内存。 它在内存中加载一个值并将其与给定值进行比较。 如果它们相等，它会尝试将新值存储到内存中。 #Syntax: cmpxchg [weak] [volatile] &lt;ty&gt;* &lt;pointer&gt;, &lt;ty&gt; &lt;cmp&gt;, &lt;ty&gt; &lt;new&gt; [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;success ordering&gt; &lt;failure ordering&gt;[, align &lt;alignment&gt;] ; yields &#123; ty, i1 &#125; #Example entry: %orig &#x3D; load atomic i32, i32* %ptr unordered, align 4 ; yields i32 br label %loop loop: %cmp &#x3D; phi i32 [ %orig, %entry ], [%value_loaded, %loop] %squared &#x3D; mul i32 %cmp, %cmp %val_success &#x3D; cmpxchg i32* %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields &#123; i32, i1 &#125; %value_loaded &#x3D; extractvalue &#123; i32, i1 &#125; %val_success, 0 %success &#x3D; extractvalue &#123; i32, i1 &#125; %val_success, 1 br i1 %success, label %done, label %loop done: ... atomicrmw atomicrmw指令用于原子地修改内存。 #Syntax: atomicrmw [volatile] &lt;operation&gt; &lt;ty&gt;* &lt;pointer&gt;, &lt;ty&gt; &lt;value&gt; [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;ordering&gt;[, align &lt;alignment&gt;] ; yields ty atomicrmw指令有三个参数：要应用的操作、要修改其值的地址、操作的参数。 xchg: *ptr = val add: *ptr = *ptr + val sub: *ptr = *ptr - val and: *ptr = *ptr &amp; val nand: *ptr = ~(*ptr &amp; val) or: *ptr = *ptr | val xor: *ptr = *ptr ^ val max: *ptr = *ptr &gt; val ? *ptr : val (using a signed comparison) min: *ptr = *ptr &lt; val ? *ptr : val (using a signed comparison) umax: *ptr = *ptr &gt; val ? *ptr : val (using an unsigned comparison) umin: *ptr = *ptr &lt; val ? *ptr : val (using an unsigned comparison) fadd: *ptr = *ptr + val (using floating point arithmetic) fsub: *ptr = *ptr - val (using floating point arithmetic) #Example: %old &#x3D; atomicrmw add i32* %ptr, i32 1 acquire ; yields i32 getelementptr getelementptr指令用于获取 aggregate 数据结构的子元素的地址。 它只执行地址计算，不访问内存。 该指令还可用于计算此类地址的向量。 &lt;result&gt; &#x3D; getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;* &lt;result&gt; &#x3D; getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;* &lt;result&gt; &#x3D; getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt; 第一个&lt;ty&gt;是第一个索引&lt;idx&gt;使用的基本类型 第二个&lt;ty&gt;*表示其后的基地址ptrval的类型。 &lt;ty&gt; &lt;idx&gt;是第一组索引的类型和值， 可以出现多次，其后出现就是第二组、第三组等等索引的类型和值。 #Example: ; yields [12 x i8]*:aptr %aptr &#x3D; getelementptr &#123;i32, [12 x i8]&#125;, &#123;i32, [12 x i8]&#125;* %saptr, i64 0, i32 1 ; yields i8*:vptr %vptr &#x3D; getelementptr &#123;i32, &lt;2 x i8&gt;&#125;, &#123;i32, &lt;2 x i8&gt;&#125;* %svptr, i64 0, i32 1, i32 1 ; yields i8*:eptr %eptr &#x3D; getelementptr [12 x i8], [12 x i8]* %aptr, i64 0, i32 1 ; yields i32*:iptr %iptr &#x3D; getelementptr [10 x i32], [10 x i32]* @arr, i16 0, i16 0 其他操作(Other Operations) icmp 整数比较 icmp 指令根据其两个整数、整数向量、指针或指针向量操作数的比较返回一个布尔值或一个布尔值向量。 #Syntax: &lt;result&gt; &#x3D; icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields i1 or &lt;N x i1&gt;:result Arguments: “icmp”指令需要三个操作数。 第一个操作数是指示要执行的比较类型的关键字： eq: equal ne: not equal ugt: unsigned greater than uge: unsigned greater or equal ult: unsigned less than ule: unsigned less or equal sgt: signed greater than sge: signed greater or equal slt: signed less than sle: signed less or equal The remaining two arguments must be integer or pointer or integer vector typed. They must also be identical types. eq: yields true if the operands are equal, false otherwise. No sign interpretation is necessary or performed. ne: yields true if the operands are unequal, false otherwise. No sign interpretation is necessary or performed. ugt: interprets the operands as unsigned values and yields true if op1 is greater than op2. uge: interprets the operands as unsigned values and yields true if op1 is greater than or equal to op2. ult: interprets the operands as unsigned values and yields true if op1 is less than op2. ule: interprets the operands as unsigned values and yields true if op1 is less than or equal to op2. sgt: interprets the operands as signed values and yields true if op1 is greater than op2. sge: interprets the operands as signed values and yields true if op1 is greater than or equal to op2. slt: interprets the operands as signed values and yields true if op1 is less than op2. sle: interprets the operands as signed values and yields true if op1 is less than or equal to op2. #Example &lt;result&gt; &#x3D; icmp eq i32 4, 5 ; yields: result&#x3D;false &lt;result&gt; &#x3D; icmp ne float* %X, %X ; yields: result&#x3D;false &lt;result&gt; &#x3D; icmp ult i16 4, 5 ; yields: result&#x3D;true &lt;result&gt; &#x3D; icmp sgt i16 4, 5 ; yields: result&#x3D;false &lt;result&gt; &#x3D; icmp ule i16 -4, 5 ; yields: result&#x3D;false &lt;result&gt; &#x3D; icmp sge i16 4, 5 ; yields: result&#x3D;false fcmp 浮点数比较 fcmp指令根据其操作数的比较返回一个布尔值或布尔值向量。 如果操作数是浮点标量，则结果类型为布尔值 (i1)。 如果操作数是浮点向量，则结果类型是布尔向量，其元素数量与被比较的操作数相同。 #Syntax: &lt;result&gt; &#x3D; fcmp [fast-math flags]* &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ; yields i1 or &lt;N x i1&gt;:result Arguments: fcmp’指令需要三个操作数。 第一个操作数是指示要执行的比较类型的关键字： false：不比较，总是返回false oeq：有序且相等 ogt：有序且大于 oge：有序且大于等于 olt：有序且小于 ole：有序且小于或等于 one：有序且不相等 ord：有序(非NASN） yields true if both operands are not a QNAN. ueq：无序或相等 ugt：无序或大于 uge：无序或大于等于 ult：无序或小于 ule：无序或小于等于 une：无序或不相等 uno：无序（都是nans） yields true if either operand is a QNAN. true：不比较，总是返回true Ordered 表示两个操作数都不是 QNAN，而 unordered 表示任何一个操作数都可能是 QNAN。 每个 val1 和 val2 参数必须是 floating-point 类型或 [vector](https://llvm .org/docs/LangRef.html#t-vector) 的浮点类型。 它们必须具有相同的类型。 Semantics: The ‘fcmp’ instruction compares op1 and op2 according to the condition code given as cond. If the operands are vectors, then the vectors are compared element by element. Each comparison performed always yields an i1 result, as follows: false: always yields false, regardless of operands. oeq: yields true if both operands are not a QNAN and op1 is equal to op2. ogt: yields true if both operands are not a QNAN and op1 is greater than op2. oge: yields true if both operands are not a QNAN and op1 is greater than or equal to op2. olt: yields true if both operands are not a QNAN and op1 is less than op2. ole: yields true if both operands are not a QNAN and op1 is less than or equal to op2. one: yields true if both operands are not a QNAN and op1 is not equal to op2. ord: yields true if both operands are not a QNAN. ueq: yields true if either operand is a QNAN or op1 is equal to op2. ugt: yields true if either operand is a QNAN or op1 is greater than op2. uge: yields true if either operand is a QNAN or op1 is greater than or equal to op2. ult: yields true if either operand is a QNAN or op1 is less than op2. ule: yields true if either operand is a QNAN or op1 is less than or equal to op2. une: yields true if either operand is a QNAN or op1 is not equal to op2. uno: yields true if either operand is a QNAN. true: always yields true, regardless of operands. fcmp 指令还可以选择采用任意数量的 fast-math 标志，它们是启用其他不安全浮点优化的优化提示。 任何一组快速数学标志在“fcmp”指令上都是合法的，但唯一对其语义有任何影响的标志是那些允许对输入参数的值进行假设的标志； 即nnan、ninf和reassoc。 有关详细信息，请参阅 Fast-Math 标志。 # Example: &lt;result&gt; &#x3D; fcmp oeq float 4.0, 5.0 ; yields: result&#x3D;false &lt;result&gt; &#x3D; fcmp one float 4.0, 5.0 ; yields: result&#x3D;true &lt;result&gt; &#x3D; fcmp olt float 4.0, 5.0 ; yields: result&#x3D;true &lt;result&gt; &#x3D; fcmp ueq double 1.0, 2.0 ; yields: result&#x3D;false phi phi 指令用于实现 SSA 图中表示函数的 φ 节点。 在运行时，phi指令在逻辑上采用与在当前块之前执行的前驱基本块相对应的对指定的值。 # Syntax: &lt;result&gt; &#x3D; phi [fast-math-flags] &lt;ty&gt; [ &lt;val0&gt;, &lt;label0&gt;], ... Arguments: 传入值的类型由第一个类型字段指定。 在此之后，phi指令将一对列表作为参数，其中一对用于当前块的每个前驱基本块。 只有 first class 类型的值可以用作 PHI 节点的值参数。 只有标签可以用作标签参数。 在基本块的开始和 PHI 指令之间不能有非 phi 指令：即 PHI 指令必须在基本块中的第一个。 就 SSA 形式而言，每个传入值的使用都被认为发生在从相应的前驱块到当前块的边上（但在同一边上定义了“invoke”指令的返回值之后。 # Example: Loop: ; Infinite loop that counts from 0 on up... %indvar &#x3D; phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ] %nextindvar &#x3D; add i32 %indvar, 1 br label %Loop select 条件值选择 select指令用于根据条件选择一个值，无需 IR 级分支。 如果条件是 i1 并且计算结果为 1，则指令返回第一个值参数； 否则，它返回第二个值参数。 如果条件是 i1 的向量，则值参数必须是相同大小的向量，并且选择是逐个元素完成的。 如果条件是 i1 并且值参数是相同大小的向量，则选择整个向量。 #Syntax &lt;result&gt; &#x3D; select [fast-math flags] selty &lt;cond&gt;, &lt;ty&gt; &lt;val1&gt;, &lt;ty&gt; &lt;val2&gt; ; yields ty selty is either i1 or &#123;&lt;N x i1&gt;&#125; #Example: %X &#x3D; select i1 true, i8 17, i8 42 ; yields i8:17 freeze freeze 指令用于停止 undef 和 [poison](https://llvm.org/docs/LangRef. html#poisonvalues) 值。 #Syntax: &lt;result&gt; &#x3D; freeze ty &lt;val&gt; ; yields ty:result Semantics: 如果参数是 undef 或 poison，则 freeze’返回一个任意但固定的类型为 ``ty' 的值。 否则，此指令为空操作并返回输入参数。 同一条freeze指令返回的值的所有使用都保证始终遵守相同的值，而不同的freeze`指令可能会产生不同的值。 虽然 undef 和 poison 指针可以被冻结，但结果是一个不可解引用的指针。 有关详细信息，请参阅 指针别名规则 部分。 如果聚合值或向量被冻结，则操作数按元素冻结。 不考虑聚合的填充，因为如果不将其存储到内存中并以不同的类型加载它，它是不可见的。 # Example: %w &#x3D; i32 undef %x &#x3D; freeze i32 %w %y &#x3D; add i32 %w, %w ; undef %z &#x3D; add i32 %x, %x ; even number because all uses of %x observe ; the same value %x2 &#x3D; freeze i32 %w %cmp &#x3D; icmp eq i32 %x, %x2 ; can be true or false ; example with vectors %v &#x3D; &lt;2 x i32&gt; &lt;i32 undef, i32 poison&gt; %a &#x3D; extractelement &lt;2 x i32&gt; %v, i32 0 ; undef %b &#x3D; extractelement &lt;2 x i32&gt; %v, i32 1 ; poison %add &#x3D; add i32 %a, %a ; undef %v.fr &#x3D; freeze &lt;2 x i32&gt; %v ; element-wise freeze %d &#x3D; extractelement &lt;2 x i32&gt; %v.fr, i32 0 ; not undef %add.f &#x3D; add i32 %d, %d ; even number ; branching on frozen value %poison &#x3D; add nsw i1 %k, undef ; poison %c &#x3D; freeze i1 %poison br i1 %c, label %foo, label %bar ; non-deterministic branch to %foo or %bar call 简单函数调用 call指令代表一个简单的函数调用。 # Syntax: &lt;result&gt; &#x3D; [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(&lt;num&gt;)] &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs] [ operand bundles ] Arguments: https://llvm.org/docs/LangRef.html#id2116 Semantics: call指令用于使控制流转移到指定函数，其传入参数绑定到指定值。 在被调用函数中执行ret指令时，控制流继续执行函数调用之后的指令，并且函数的返回值绑定到结果参数。 # Example: %retval &#x3D; call i32 @test(i32 %argc) call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42) ; yields i32 %X &#x3D; tail call i32 @foo() ; yields i32 %Y &#x3D; tail call fastcc i32 @foo() ; yields i32 call void %foo(i8 signext 97) %struct.A &#x3D; type &#123; i32, i8 &#125; %r &#x3D; call %struct.A @foo() ; yields &#123; i32, i8 &#125; %gr &#x3D; extractvalue %struct.A %r, 0 ; yields i32 %gr1 &#x3D; extractvalue %struct.A %r, 1 ; yields i8 %Z &#x3D; call void @foo() noreturn ; indicates that %foo never returns normally %ZZ &#x3D; call zeroext i32 @bar() ; Return value is %zero extended va_arg 可变参数 va_arg指令用于访问通过函数调用的variable argumen区域传递的参数。 它用于在 C 中实现 va_arg 宏。 # Syntax: &lt;resultval&gt; &#x3D; va_arg &lt;va_list*&gt; &lt;arglist&gt;, &lt;argty&gt; Example: See the variable argument processing section. landingpad LLVM 的异常处理系统 使用landingpad指令来指定一个基本块是一个着陆场——一个异常着陆的地方， 并且对应于在 try/catch 序列的 catch 部分中找到的代码。 它定义了 personality 函数 在重新进入该函数时提供的值。 resultval 的类型为 resultty。 # Syntax: &lt;resultval&gt; &#x3D; landingpad &lt;resultty&gt; &lt;clause&gt;+ &lt;resultval&gt; &#x3D; landingpad &lt;resultty&gt; cleanup &lt;clause&gt;* &lt;clause&gt; :&#x3D; catch &lt;type&gt; &lt;value&gt; &lt;clause&gt; :&#x3D; filter &lt;array constant type&gt; &lt;array constant&gt; # Example: ;; A landing pad which can catch an integer. %res &#x3D; landingpad &#123; i8*, i32 &#125; catch i8** @_ZTIi ;; A landing pad that is a cleanup. %res &#x3D; landingpad &#123; i8*, i32 &#125; cleanup ;; A landing pad which can catch an integer and can only throw a double. %res &#x3D; landingpad &#123; i8*, i32 &#125; catch i8** @_ZTIi filter [1 x i8**] [i8** @_ZTId] catchpad LLVM 的异常处理系统 使用catchpad指令来指定一个基本块开始一个 catch 处理程序- 个性例程试图转移控制以捕获异常的一种。 #Syntax: &lt;resultval&gt; &#x3D; catchpad within &lt;catchswitch&gt; [&lt;args&gt;*] #Example: dispatch: %cs &#x3D; catchswitch within none [label %handler0] unwind to caller ;; A catch block which can catch an integer. handler0: %tok &#x3D; catchpad within %cs [i8** @_ZTIi] cleanuppad LLVM 的异常处理系统使用cleanuppad指令来指定基本块是清理块- 个性例程试图转移控制以运行清理操作的一种。 # Syntax: &lt;resultval&gt; &#x3D; cleanuppad within &lt;parent&gt; [&lt;args&gt;*] # Example: %tok &#x3D; cleanuppad within %cs [] Poison Values A poison value 错误操作的结果。. 为了促进推测执行，许多指令在提供非法操作数时不会立即调用未定义行为，而是返回poison value 。 字符串 poison 可以在任何需要常量的地方使用，并且带有 nsw 标志的 add 等操作可以产生poison value。 Most instructions return ‘poison’ when one of their arguments is ‘poison’. A notable exception is the select instruction. Propagation of poison can be stopped with the freeze instruction. It is correct to replace a poison value with an undef value or any value of the type. This means that immediate undefined behavior occurs if a poison value is used as an instruction operand that has any values that trigger undefined behavior. Notably this includes (but is not limited to): The pointer operand of a load, store or any other pointer dereferencing instruction (independent of address space). The divisor operand of a udiv, sdiv, urem or srem instruction. The condition operand of a br instruction. The callee operand of a call or invoke instruction. The parameter operand of a call or invoke instruction, when the function or invoking call site has a noundef attribute in the corresponding position. The operand of a ret instruction if the function or invoking call site has a noundef attribute in the return value position. Here are some examples: entry: %poison &#x3D; sub nuw i32 0, 1 ; Results in a poison value. %poison2 &#x3D; sub i32 poison, 1 ; Also results in a poison value. %still_poison &#x3D; and i32 %poison, 0 ; 0, but also poison. %poison_yet_again &#x3D; getelementptr i32, i32* @h, i32 %still_poison store i32 0, i32* %poison_yet_again ; Undefined behavior due to ; store to poison. store i32 %poison, i32* @g ; Poison value stored to memory. %poison3 &#x3D; load i32, i32* @g ; Poison value loaded back from memory. %narrowaddr &#x3D; bitcast i32* @g to i16* %wideaddr &#x3D; bitcast i32* @g to i64* %poison4 &#x3D; load i16, i16* %narrowaddr ; Returns a poison value. %poison5 &#x3D; load i64, i64* %wideaddr ; Returns a poison value. %cmp &#x3D; icmp slt i32 %poison, 0 ; Returns a poison value. br i1 %cmp, label %end, label %end ; undefined behavior end:","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"LLVM","slug":"Master/LLVM","permalink":"https://www.sizaif.com/navigation/categories/Master/LLVM/"}],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"LLVM","slug":"LLVM","permalink":"https://www.sizaif.com/tags/LLVM/"}],"author":"sizaif"},{"title":"AFL(american Fuzzy Lop)学习一-补充QEMU模式","slug":"AFL学习-一QEMU模式","date":"2022-04-10T07:47:00.000Z","updated":"2022-04-19T02:42:58.000Z","comments":true,"path":"posts/4bf8181c/","link":"","permalink":"https://www.sizaif.com/posts/4bf8181c/","excerpt":"","text":"QEMU模式测试 @2022-04-10 @sizaif 编译QEMU 参考README.qemu $./build_qemu_support.sh # Cannot use 'python', Python 2.6 or later is required.Note that Python 3 or later is not yet supported. # 安装依赖，将python链接到python2上 $ sudo apt-get install libtool,libtool-bin,bison,libgtk2.0-dev,python2 ================================================= AFL binary-only instrumentation QEMU build script ================================================= [*] Performing basic sanity checks... [+] All checks passed! [+] Cryptographic signature on qemu-2.10.0.tar.xz checks out. [*] Uncompressing archive (this will take a while)... [+] Unpacking successful. [*] Configuring QEMU for ... [*] Applying patches... patching file linux-user/elfload.c patching file accel/tcg/cpu-exec.c patching file linux-user/syscall.c patching file configure patching file util/memfd.c [+] Patching done. Install prefix /usr/local BIOS directory /usr/local/share/qemu binary directory /usr/local/bin library directory /usr/local/lib module directory /usr/local/lib/qemu libexec directory /usr/local/libexec include directory /usr/local/include config directory /usr/local/etc local state directory /usr/local/var Manual directory /usr/local/share/man ELF interp prefix /usr/gnemul/qemu-%M Source path /home/workhome/AFL/qemu_mode/qemu-2.10.0 C compiler cc Host C compiler cc C++ compiler c++ Objective-C compiler cc ARFLAGS rv CFLAGS -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 -g -O3 -ggdb QEMU_CFLAGS -I/usr/include/pixman-1 -I$(SRC_PATH)/dtc/libfdt -pthread -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -fPIE -DPIE -m64 -mcx16 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fno-common -fwrapv -Wexpansion-to-defined -Wendif-labels -Wno-shift-negative-value -Wno-missing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-declaration -Wold-style-definition -Wtype-limits -fstack-protector-strong LDFLAGS -Wl,--warn-common -Wl,-z,relro -Wl,-z,now -pie -m64 -g make make install install python python -B smbd /usr/sbin/smbd module support no host CPU x86_64 host big endian no target list x86_64-linux-user gprof enabled no sparse enabled no strip binaries yes profiler no static build no pixman system SDL support no GTK support no GTK GL support no VTE support no TLS priority NORMAL GNUTLS support no GNUTLS rnd no libgcrypt no libgcrypt kdf no nettle no nettle kdf no libtasn1 no curses support no virgl support no curl support no mingw32 support no Audio drivers oss Block whitelist (rw) Block whitelist (ro) VirtFS support VNC support no xen support no brlapi support no bluez support no Documentation no PIE yes vde support no netmap support no Linux AIO support no ATTR/XATTR support yes Install blobs yes KVM support yes HAX support no TCG support yes TCG debug enabled no TCG interpreter no RDMA support no fdt support yes preadv support yes fdatasync yes madvise yes posix_madvise yes libcap-ng support no vhost-net support yes vhost-scsi support yes vhost-vsock support yes vhost-user support yes Trace backends log spice support no rbd support no xfsctl support no smartcard support no libusb no usb net redir no OpenGL support no OpenGL dmabufs no libiscsi support no libnfs support no build guest agent yes QGA VSS support no QGA w32 disk info no QGA MSI support no seccomp support no coroutine backend ucontext coroutine pool yes debug stack usage no crypto afalg no GlusterFS support no gcov gcov gcov enabled no TPM support yes libssh2 support no TPM passthrough yes QOM debugging yes Live block migration yes lzo support no snappy support no bzip2 support no NUMA host support no tcmalloc support no jemalloc support no avx2 optimization yes replication support yes VxHS block device no [+] Configuration complete. gettid 错误 error: static declaration of ‘gettid’ follows non-static declaration 261 | _syscall0(int, gettid) AFL QEMU模式安装报错（afl-2.52b &amp; qemu-2.10.0）[已解决] util/memfd.c:40:12: error: static declaration of ‘memfd_create 错误 【AFL-qemu安装问题】出现util/memfd.c:40:12: error: static declaration of ‘memfd_create’ follows non-static d $ ./build_qemu_support.sh ········ 省略编译过程 ········ [+] Build process successful! [*] Copying binary... -rwxr-xr-x 1 root root 14238392 Apr 10 07:54 ../afl-qemu-trace [+] Successfully created '../afl-qemu-trace'. [*] Testing the build... [+] Instrumentation tests passed. [+] All set, you can now use the -Q mode in afl-fuzz! # 将afl-qemu-trace 放到与afl-fuzz 同目录下(/usr/local/bin) 并将此目录添加到环境变量即可 编写C++代码测试 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;signal.h&gt; using namespace std; void test (string buf) &#123; int len &#x3D; buf.length(); if (( len &#x3D;&#x3D; 6 &amp;&amp; buf[0] &#x3D;&#x3D; &#39;s&#39; &amp;&amp; buf[1]&#x3D;&#x3D;&#39;i&#39; &amp;&amp; buf[2]&#x3D;&#x3D;&#39;z&#39;)||(len &gt;&#x3D;7 &amp;&amp; buf[0]&#x3D;&#x3D;&#39;x&#39; &amp;&amp; buf[1]&#x3D;&#x3D;&#39;i&#39; &amp;&amp; buf[2]&#x3D;&#x3D;&#39;d&#39; &amp;&amp; buf[3]&#x3D;&#x3D;&#39;i&#39;&amp;&amp; buf[4]&#x3D;&#x3D;&#39;a&#39; &amp;&amp; buf[5]&#x3D;&#x3D;&#39;n&#39;))&#123; cout&lt;&lt;&quot;awesome found sizaif !&quot;&lt;&lt;endl; raise(SIGSEGV); &#125; else&#123; cout&lt;&lt;&quot;sorry not&quot;&lt;&lt;endl; &#125; &#125; int main(int argc, char *argv[]) &#123; string buf &#x3D; &quot;&quot;; cin&gt;&gt;buf; test(buf); return 0; &#125; 编译并进行fuzz $ root@2d34b521fdd5:/home/workhome/afl-test/insc++# afl-fuzz -Q -i in -o crash_qemu ./afltestc++2 afl-fuzz 2.57b by &lt;lcamtuf@google.com> [+] You have 16 CPU cores and 4 runnable tasks (utilization: 25%). [+] Try parallel jobs - see /usr/local/share/doc/afl/parallel_fuzzing.txt. [*] Checking CPU core loadout... [+] Found a free CPU core, binding to #0. [*] Checking core_pattern... [*] Setting up output directories... [+] Output directory exists but deemed OK to reuse. [*] Deleting old session data... [+] Output dir cleanup successful. [*] Scanning 'in'... [+] No auto-generated dictionary tokens to reuse. [*] Creating hard links for all input files... [*] Validating target binary... [*] Attempting dry run with 'id:000000,orig:t.txt'... [*] Spinning up the fork server... [+] All right - fork server is up. len = 6, map size = 58, exec speed = 3060 us [+] All test cases processed. [+] Here are some useful stats: Test case count : 1 favored, 0 variable, 1 total Bitmap range : 58 to 58 bits (average: 58.00 bits) Exec timing : 3060 to 3060 us (average: 3060 us) [*] No -t option specified, so I'll use exec timeout of 20 ms. [+] All set and ready to roll! crash","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"论文","slug":"Master/论文","permalink":"https://www.sizaif.com/navigation/categories/Master/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"AFL","slug":"AFL","permalink":"https://www.sizaif.com/tags/AFL/"},{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"论文","slug":"论文","permalink":"https://www.sizaif.com/tags/%E8%AE%BA%E6%96%87/"}],"author":"sizaif"},{"title":"AFL(american Fuzzy Lop)学习一","slug":"AFL学习-一","date":"2022-04-09T09:58:01.000Z","updated":"2022-04-19T02:42:03.000Z","comments":true,"path":"posts/9cd8386/","link":"","permalink":"https://www.sizaif.com/posts/9cd8386/","excerpt":"","text":"AFL(american fuzzy lop)学习一 @sizaif @2022-04-09 AFL 的模糊方法 基于改进的边缘覆盖 插桩法引导的遗传算法 流程： 插桩 从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）； 选择一些输入文件，作为初始测试集加入输入队列（queue）； 将队列中的文件按一定的策略进行“突变”； 如果经过变异文件更新了覆盖范围，则将其保留添加到队列中; 上述过程会一直循环进行，期间触发了crash的文件会被记录下来。 二进制 改进边缘覆盖： 向目标程序注入以下工具来记录采用了哪些分支和次数 一条边表示为当前基本块(分配了一个随机常数)与前一个基本块(即元组 (prev_location, cur_location))之间的 XOR 覆盖信息存储在一个紧凑共享的64KB的哈希表中，称为跟踪位图(bitmap) 当访问一条边时，通过增加与该特定边的哈希相对应的位图中的值来记录命中 cur_location &#x3D; &lt;COMPILE_TIME_RANDOM&gt;; shared_mem[cur_location ^ prev_location]++; prev_location &#x3D; cur_location &gt;&gt; 1; Instrumenting programs for use with AFL 源代码已知的情况下：编译插桩afl工具： 通用方法： $ CC=/path/to/afl/afl-gcc ./configure # c $ CXX=/path/to/afl/afl-g++ ./configure # c++ $ make clean all 对于clang(afl-clang and afl-clang++) 也适用 $ CC=/path/to/afl/afl-clang-fast ./configure [...options...] $ CXX=/path/to/afl/afl-clang-fast++ ./configure [...options...] $ make 测试(libraries)时， 需要找到或编写一个简单的程序，该程序从stdin或文件中读取数据，并将数据传递给测试库。 将此可执行文件链接到已检测库的静态版本，或者确保在运行时加载正确的**.so**文件(通常通过设置LD_LIBRARY _PATH)。最简单的选择是静态构建，通常通过 $ CC(C++)=/path/to/afl/afl-XXX ./configure --disable-shared Instrumenting binary-only apps 无法获得源码时，针对二进制文件进行fuzzer， 使用QEMU $ cd qemu_mode $ ./build_qemu_support.sh 源码 afl-analyze：用来对用例进行分析，发现其中有意义的字段。 afl-clang++：相当于c++的编译器的封装。 afl-fuzz：AFL主体，用于对目标程序进行fuzz。 afl-gcc：相当于gcc的封装。 afl-plot：生成模糊测试任务的状态图。 afl-tmin：对用例进行简化。 afl-clang：相当于c的编译器封装。 afl-cmin：对用例进行简化。 afl-g++：相当于g++的封装。 afl-gotcpu：用于查看当前CPU状态。 afl-showmap：用于对单个用例执行路径跟踪。 afl-whatsup：用于查看fuzz任务当前的状态。 alf-clang-fast: 基于LLVM高效clang针对c afl-clang-fast++: 基于LLVM高效clang针对c++ 输出 解释输出 在输出目录中创建了三个子目录并实时更新 queue/ 每个独特的执行路径的测试用例，加上用户给出的所有开始文件。这就是第2节提到的合成语料。在将这个语料库用于任何其他目的之前，您可以使用afl-cmin工具将它缩小到更小的大小。该工具将找到提供同等边缘覆盖的较小文件子集。 crashes/ 导致被测试程序接收致命信号的唯一测试用例(例如SIGSEGV, SIGILL, SIGABRT)。这些条目按接收到的信号分组。 hangs/ 导致被测试程序超时的唯一测试用例。在某些东西被归类为挂起之前的默认时间限制大于1秒和-t参数的值。可以通过设置AFL_HANG_TMOUT来微调该值，但很少需要这样做。 运行含义 1) Process timing 指示了Fuzzer测试的时间消耗 +----------------------------------------------------+ | run time : 0 days, 8 hrs, 32 min, 43 sec | | last new path : 0 days, 0 hrs, 6 min, 40 sec | | last uniq crash : none seen yet | | last uniq hang : 0 days, 1 hrs, 24 min, 32 sec | +----------------------------------------------------+ process timing 指示了Fuzzer测试的时间消耗 run time: 运行总时间 last new path: path(触发新执行的测试用例的缩写)，上次执行测试用例的时间,长时间未变化说明有程序有问题，过于简单无分支或内存太小会收到一个红色警告 last uniq crash: 上次崩溃的时间 last uniq hang: 上次挂起的时间 2) Overall results 汇总了fuzzer测试的执行结果。 +-----------------------+ | cycles done : 0 | | total paths : 2095 | | uniq crashes : 0 | | uniq hangs : 19 | +-----------------------+ cycle done: 表明fuzzer的轮数 颜色说明 品红色处于 the first pass， 如果有新发现，颜色会变成黄色， 所有子过程完成后将会变成蓝色， 最后变成绿色的话表明已经长时间没有新的动作了，此时也提示我们应该手动ctrl-c去关闭fuzzing。 total paths: 目前为止执行的测试用例 uniq crashes: 目前为止发现的崩溃 uniq hang: 目前为止发现的挂起 3) Cycle progress 展示了当前队列中fuzzer 执行了多少 +-------------------------------------+ | now processing : 1296 (61.86%) | | paths timed out : 0 (0.00%) | +-------------------------------------+ ow processing: 当前测试用例的进程的ID 因为fuzzer是开启另一个进程进行测试的 结果写回共享内存中 paths timed out: 根据超时决定是否放弃 4) Map coverage +--------------------------------------+ | map density : 10.15% &#x2F; 29.07% | | count coverage : 4.03 bits&#x2F;tuple | +--------------------------------------+ map density：多少个分支元组,命中，与位图的容量成比例.号码在左边描述当前输入;右边的是整体的值是输入语料库。绝对值低于二百说的是表明了以下三种情况之一 程序极其简单;它没有被正确地使用(例如，由于链接到目标的非工具副本图书馆);或者它过早地退出了您的输入测试用例。绒毛会尝试用粉红色标记，只是为了让你意识到。超过70%的百分比可能很少发生在非常复杂的程序大量使用模板生成的代码。将以红色标记高百分比。但是一般不会有红色标记除非你用的是非常复杂的软件(比如v8, perl，ffmpeg)。 count coverage：另一行处理元组命中次数的可变性二进制文件。本质上，如果每一个被取的分支总是取一个固定数量的对于我们尝试过的所有输入，这将是“1.00”。当我们管理为了触发每个分支的其他命中计数，指针将开始移动接近“8.00”(8位地图命中的每一个位)，但可能永远不会达到这一极端。 5) Stage progress 进一步展示了fuzzer的执行过程细节。 +-------------------------------------+ | now trying : interest 32&#x2F;8 | | stage execs : 3996&#x2F;34.4k (11.62%) | | total execs : 27.4M | | exec speed : 891.7&#x2F;sec | +-------------------------------------+ now trying: 指明当前所用的变异输入的方法 参数含义 calibration – 在fuzzing测试之前的阶段，主要是检查执行路径检测异常，建立基线执行速度。 trim L/S – 同样也是在fuzzing测试之前的阶段，修建测试用例使其更短，但保证裁剪后仍能达到相同的执行路径。L表示length长度，S表示stepover步距，其值与文件大小是相关的。 bitflip L/S – 确定性的比特位翻转。以S为增量，L长度的bit数被翻转。有以下几种变型模式：1/1, 2/1, 4/1, 8/8, 16/8, 32/8。 arith L/8 – 确定性的算术运算。AFL会尝试去减去或者加上一些整数使其为8bit/16bit/32bit的值，步距永远是8bits。 interest L/8 – 确定性的值覆盖。AFL自身保留了一些Interesting的8bit/16bit/32bit的值，用这些值去覆盖原有的测试用例，步距永远是8bits。 extras – 确定性的字典注入。这里AFL自身有一个字典，当然也可以使用-x选项来指明使用用户提供的字典。 havoc – 固定长度的堆叠随机扭曲。该阶段会尝试位翻转，用随机数或者Interesting的整数去覆盖，块删除，块复制，以及字典的相关操作。 splice – 最后一种策略。在上述策略都执行完后将会执行该策略，它和havoc差不多，不过它会首先将队列中的两个随机输入先拼接在一起。 sync – 这个是并行执行的策略选项，通过-M或者-S选项进行指定。该策略并不会涉及到真正的fuzzing，会导入从另一个fuzzer得到的输出和测试用例。 以上所有策略执行一遍也就是前文提到的the first pass。 stage execs: 当前阶段的进度指示 total execs: 全局的进度指示 exec speed: 执行速度但是基准测试应该理想地超过500次执行/秒大多数时候——如果它保持在100以下，这项工作可能会非常长。fuzzer也会明确地警告你缓慢的目标。如果发生这种情况,查看fuzzer中包含的perf_tips.txt文件，了解如何提高速度的事情了。 6) Findings in depth 应该是种子变异产生的信息 +--------------------------------------+ | favored paths : 879 (41.96%) | | new edges on : 423 (20.19%) | | total crashes : 0 (0 unique) | | total tmouts : 24 (19 unique) | +--------------------------------------+ favored paths: 基于最小化算法产生新的更好的路径 new edges on: 基于更好路径产生的新边 total crashes: 基于更好路径产生的崩溃 total tmouts: 基于更好路径产生的超时 包括所有超时的超时 即使这些超时不足以分类到hangs. 7) Fuzzing strategy yields 进一步展示了AFL所做的工作，在更有效路径上得到的结果比例 针对的应该是上文的 stage progress的now trying一栏的参数 +-----------------------------------------------------+ | bit flips : 57&#x2F;289k, 18&#x2F;289k, 18&#x2F;288k | | byte flips : 0&#x2F;36.2k, 4&#x2F;35.7k, 7&#x2F;34.6k | | arithmetics : 53&#x2F;2.54M, 0&#x2F;537k, 0&#x2F;55.2k | | known ints : 8&#x2F;322k, 12&#x2F;1.32M, 10&#x2F;1.70M | | dictionary : 9&#x2F;52k, 1&#x2F;53k, 1&#x2F;24k | | havoc : 1903&#x2F;20.0M, 0&#x2F;0 | | trim : 20.31%&#x2F;9201, 17.05% | +-----------------------------------------------------+ bit flips: 确定性的比特位翻转。以S为增量，L长度的bit数被翻转。有以下几种变型模式：1/1, 2/1, 4/1, 8/8, 16/8, 32/8。 byte flips: 这个应该就是字节翻转了 arithmetics: – 确定性的算术运算。AFL会尝试去减去或者加上一些整数使其为8bit/16bit/32bit的值，步距永远是8bits。 known ints: dictionary: havoc:– 固定长度的堆叠随机扭曲。该阶段会尝试位翻转，用随机数或者Interesting的整数去覆盖，块删除，块复制，以及字典的相关操作。 trim:– 同样也是在fuzzing测试之前的阶段，修建测试用例使其更短，但保证裁剪后仍能达到相同的执行路径。L表示length长度，S表示stepover步距，其值与文件大小是相关的。 这个修剪策略有一些不同/ 这一行中的第一个数字显示了从输入中删除的字节的比率，第二个数字表示实现这一目标需要的执行数，第三个数字显示了字节的比例，尽管不可能移除，被视为没有效果，在进行效果更好的fuzzer步骤的时候不是考虑的因素 8) Path geometry 汇总了路径测试的相关信息。 +---------------------+ | levels : 5 | | pending : 1570 | | pend fav : 583 | | own finds : 0 | | imported : 0 | | stability : 100.00% | +---------------------+ levels: 表示测试等级 pending: 表示还没有经过fuzzing的输入数量 pend fav: 表明fuzzer感兴趣的输入数量 own finds: 表示在fuzzing过程中新找到的，或者是并行测试从另一个实例导入的 imported: n/a表明不可用，即没有导入 stability: 表明相同输入是否产生了相同的行为，一般结果都是100%，如果低于100%并且变红，则需要查阅官方文档寻找解决步骤。 9) CPU load [cpu: 25%] 显示了本地系统上的CPU利用率。它是计算处于“可运行”状态的进程数，然后将其与系统上的逻辑核数进行比较。 绿色-则表示使用的CPU核比可用的少 红色-则表示您的CPU可能已经超额订阅运行额外的fuzzers可能不会给你带来任何好处 1 10) Addendum: status and plot files For unattended operation, some of the key status screen information can be also found in a machine-readable format in the fuzzer_stats file in the output directory. This includes: - start_time - unix time indicating the start time of afl-fuzz - last_update - unix time corresponding to the last update of this file - fuzzer_pid - PID of the fuzzer process - cycles_done - queue cycles completed so far - execs_done - number of execve() calls attempted - execs_per_sec - current number of execs per second - paths_total - total number of entries in the queue - paths_found - number of entries discovered through local fuzzing - paths_imported - number of entries imported from other instances - max_depth - number of levels in the generated data set - cur_path - currently processed entry number - pending_favs - number of favored entries still waiting to be fuzzed - pending_total - number of all entries waiting to be fuzzed - stability - percentage of bitmap bytes that behave consistently - variable_paths - number of test cases showing variable behavior - unique_crashes - number of unique crashes recorded - unique_hangs - number of unique hangs encountered - command_line - full command line used for the fuzzing session - slowest_exec_ms- real time of the slowest execution in ms - peak_rss_mb - max rss usage reached during fuzzing in mb c 编译插桩测试 编写alftestc代码 //afltestc.c #include &lt;stdio.h> #include &lt;string.h> #include &lt;stdlib.h> #include &lt;signal.h> void test (char *buf) &#123; int len = strlen(buf); int i = 0; if(buf[0] == 's' &amp;&amp; buf[1] == 'i')&#123; if(buf[2] == 'z' &amp;&amp; buf[3] == 'a')&#123; if(buf[4] == 'i' &amp;&amp; buf[5] == 'f')&#123; if(len == 6)&#123; printf(\"awesome found sizaif !\\n\"); raise(SIGSEGV); &#125;else&#123; printf(\"sorry not\\n\"); &#125; &#125; &#125; &#125; &#125; int main(int argc, char *argv[]) &#123; char buf[1000] = &#123;0&#125;; gets(buf); test(buf); return 0; &#125; 创建configure makefile等文件 root@0187031113b5:/home/workhome/afl-test/ins-c# ls Makefile.am aclocal.m4 autom4te.cache compile config.h.in configure depcomp missing Makefile.in afltestc.c autoscan.log config.h config.log configure.ac install-sh stamp-h1 使用afl-gcc 插桩 afl-gcc插桩 root@0187031113b5:/home/workhome/afl-test/ins-c# CC=afl-gcc ./configure checking for a BSD-compatible install... /usr/bin/install -c checking whether build environment is sane... yes checking for a thread-safe mkdir -p... /usr/bin/mkdir -p checking for gawk... no checking for mawk... mawk checking whether make sets $(MAKE)... yes checking whether make supports nested variables... yes checking for gcc... afl-gcc checking whether the C compiler works... yes checking for C compiler default output file name... a.out checking for suffix of executables... checking whether we are cross compiling... no checking for suffix of object files... o checking whether we are using the GNU C compiler... yes checking whether afl-gcc accepts -g... yes checking for afl-gcc option to accept ISO C89... none needed checking whether afl-gcc understands -c and -o together... yes checking whether make supports the include directive... yes (GNU style) checking dependency style of afl-gcc... gcc3 checking that generated files are newer than configure... done configure: creating ./config.status config.status: creating Makefile config.status: creating config.h config.status: executing depfiles commands 编译运行 root@0187031113b5:/home/workhome/afl-test/ins-c# make afl_harden=1 make all-am make[1]: Entering directory '/home/workhome/afl-test/ins-c' afl-gcc -DHAVE_CONFIG_H -I. -g -O2 -MT afltestc.o -MD -MP -MF .deps/afltestc.Tpo -c -o afltestc.o afltestc.c afl-cc 2.57b by &lt;lcamtuf@google.com> afltestc.c: In function 'main': afltestc.c:26:5: warning: implicit declaration of function 'gets'; did you mean 'fgets'? [-Wimplicit-function-declaration] 26 | gets(buf); | ^~~~ | fgets afl-as 2.57b by &lt;lcamtuf@google.com> [+] Instrumented 11 locations (64-bit, non-hardened mode, ratio 100%). mv -f .deps/afltestc.Tpo .deps/afltestc.Po afl-gcc -g -O2 -o afltestc afltestc.o afl-cc 2.57b by &lt;lcamtuf@google.com> /usr/bin/ld: afltestc.o: in function `main': /home/workhome/afl-test/ins-c/afltestc.c:26: warning: the `gets' function is dangerous and should not be used. make[1]: Leaving directory '/home/workhome/afl-test/ins-c' 创建 in,crash 文件夹 in 中创建初始seed ： hello.txt # hello.txt hello afl-fuzz 运行 $ afl-fuzz -d -i in -o crash ./afltestc root@0187031113b5:/home/workhome/afl-test/ins-c# afl-fuzz -d -i in -o crash ./afltestc afl-fuzz 2.57b by &lt;lcamtuf@google.com> [+] You have 16 CPU cores and 3 runnable tasks (utilization: 19%). [+] Try parallel jobs - see /usr/local/share/doc/afl/parallel_fuzzing.txt. [*] Checking CPU core loadout... [+] Found a free CPU core, binding to #0. [*] Checking core_pattern... [*] Setting up output directories... [*] Scanning 'in'... [+] No auto-generated dictionary tokens to reuse. [*] Creating hard links for all input files... [*] Validating target binary... [*] Attempting dry run with 'id:000000,orig:hello.txt'... [*] Spinning up the fork server... [+] All right - fork server is up. len = 6, map size = 4, exec speed = 164 us [+] All test cases processed. [+] Here are some useful stats: Test case count : 1 favored, 0 variable, 1 total Bitmap range : 4 to 4 bits (average: 4.00 bits) Exec timing : 164 to 164 us (average: 164 us) [*] No -t option specified, so I'll use exec timeout of 20 ms. [+] All set and ready to roll! crash if(buf[0] == 's' &amp;&amp; buf[1] == 'i')&#123; if(buf[2] == 'z' &amp;&amp; buf[3] == 'a')&#123; if(buf[4] == 'i' &amp;&amp; buf[5] == 'f')&#123; if(len == 6)&#123; printf(\"awesome found sizaif !\\n\"); raise(SIGSEGV); &#125;else&#123; printf(\"sorry not\\n\"); &#125; &#125; &#125; &#125; 当输入seed 突变为sizaif，且长度为6时，crash plot 使用afl-clang-fast 插桩: root@0187031113b5:/home/workhome/afl-test/ins-c# CC=afl-clang-fast ./configure checking for a BSD-compatible install... /usr/bin/install -c checking whether build environment is sane... yes checking for a thread-safe mkdir -p... /usr/bin/mkdir -p checking for gawk... no checking for mawk... mawk checking whether make sets $(MAKE)... yes checking whether make supports nested variables... yes checking for gcc... afl-clang-fast checking whether the C compiler works... yes checking for C compiler default output file name... a.out checking for suffix of executables... checking whether we are cross compiling... no checking for suffix of object files... o checking whether we are using the GNU C compiler... yes checking whether afl-clang-fast accepts -g... yes checking for afl-clang-fast option to accept ISO C89... none needed checking whether afl-clang-fast understands -c and -o together... yes checking whether make supports the include directive... yes (GNU style) checking dependency style of afl-clang-fast... gcc3 checking that generated files are newer than configure... done configure: creating ./config.status config.status: creating Makefile config.status: creating config.h config.status: executing depfiles commands 编译运行 oot@0187031113b5:/home/workhome/afl-test/ins-c# make afl_harden=1 make all-am make[1]: Entering directory '/home/workhome/afl-test/ins-c' afl-clang-fast -DHAVE_CONFIG_H -I. -g -O2 -MT afltestc.o -MD -MP -MF .deps/afltestc.Tpo -c -o afltestc.o afltestc.c afl-clang-fast 2.57b by &lt;lszekeres@google.com> afltestc.c:26:5: warning: implicit declaration of function 'gets' is invalid in C99 [-Wimplicit-function-declaration] gets(buf); ^ afl-llvm-pass 2.57b by &lt;lszekeres@google.com> [+] Instrumented 11 locations (non-hardened mode, ratio 100%). 1 warning generated. mv -f .deps/afltestc.Tpo .deps/afltestc.Po afl-clang-fast -g -O2 -o afltestc afltestc.o afl-clang-fast 2.57b by &lt;lszekeres@google.com> /usr/bin/ld: afltestc.o: in function `main': /home/workhome/afl-test/ins-c/afltestc.c:26: warning: the `gets' function is dangerous and should not be used. make[1]: Leaving directory '/home/workhome/afl-test/ins-c' 创建 in,crash 文件夹 in 中创建初始seed ： hello.txt # hello.txt abc afl-fuzz 运行 $ afl-fuzz -d -i in -o crash2 ./afltestc root@0187031113b5:/home/workhome/afl-test/ins-c# afl-fuzz -d -i in -o crash2 ./afltestc afl-fuzz 2.57b by &lt;lcamtuf@google.com> [+] You have 16 CPU cores and 2 runnable tasks (utilization: 12%). [+] Try parallel jobs - see /usr/local/share/doc/afl/parallel_fuzzing.txt. [*] Checking CPU core loadout... [+] Found a free CPU core, binding to #0. [*] Checking core_pattern... [*] Setting up output directories... [*] Scanning 'in'... [+] No auto-generated dictionary tokens to reuse. [*] Creating hard links for all input files... [*] Validating target binary... [*] Attempting dry run with 'id:000000,orig:hello.txt'... [*] Spinning up the fork server... [+] All right - fork server is up. len = 4, map size = 3, exec speed = 152 us [+] All test cases processed. [+] Here are some useful stats: Test case count : 1 favored, 0 variable, 1 total Bitmap range : 3 to 3 bits (average: 3.00 bits) Exec timing : 152 to 152 us (average: 152 us) [*] No -t option specified, so I'll use exec timeout of 20 ms. [+] All set and ready to roll! crash plot c++ 编译插桩测试 编写afltestc++代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;signal.h&gt; using namespace std; void test (string buf) &#123; int len &#x3D; buf.length(); if ( len &#x3D;&#x3D; 6 &amp;&amp; buf[0] &#x3D;&#x3D; &#39;s&#39; &amp;&amp; buf[1]&#x3D;&#x3D;&#39;i&#39; &amp;&amp; buf[2]&#x3D;&#x3D;&#39;z&#39;)&#123; cout&lt;&lt;&quot;awesome found sizaif !&quot;&lt;&lt;endl; raise(SIGSEGV); &#125; else&#123; cout&lt;&lt;&quot;sorry not&quot;&lt;&lt;endl; &#125; &#125; int main(int argc, char *argv[]) &#123; string buf &#x3D; &quot;&quot;; cin&gt;&gt;buf test(buf); return 0; &#125; 使用afl-g++插桩 : root@0187031113b5:/home/workhome/afl-test/ins-c++# afl-g++ -g -o afltestc++ afltestc++.cpp afl-cc 2.57b by &lt;lcamtuf@google.com> afl-as 2.57b by &lt;lcamtuf@google.com> [+] Instrumented 41 locations (64-bit, non-hardened mode, ratio 100%). 运行 root@0187031113b5:/home/workhome/afl-test/ins-c++# afl-fuzz -b 6 -i in -o crashc++ ./afltestc++ afl-fuzz 2.57b by &lt;lcamtuf@google.com> [+] You have 16 CPU cores and 2 runnable tasks (utilization: 12%). [+] Try parallel jobs - see /usr/local/share/doc/afl/parallel_fuzzing.txt. [*] Checking CPU core loadout... [+] Found a free CPU core, binding to #6. [*] Checking core_pattern... [*] Setting up output directories... [*] Scanning 'in'... [+] No auto-generated dictionary tokens to reuse. [*] Creating hard links for all input files... [*] Validating target binary... [*] Attempting dry run with 'id:000000,orig:hello.txt'... [*] Spinning up the fork server... [+] All right - fork server is up. len = 29, map size = 15, exec speed = 212 us [+] All test cases processed. [+] Here are some useful stats: Test case count : 1 favored, 0 variable, 1 total Bitmap range : 15 to 15 bits (average: 15.00 bits) Exec timing : 212 to 212 us (average: 212 us) [*] No -t option specified, so I'll use exec timeout of 20 ms. [+] All set and ready to roll! crash plot 使用afl-clang-fast++ root@0187031113b5:/home/workhome/afl-test/ins-c++# afl-clang-fast++ -g -o afltestc++clang afltestc++.cpp afl-clang-fast 2.57b by &lt;lszekeres@google.com> afl-llvm-pass 2.57b by &lt;lszekeres@google.com> [+] Instrumented 127 locations (non-hardened mode, ratio 100%). crash plot","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"论文","slug":"Master/论文","permalink":"https://www.sizaif.com/navigation/categories/Master/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"AFL","slug":"AFL","permalink":"https://www.sizaif.com/tags/AFL/"},{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"论文","slug":"论文","permalink":"https://www.sizaif.com/tags/%E8%AE%BA%E6%96%87/"}],"author":"sizaif"},{"title":"Linux 下C/C++ 生成Configure 和Makefile","slug":"linux-下C-C-生成Configure-和Makefile","date":"2022-04-09T03:58:13.000Z","updated":"2022-04-09T05:09:46.000Z","comments":true,"path":"posts/f4dff8fd/","link":"","permalink":"https://www.sizaif.com/posts/f4dff8fd/","excerpt":"","text":"linux 下C/C++ 生成Configure 和Makefile 前提： automake 简要步骤 编写test.c 运行autoscan 运行mv configure.scan configure.ac 修改configure.ac中内容 # -*- Autoconf -*- # Process this file with autoconf to produce a configure script. AC_PREREQ([2.69]) AC_INIT(test, 1.0, sizaif@mail.com) AC_CONFIG_SRCDIR([test.cpp]) AC_CONFIG_HEADERS([config.h]) AM_INIT_AUTOMAKE # 增加 # Checks for programs. AC_PROG_CXX AC_PROG_CC # Checks for libraries. # Checks for header files. # Checks for typedefs, structures, and compiler characteristics. AC_TYPE_SIZE_T # Checks for library functions. AC_CONFIG_FILES([Makefile]) 运行aclocal 创建Makefile.am AUTOMAKE_OPTIONS&#x3D;foreign # 固定写法 bin_PROGRAMS&#x3D;test # 生成的可执行文件名称 test_SOURCES&#x3D;test.c # 可执行文件名称_SOURCES 运行automake --add-missing 运行autoconf 生成configure 文件 执行./configure就可以得到Makefile , 以及config.h文件","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Linux","slug":"技术向/Linux","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Linux/"}],"tags":[{"name":"make","slug":"make","permalink":"https://www.sizaif.com/tags/make/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.sizaif.com/tags/ubuntu/"}],"author":"sizaif"},{"title":"模糊测试技术","slug":"模糊测试技术","date":"2022-04-07T06:49:59.000Z","updated":"2022-04-07T06:52:08.000Z","comments":true,"path":"posts/d619a3ee/","link":"","permalink":"https://www.sizaif.com/posts/d619a3ee/","excerpt":"","text":"模糊测试技术 2022-01-09- [TOC] 模糊测试基本流程: 预处理(preprocessing)、输入数据构造(input building)、输入选择(input selection)、评估(evalution)、结果分析(post-fuzzing) 2013年AFL诞生,基于覆盖率引导的模糊测试成为主流方向 AFL 是覆盖率为导向的模糊测试工具,通过插桩的方法,采集输入数据对应的边覆盖率,作为模糊测试种子选取的衡量指标．通过使用进化算法以及精心构造的突变策略 预处理 工作: 搜集目标相关信息并制定模糊测试的策略, 为监控目标在测试中的运行状态做必要的准备．通常依赖于插桩、符号执行以及污点分析这类程序分析技术 搜集目标相关信息,比如目标的输入数据格式、目标的内部结构,并为监控测试中目标的状态变化做必要的准备．该环节面临的挑战是:使用什么程序分析技术,以及模糊测试究竟需要对目标内部信息有多详细的了解 根据模糊测试对程序内部信息分析的程度,现代的模糊测试方法可以划分为３类:黑盒模糊测试 (blackＧboxfuzzing)、灰盒模糊测试(greyＧboxfuzzing) 和白盒模糊测试(whiteＧboxfuzzing) 1. 插桩: 插桩技术通过向目标的代码中合适的位置添加预设好的代码,获得程序的静态或动态执行信息．比如程序的抽象语法树,覆盖率以及函数内变量取值等 动态插桩 动态插桩则是在运行的过程中对运行过的代码 进行插桩．比如利用 QEMU等模拟技术,进行动态插桩,可以获得程序运行时的信息,缺点是资源的开销大 静态插桩 通过 GCC编译器在汇编语言上插 桩,LLVM在生成的中间语言LLVMIR(low level virtual machine intermediate representation)上插桩．优点是节省时间、速度快,缺点是依赖于程序源码． 插桩技术的缺点是会带来资源的开销 2. 符号执行 将程序行为的推理归结为逻辑领域的推理,通过构建一个表示程序执行的逻辑公式,可以同时推断一个程序在不同输入上的行为． 该方法可以使模糊测试获得较好的覆盖率,并可以深入到程序深处,探寻可能存在漏洞的区域 静态符号执行 静态符号执行通常会因为程序中循环和递归的存在,陷入到路径爆炸中,还会因为路径约束中包含诸如取Hash值等操作,导致约束求解失败．由于存在这2种问题,使用较多的是动态符号执行 动态符号执行 动态符号执行通过对程序进行实际执行与符号化执行,维护程序的实际状态和符号化状态,通过将难以求解的约束替换为实际值,缓解了静态符号执行的问题,并按照深度优先的搜索策略对目标程序进行了探索． 存在的问题: ①由于程序分支的存在,路径爆炸的问题仍然存在,程序越复杂, 路径爆炸的问题就越严重．解决的一种办法是通过启发式的方法,选择比较重要的路径进行探索． ②虽然动态符号执行使用实际值替换的方法,解决了一 部分静态符号执行无法绕过的约束,但是也会丢失 一些路径,造成探索结果的不完整． ③所有的符号执行技术都受限于约束求解方法的能力,比如如何处理类似取余操作这样的非线性约束,仍然是符号执行面临的挑战 为了能够将符号执行更好地应用到模糊测试中,近年来诞生了一些工作, 比如Pangolin 通过 [22] 允许符号执行重用之前的计算结果, Intriguer通 [23]过利用字段级的信息,都实现了对符号执行过程的加速． ILF[24] 通过使用神经网络,对由符号执行专家生成的大量高质量输入数据进行学习,得到了合适 的模糊测试策略 [２２] Huang Heqing,Yao Peisen,Wu Rongxin,et al．Pangolin incremental hybrid fuzzing with polyhedral path abstraction [C]∕∕ Procofthe２０２０IEEE Sympon Security and Privacy (SP)．Piscataway,NJ:IEEE,２０２０:１６１３１６２７ [２３] Cho M,Kim S,Kwon T．Intriguer field-level constraint solving for hybrid fuzzing [C]∕∕ procofthe２０１９ ACM SIGSAC Conf on Computer and Communications Security． New York: ACM,２０１９:５１５５３０ [２４] He Jingxuan,Balunovi M,AmbroladzeN,et al．Learning to fuzz from symbolic execution with application to smart contracts[C]∕∕Procofthe２０１９ ACM SIGSAC Conf on Computer and Communications Security．New York:A CM, ２０１９:５３１５４８ 3. 污点分析 该技术会观测程序中,哪些程序数据受到了预先准备好的污染源(比如输入)的污染,目的是跟踪污染源和汇聚点(比如有敏感信息的程序数据)之间的信息流 静态污点分析 静态污点分析不需要程序实际运行,通过对程序静态分析,获得程序控制流图、抽象语法树等信息, 依据数据流以及依赖关系进行污点分析; 动态污点分析 动态污点分析则是在程序实际执行的过程中,利用程序的动态执行信息进行污点分析 动态污点分析检测的可信度更高,但是检测结果是否全面, 取决于动态污点分析对程序的覆盖情况,而且动态污点分析会消耗更多的资源; 静态污点分析又会和符号执行一样,可能会陷入到路径爆炸中,而简化后的静态污点分析又存在着严重的过度污染问题 将污点分析技术应用到模糊测试中,并降低其资源消耗是近年来的重要研究方向．比如GREYONE [２５]尝试通过减少污点分析跟踪的对象、降低污点分析的开销、提升模糊测试的检测效率． [２５] GanShuitao,ZhangChao,ChenPeng,etal．GREYONE dataflowsensitivefuzzing[C]∕∕Procofthe２９thUSENIX SecuritySymposium．Berkeley,CA:USENIXAssociation, ２０２０:２５７７２５９４ 基于AFL的模糊测试方法 输入构造 种子获取、种子筛选、种子突变 具体的挑战是如何在尽量满足语法语义检查的情况下,短时间内生成 大量的输入,用以对目标做全面而深入分析． 首先得到一个数据 $S$ ,然后数据 $S$ 按照一 定的策略进行一定次数的变异,获得大量新数据 $I$ , 最后将$I$输入到被测试对象中进行测试．其中数据 $S$ 被称为种子(seed), $I$ 是测试实际使用的输入数据 评估 现阶段的研究都会聚焦于模糊测试器在２个指标上的表现:覆盖率和暴露漏洞平均时间 覆盖率是软件测试中的一个衡量指标,指的是在测试过程中,对象被覆盖到的数目占总数的比例． 通常而言,高覆盖率更可能发现更多的隐藏漏洞,众多研究因此集中在覆盖率提升上 AFL 使用上下文无关的边覆盖率作为评估指标． [13] Angora 使用上下文敏感的分支覆盖率．[42] VUzzer 使用了块覆盖率替代边覆盖率作为覆盖率评估的对象．[41] 暴露漏洞平均时间: 暴露 漏 洞 平 均 时 间 被 Böhme４６] AFLGo 选 做 评 估 指 标．在 与 基 准 模 糊 工 具 [４６] AFL 的对比实验中,AFLGo 复现单个漏洞的 [１３] [４６] 时间远比AFL少,这证明了该评估指标的有效性． 此后Hawakeye[４７] 同样使用了这一指标来证明其性 能．Parmesan 在通过sanitizer来发现潜在漏洞的 [６３] 研究工作中,也是用暴露漏洞平均时间作为评估指 标同Angora [４２] 等定向灰盒模糊工具进行比较 结果分析 结果分析发生在模糊测试结束以后,主要目的是对于模糊测试的输出信息进行分析和处理 具体应用场景下的模糊测试 物联网中的模糊测试 主要面临两个问题: 将模糊测试应用到物联网领域问题就是特定物联网设备上运行的程序通常对于其实际硬件的配置有着高度的依赖性． ​ 简单的从固件中提取一个用户级别的程序,然后使用模糊测试进行检测,通常是行不通的 Iot-Fuzzer[３０] 认为大多数物联网设备通过其官方移动应用程序进行控制,并且此类应用程序通常包含有与设备进行通信所使用协议的丰富信息,因此通过识别和重用特定于程序的逻辑(比如加密)来改变测试用例(尤其是消息字段),就能够有效地对物联网目标进行模糊测试,而无需依赖于有关其协议规范的任何知识． 物联网设备远远无法满足模糊测试需要的吞吐率 多项研究成果表明物联网设备采用全仿真的系统,可以获得最高的吞吐量,这是因为真实的物联网设备相比于桌面工作站或者服务器要慢得多 内核安全中的模糊测试 内核模糊测试通常利用暴露出来的系统调用接口和外围接口,从用户空间进入到内核组件中进行模糊测试,以检测内核中可能存在的漏洞 主要面临的问题: Windows内核程序以及很多相关组件的源代码并 不开源,将导致传统的反馈机制不再适用． 内核中的代码由于存在中断、多线程操作等机制,使得模糊测试变的很复杂． 内核模糊测试一旦检测到程序的崩溃,将会导致整个操作系统重新启动,极大地影响了模糊测试的效率． 为了克服这些问题,产生了一些专门针对内核安全进行模糊测试的研究, 比如syzkaller [７０] 是由Google开发的一种以获得高覆盖率为导向的内核 模糊测试工具,目前实际使用比较多,并经常被用于对比实验中． Razzer[７１] 是基于syzkaller [７０] 通过使用LLVM和修改后的SVF技术针对内核中存在的数据争用问题进行的模糊测试 TriforceAFL[３６] AFL [１３]的QEMU模式,在系统模拟器的帮助下,通过跟踪分支信息,对Linux的内核进行模糊测试． kAFL[３７] 通过利用Intel提供的进程追踪技术,获取代码运行时的控制流信息,并通过使用Intel的硬件 虚拟特征(VTＧx)提升效率并使得kAFL[３７] 独立于特定的操作系统 传统的模糊测试应用到内核模糊测试上将面临着众多的问题,包 括内核态代码的复杂执行环境,以及内核崩溃的处 理问题．另外内核安全面临的威胁来源是不确定的, 可以是外部固件,也可以是第三方开发的驱动程序, 还可以是内核程序自身设计的问题．模糊测试在内 核安全领域的应用还有待进一步的研究． 静态分析或模糊检测技术通常对内存溢出等漏洞有效,而无法挖掘协议实现库的逻辑漏洞. 通过提取安全协议实现的状态机,能够实现对协议实现的形式化建模.","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"论文","slug":"Master/论文","permalink":"https://www.sizaif.com/navigation/categories/Master/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"论文","slug":"论文","permalink":"https://www.sizaif.com/tags/%E8%AE%BA%E6%96%87/"}],"author":"sizaif"},{"title":"Tlspuffin-Docker:changelog","slug":"tlspuffin-docker-changelog","date":"2022-03-15T03:02:38.000Z","updated":"2022-03-15T03:12:24.000Z","comments":true,"path":"posts/95953aea/","link":"","permalink":"https://www.sizaif.com/posts/95953aea/","excerpt":"","text":"1.6.0 修复deps/rust-openssl-src 文件权限util/dmod 权限问题修复 makedepend: not foundapt-get install xutils-dev修改主版本号pust到dcokerhub稳定版本 1.3.0 - 1.5.0 修复编译错误 1.2.0 增加openssl1.01f的依赖 1.1.0 增加openssl1.01f支持 1.0.0 移植到docker中初始src","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"论文","slug":"Master/论文","permalink":"https://www.sizaif.com/navigation/categories/Master/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/tags/Master/"}],"author":"sizaif"},{"title":"Tlspuffin 切换LUT版本","slug":"tlspuffin-切换LUT版本","date":"2022-03-04T13:03:48.000Z","updated":"2022-03-15T03:04:20.000Z","comments":true,"path":"posts/ed5ef6e5/","link":"","permalink":"https://www.sizaif.com/posts/ed5ef6e5/","excerpt":"","text":"说明 当前的缺陷 只有openssl1.1.1k 和libressl（存疑) 支持Security Violation Oracle 文献8.2.2节 Improved Security Violation Oracle In Section 5.2 we designed a bug oracle which is able to check security properties. Right now we only check after successful handshakes whether no security violation happened. For example whether a downgrade or authentication bypass happened. This could be extended by also verifying invariants during the execution of a handshake. That way we could for example detect the FREAK vulnerability automatically. Furthermore, the security violation oracle could also be extended to other TLS implementations. Right now only OpenSSL 1.1.1k is supported. Support for checking security violations could be ported to LibreSSL 3.3.3 and backported to OpenSSL 1.0.x. 那么切换到其他版本的时候，暂时不能使用Oracle deps的关系 Tlspuffin 顶层 Cargo.toml中定义 features中openssl版本, 以及依赖rust-openssl/openssl rust-openssl/openssl Cargo.toml中定义vendored-openssl版本，以及依赖openssl-sys openssl-sys Cargo.toml中定义细化的vendored-openssl版本，以及依赖openssl-srs 功能: cfg定义对应的openssl版本绑定 路径: src&#x2F;openssl_binding.rs&#x2F;fn create_openssl_server 功能: 定义features对应的版本源码位置 路径: deps&#x2F;rust-openssl-src&#x2F;src&#x2F;lib.rs&#x2F;fn source_dir 步骤 rust-openssl-src 文件存放 openssl的各版本源码 修改Tlspuffin 顶层Cargo.toml 添加版本名称 根据依赖依次添加版本信息 在两个路径文件中添加对应的信息 编译其他版本 方式一： 修改 顶层Cargo.toml 文件中 [features] 项中 default 参数 [features] default = [\"sancov_libafl\", \"openssl111j\", \"introspection\"] 方式二： 使用cargo 命令 添加参数 $ cargo run --no-default-features --features openssl102u,sancov_libafl,introspection sancov_libafl,introspection 必须项","categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"论文","slug":"Master/论文","permalink":"https://www.sizaif.com/navigation/categories/Master/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/tags/Master/"}],"author":"sizaif"},{"title":"Miui13-mi10s刷twrp和Magisk","slug":"Miui13-mi10s刷twrp和Magisk","date":"2022-03-01T10:20:02.000Z","updated":"2022-03-08T11:58:59.000Z","comments":true,"path":"posts/9d7955fe/","link":"","permalink":"https://www.sizaif.com/posts/9d7955fe/","excerpt":"","text":"前言 待手机解锁BL锁后, 尝试开始刷机 目标: 刷SkyMi星空包-miui13 官改包高级包 刷入Magisk v24.1面具 以及EDXP,实现绕过ROOT检测 步骤 解BL锁 前提条件 手机与账号绑定168h 电脑安装好相应的adb驱动 电脑安装好mifash驱动 连接手机，手机设置usb调试后, 开启OEM调试 在platform-tools目录下 先查看是否连接成功 $./adb.exe devices 进入fastboot模式 $./adb.exe reboot bootloader 电脑进入miflash 登录账号后进行解锁 刷入Twrp 前提条件 BL已解锁 需要PC /笔记本电脑和USB数据线 电脑安装好相应的adb驱动 电脑安装好mifash驱动 提前下载好对应的Twrp版本 提前做好备份 手机有足够的电量 USB Drivers: Xiaomi USB Drivers Download ADB and Fastboot and install them on your PC TWRP Recovery Details File Name TWRP Recovery Version 3.6.0 Support Unofficial Developer TheRomFan 连接手机，手机设置usb调试后,开启OEM调试 在platform-tools目录下 进入fastboot模式 $./adb.exe reboot bootloader 查看fastboot设备信息 $./fastboot.exe devices Devices with A/B partition scheme twrp.img为下载的twrp名称 刷入boot ， 临时进入twrp $./fastboot.exe boot twrp.img 将twrp.img文件复制到设备 $ ./adb.exe push twrp.img /sdcard 进入到twrp中 $./fastboot.exe oem reboot-recovery 选择 Install Recovery Ramdisk 选择刚刚复制进去的twrp.img 重启recovery 安装Magisk magisk root权限的正确获得方法是修补你目前系统的boot，再通过电脑adb命令刷入修补后的boot。 错误方法: 先获得官方root权限，再给magisk manager权限来让其直接刷入magisk来获得root权限。 首先要有一个概念，小米11（后文均代指出厂就是安卓11）的手机与之前的小米/红米是不一样的（哪怕后来从10升级了安卓11），小米11使用的是V a/b的分区形式。不同于其他手机，其他手机的启动流程图可以大致参考一下 拿到boot.img 新版本需要先解压payload.bin，然后需要一个工具来二次解包工具在这里 aili.lanzoux.com/ii2lkkp079g密码:5b8x) 这个工具很简单，包里也有readme，大概意思就是把payload.bin放入input，运行exe，到output去找解压出的boot.img包就行 手机上安装Magisk Manager 将刚刚提取到的boot.img移到手机里，打开梯或者更改面具的自定义通道， 然后回到主界面选择Magisk的安装 Magisk安装 此处选择并修补一个文件，选择到刚刚移入手机的boot.img，等待修补完成，在同目录下会生成boot_patch.img文件。 此处不可选择直接安装（推荐），原因后面会说 将这个修补的boot_patch.img移回电脑。开始线刷， $fastboot flash boot_a boot_patched.img $fastboot flash boot_b boot_patched.img 为什么面具不能选择直接安装（推荐）？ 如果你提前已经获取了官方Root，这一步你当然可以正常运行并且刷好面具。但为了绕过银行等APPRoot检测，使的Magiskhide正常发挥作用。使用官方Root获取到面具，面具接管了你的官方Root，当你使用hide时，面具的Root被隐藏了，官方的Root就恢复了（对该应用）。所以应用能检测出Root，而且很难再把官方Root去隐藏。本教程压根就不刷官方Root直接获取面具Root，所以Magiskhide能正常发挥作用（并且大多数情况是绝对够用的）。 你当然也能再刷一个某某银行去Root的模块，但是不麻烦么？明明自带的腿就能发挥作用，你先砍断他的腿在给他接上，这不是多此一举？而且模块越多稳定性啊软件更新啊都是问题。一劳永逸的方法不好么？ Magisk 隐藏生效 [填坑] 星空ROM包 经过测试后， 星空集成的ROM包与Twrp无法同时存在 刷入Twrp后， 使用Twrp卡刷ROM后，twrp会自动回滚成官方recovery 没刷内核的原因。 星空ROM自动线刷卡刷两种方式，集成Magisk。 所以没有必要使用Twrp 前提： 安装好usb驱动 安装好adb命令 临时使用Twrp方式： $./fastboot.exe boot twrp.img 进入Twrp $./fastboot.exe oem reboot-recovery","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"}],"tags":[{"name":"fastboot","slug":"fastboot","permalink":"https://www.sizaif.com/tags/fastboot/"},{"name":"驱动","slug":"驱动","permalink":"https://www.sizaif.com/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"miflash unlock","slug":"miflash-unlock","permalink":"https://www.sizaif.com/tags/miflash-unlock/"}],"author":"sizaif"},{"title":"解决Win10 Fastboot驱动问题","slug":"解决win10-fastboot驱动问题","date":"2022-03-01T09:30:15.000Z","updated":"2022-03-01T09:51:33.510Z","comments":true,"path":"posts/c1ff5c7b/","link":"","permalink":"https://www.sizaif.com/posts/c1ff5c7b/","excerpt":"","text":"前言 小米手机解锁BL, 使用从官网下载的解锁工具 (miflash_unlock-6.5.224.28 版本自身不带win10 驱动)导致出现即使连接手机后也显示: 当前未连接手机 解决方法 下载驱动: google_latest_usb_driver_windows 解压后目录下有个: android_winusb.inf 文件 打开设备管理器 其他设备里找到 Android类似带有!不正常驱动 更新驱动程序-&gt;浏览我的计算机以查找驱动程序 让我从计算机上的可用驱动程序列表选取-&gt;下一步-&gt;从磁盘安装 选择从磁盘安装 选择android_winusb.inf文件 下一步安装等待安装完成后即可 刷新其他设备, 驱动变的可用如图 安装ADB platform-tools_r31.0.3-windows.zip 手机开发者选项里设置 USB 调试, OEM启动 后 在platform文件夹下打开控制台输入 # 查看设备 $ ./adb.exe devices List of devices attached 2b24874b device # 进入fastboot模式 $./adb.exe reboot bootloader # 等待手机进入fastboot后 查看fastboot信息 $ ./fastboot.exe devices 2b24874b fastboot # 手机重启 $ ./fastboot.exe reboot Rebooting OKAY [ 0.001s] Finished. Total time: 0.002s 使用miflash unlock 解BL锁 此时登录账户后, 可正常解锁","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"}],"tags":[{"name":"fastboot","slug":"fastboot","permalink":"https://www.sizaif.com/tags/fastboot/"},{"name":"驱动","slug":"驱动","permalink":"https://www.sizaif.com/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"miflash unlock","slug":"miflash-unlock","permalink":"https://www.sizaif.com/tags/miflash-unlock/"}],"author":"sizaif"},{"title":"AD与AAD区别和联系","slug":"AD与AAD区别和联系","date":"2022-02-23T09:43:25.000Z","updated":"2022-04-10T08:59:50.000Z","comments":true,"path":"posts/2036bda7/","link":"","permalink":"https://www.sizaif.com/posts/2036bda7/","excerpt":"","text":"AD 与AAD 的区别与联系 2022-01-07 [TOC] AD是什么 Active Directory(AD) 活动目录 Active Directory (AD)是一个数据库和一组服务，将用户与他们完成工作所需的网络资源连接起来。 活动目录(Active Directory)主要提供以下功能：1、服务器及客户端计算机管理，2、用户服务，3、资源管理，4、桌面配置，5、应用系统支撑等。 AD（Active Directory）概述： 传统AD依赖于Kerbose进行身份验证，Kerbose又叫做三头狗，要求计算机、用户和域控三方都要参与验证。因此，在传统AD中，计算机也拥有账号，也需要加域。另外，计算机也有登录到域的过程，甚至可以授权计算机账号访问文件夹和其他资源。在传统AD中，所有以Local System、Network Service身份运行的服务在访问域中其他共享资源时，都是以计算机账户的身份进行验证的。 传统AD的登录会由用户向域控申请和计算机之间通信的会话票据(默认存活8小时)，用户登录计算机时，向计算机出示会话票据，同时加上时间戳证明没有篡改过，计算机才会授权用户登录。登录以后，会在该计算机上生成登录会话，并查询该用户所属的域组和本地组，以此来创建访问令牌，如果是本地管理员，则会生成2张访问令牌(普通用户令牌和管理员令牌)。 传统AD协议(如Kerbose和LDAP）太沉重，一般只能适合内网C/S架构，无法穿透Internet。如果要穿透Internet，通常要将其转为基于Claim的形式，例如ADFS。ADFS类似于调制解调器，能够把Kerbose协议&quot;转换&quot;为其他Internet验证协议(SAML等)，但这其实并不是真正意义上的&quot;转换&quot;。 ADDS 是什么 What is Active Directory? Active Directory Domain Services (AD DS) 域控服务 运行AD DS的服务器称为域控制器(DCs, domain controllers) 组织通常具有多个DCS，每个组织都有一个用于整个域的目录的副本。对一个域控制器上的目录 - 例如密码更新或删除用户帐户的更改将复制到其他DCS，以便它们保持最新状态。全局目录服务器是一个DC，它存储其域目录中的所有对象的完整副本以及森林中所有其他域的所有对象的部分副本;这使用户和应用程序能够在其林的任何域中查找对象。桌面，笔记本电脑和运行Windows（而不是Windows Server）的其他设备可以是Active Directory环境的一部分，但它们不会运行AD DS。AD DS依赖于多种建立的协议和标准，包括LDAP（轻量级目录访问协议），Kerberos和DNS（域名系统）。 AAD是什么 Azure Active Directory (Azure AD) 是 Microsoft 基于云的身份和访问管理服务，可实现的员工登录和访问 Azure 中的资源： What is Azure Active Directory AAD（Azure Active Directory）概述 Azure 提供通过AAD管理身份验证和授权的服务，AAD是一种基于云的标识服务，管理员和开发人员可以使用Azure AD配置的集中式规则和策略来控制对内部和外部数据及应用程序的访问。 AAD支持常见的Internet验证协议，例如WS-Federation、SAML等轻量级的基于Claim的验证协议。与传统AD类似，AAD同样有访问令牌，不过其中的内容是Claim属性，而且由于需要在Internet上交付，所以需要对其进行数字签名和加密。下面是AAD主要包含的四个服务： 身份验证： 包括验证身份以访问应用程序和资源、自助密码重置、多重身份验证（MFA）等功能。 单一登录（SSO）：用户只需记住一个ID和一个密码即可访问多个应用程序。 应用程序管理：可以使用AAD应用程序代理、SSO、“访问”面板和SaaS应用来管理云应用和本地应用。 设备管理：管理云设备或本地设备访问企业数据的方式 AADDS是什么 Azure Active Directory Domain Services( Azure AD DS) 提供托管域服务 类似ADDS，例如域加入、组策略、轻型目录访问协议 (LDAP) 和 Kerberos/NTLM 身份验证。 无需在云中部署、管理和修补域控制器 (DC) 即可使用这些域服务。 Azure AD DS 托管域使你能够在云中或你不希望目录查找始终返回到本地 AD DS 环境的位置，运行无法使用现代身份验证方法的旧版应用程序。 你可以将这些旧版应用程序从本地环境直接迁移到托管域，而无需在云中管理 AD DS 环境。 Azure AD DS 与现有的 Azure AD 租户集成。 通过此集成，用户可以使用其现有凭据登录到与托管域相连的服务和应用程序。 还可以使用现有组和用户帐户来保护对资源的访问。 这些功能可更顺畅地将本地资源直接迁移到 Azure。 什么是 Azure Active Directory 域服务 AD与AAD的区别与联系 将 Active Directory 与 Azure Active Directory 进行比较 AD和AAD的区别 AAD与传统AD是完全不同的，前者是云服务，只管验证与授权, 而AAD更像是传统AD向云端的一个扩展，用以满足更多的应用场景与验证需求。AAD 通过为组织提供一种适用于在云中和本地所有应用的标识即服务解决方案，将目录服务方案提升到了一个新层次。同时，AAD是基于云的身份和访问管理解决方案，它也可以与本地AD同步，为本地和基于云的系统提供身份验证。AAD相较于AD的扩展功能概述如下： AAD 解决了传统AD无法扩展到外部的局限性问题。传统AD在验证和授权方面更多的是做验证，并且无法扩展到外部（受限于Kerbose和LDAP），只能局限在企业环境。而AAD恰好能够解决这一问题，它支持如OAuth2、SAML、WS-Federation和OpenID等轻量级的基于Claim的验证协议，同时也提供了Rest接口。 AAD 更关注于验证与授权。除去验证，传统AD更关注于资源的发现与管理，如最常用的组策略，而这部分内容在AAD里是不关注的，AAD关注的是验证与授权，而非管理本身。 AAD 通过多重身份验证和无密码技术提高了密码安全性。传统AD中的凭据基于密码、证书或智能卡的身份验证，通过密码策略来管理密码的长度、到期时间和复杂性，以此确保AD中密码的安全性；而AAD对云和本地使用智能密码保护，AAD通过多重身份验证和无密码技术显著的提高了密码安全性，同时也为用户提供了自助重置密码的功能来提升用户体验，降低技术支持成本。 AAD 使用AAD应用程序代理访问本地应用。AD当中大多数本地应用都使用LDAP、NTLM或kerberos协议来控制用户的访问。AAD则可使用在本地运行的AAD应用程序代理来访问这些类型的本地应用。 AAD 完全基于云。AAD 的优势在于它完全基于云所提供的灵活性，这意味着它既可以充当组织的唯一目录，也可以通过 AAD Connect 与本地AD目录服务同步。无论采取哪种方式，它都使本地和基于云的用户能够访问相同的应用程序和资源，同时受益于诸如单点登录 (SSO)、多重身份验证 (MFA)、条件访问等功能。更重要的是，它提供了一个单一位置来管理整个 IT 资产中的身份、安全性和合规性控制。 下表展示了AD与AAD的具体区别： On-Premises Active Directory Azure Active Directory Authentication kerberos A number of protocols such as SAML，WS-Federation and OAuth，OIDC Locator mechanism DNS ✗ Structure Hierarchical(based on X.500) Flat Query LDAP A rest API, called AD Graph API Communication types All kinds of types HTTP(port 80) HTTP(port 443) Devices Corporate assets, mostly PC BYOD Focus on On-perm services Internet-based services, such as O365, Azure and Facebook(Any services federated with Azure AD) Domain joined ✓ ✗ User ✓ ✓ Group ✓ ✓ OU ✓ ✗ GPO ✓ ✗","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Azure","slug":"技术向/Azure","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Azure/"}],"tags":[{"name":"Azure","slug":"Azure","permalink":"https://www.sizaif.com/tags/Azure/"},{"name":"微软","slug":"微软","permalink":"https://www.sizaif.com/tags/%E5%BE%AE%E8%BD%AF/"}],"author":"sizaif"},{"title":"Rust学习4-关键字","slug":"rust学习4-关键字","date":"2022-02-21T14:08:41.000Z","updated":"2022-02-21T15:18:03.704Z","comments":true,"path":"posts/8358a15/","link":"","permalink":"https://www.sizaif.com/posts/8358a15/","excerpt":"","text":"关键字 下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了 “原始标识符” 部分介绍的原始标识符），这包括函数、变量、参数、结构体字段、模块、crate、常量、宏、静态值、属性、类型、trait 或生命周期 的名字。 目前正在使用的关键字 如下关键字目前有对应其描述的功能。 as - 强制类型转换，消除特定包含项的 trait 的歧义，或者对 use 和 extern crate 语句中的项重命名 async - 返回一个 Future 而不是阻塞当前线程 await - 暂停执行直到 Future 的结果就绪 break - 立刻退出循环 const - 定义常量或不变裸指针（constant raw pointer） continue - 继续进入下一次循环迭代 crate - 链接（link）一个外部 crate 或一个代表宏定义的 crate 的宏变量 dyn - 动态分发 trait 对象 else - 作为 if 和 if let 控制流结构的 fallback enum - 定义一个枚举 extern - 链接一个外部 crate 、函数或变量 false - 布尔字面值 false fn - 定义一个函数或 函数指针类型 (function pointer type) for - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期 if - 基于条件表达式的结果分支 impl - 实现自有或 trait 功能 in - for 循环语法的一部分 let - 绑定一个变量 loop - 无条件循环 match - 模式匹配 mod - 定义一个模块 move - 使闭包获取其所捕获项的所有权 mut - 表示引用、裸指针或模式绑定的可变性 pub - 表示结构体字段、impl 块或模块的公有可见性 ref - 通过引用绑定 return - 从函数中返回 Self - 定义或实现 trait 的类型的类型别名 self - 表示方法本身或当前模块 static - 表示全局变量或在整个程序执行期间保持其生命周期 struct - 定义一个结构体 super - 表示当前模块的父模块 trait - 定义一个 trait true - 布尔字面值 true type - 定义一个类型别名或关联类型 union - 定义一个 union 并且是 union 声明中唯一用到的关键字 unsafe - 表示不安全的代码、函数、trait 或实现 use - 引入外部空间的符号 where - 表示一个约束类型的从句 while - 基于一个表达式的结果判断是否进行循环 保留做将来使用的关键字 如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。 abstract become box do final macro override priv try typeof unsized virtual yield 原始标识符 原始标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 r# 前缀。 例如，match 是关键字。如果尝试编译如下使用 match 作为名字的函数： fn match(needle: &amp;str, haystack: &amp;str) -> bool &#123; haystack.contains(needle) &#125; 会得到这个错误： error: expected identifier, found keyword `match` --> src/main.rs:4:4 | 4 | fn match(needle: &amp;str, haystack: &amp;str) -> bool &#123; | ^^^^^ expected identifier, found keyword 该错误表示你不能将关键字 match 用作函数标识符。你可以使用原始标识符将 match 作为函数名称使用： 文件名: src/main.rs fn r#match(needle: &amp;str, haystack: &amp;str) -> bool &#123; haystack.contains(needle) &#125; fn main() &#123; assert!(r#match(\"foo\", \"foobar\")); &#125; 此代码编译没有任何错误。注意 r# 前缀需同时用于函数名定义和 main 函数中的调用。 原始标识符允许使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。 此外，原始标识符允许你使用以不同于你的 crate 使用的 Rust 版本编写的库。比如，try 在 2015 edition 中不是关键字，而在 2018 edition 则是。所以如果用 2015 edition 编写的库中带有 try 函数，在 2018 edition 中调用时就需要使用原始标识符语法，在这里是 r#try。有关版本的更多信息，请参见附录 E.","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Rust","slug":"技术向/Rust","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://www.sizaif.com/tags/rust/"}],"author":"sizaif"},{"title":"Rust学习3-派生-Derive","slug":"rust学习3-派生-derive","date":"2022-02-21T09:31:45.000Z","updated":"2022-02-21T09:37:24.000Z","comments":true,"path":"posts/d76d00f/","link":"","permalink":"https://www.sizaif.com/posts/d76d00f/","excerpt":"","text":"派生 通过 #[derive] 属性，编译器能够提供某些 trait 的基本实现。如果需要更复杂的行为，这些 trait 也可以手动实现。 下面是可以自动派生的 trait： 比较 trait: Eq, PartialEq, Ord, PartialOrd Eq：完全等价关系 PartialEq： 部分等价关系 Ord：全序关系 PartialOrd：比较排序顺序的值 Clone, 用来从 &amp;T 创建副本 T。 Copy，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。 Hash，从 &amp;T 计算哈希值（hash）。 Default, 创建数据类型的一个空实例。 Debug，使用 &#123;:?&#125; formatter 来格式化一个值。 // `Centimeters`，可以比较的元组结构体 #[derive(PartialEq, PartialOrd)] struct Centimeters(f64); // `Inches`，可以打印的元组结构体 #[derive(Debug)] struct Inches(i32); impl Inches &#123; fn to_centimeters(&amp;self) -> Centimeters &#123; let &amp;Inches(inches) = self; Centimeters(inches as f64 * 2.54) &#125; &#125; // `Seconds`，不带附加属性的元组结构体 struct Seconds(i32); fn main() &#123; let _one_second = Seconds(1); // 报错：`Seconds` 不能打印；它没有实现 `Debug` trait //println!(\"One second looks like: &#123;:?&#125;\", _one_second); // 试一试 ^ 取消此行注释 // 报错：`Seconds`不能比较；它没有实现 `PartialEq` trait //let _this_is_true = (_one_second == _one_second); // 试一试 ^ 取消此行注释 let foot = Inches(12); println!(\"One foot equals &#123;:?&#125;\", foot); let meter = Centimeters(100.0); let cmp = if foot.to_centimeters() &lt; meter &#123; \"smaller\" &#125; else &#123; \"bigger\" &#125;; println!(\"One foot is &#123;&#125; than one meter.\", cmp); &#125; 属性 属性是应用于某些模块、crate 或项的元数据（metadata）。这元数据可以用来： 条件编译代码 设置 crate 名称、版本和类型（二进制文件或库） 禁用 lint （警告） 启用编译器的特性（宏、全局导入（glob import）等） 链接到一个非 Rust 语言的库 标记函数作为单元测试 标记函数作为基准测试的某个部分 当属性作用于整个 crate 时，它们的语法为 #![crate_attribute]，当它们用于模块 或项时，语法为 #[item_attribute]（注意少了感叹号 !）。 属性可以接受参数，有不同的语法形式： #[attribute = &quot;value&quot;] #[attribute(key = &quot;value&quot;)] #[attribute(value)] 属性可以多个值，它们可以分开到多行中： #[attribute(value, value2)] #[attribute(value, value2, value3, value4, value5)]","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Rust","slug":"技术向/Rust","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://www.sizaif.com/tags/rust/"}],"author":"sizaif"},{"title":"Rust学习2-宏与元编程","slug":"rust学习2-宏与元编程","date":"2022-02-04T10:56:48.000Z","updated":"2022-02-04T10:58:08.786Z","comments":true,"path":"posts/7af06751/","link":"","permalink":"https://www.sizaif.com/posts/7af06751/","excerpt":"","text":"Rust学习2-宏与元编程 2022-02-04- [TOC] 什么是元编程 元编程是指某类[计算机程序]的编写，这类计算机程序编写或者操纵其他程序(或者自身)作为它们的数据，或者在[运行时]完成部分本应在[编译时]完成的工作。 元编程是用来产生代码的程序，操纵代码的程序，在运行时创建和修改代码而非编程时，这种程序叫做元程序。而编写这种程序就叫做元编程。 元编程是一种编程技术,编写能够生产新代码的代码,根据语言的不同,实现的方式有两种: 在运行时编译和在编译期. 运行时元编程可用于动态语言: 例如python,JavaScript,Lisp. 编译型语言不可能在运行时生成指令,执行程序预编译. Rust提供编译期代码生成功能, Rust宏不会从执行环境中捕获变量 Rust中的宏及其类型 Rust宏时在抽象语法树构造的第二阶段结束时解析的, 进行名称解析的阶段, 名称解析时在作用域中查找在表达式中定义的变量是否存在的阶段. Rust宏能够识别上下文,并根据宏扩展响应的内容, 常见的宏就是println! , 允许我们向println宏传递尽可能多的参数. Rust不支持传递函数的可变参数. println!(\"&#123;&#125;\", 1); // 默认用法,打印Display println!(\"&#123;:o&#125;\", 9); // 八进制 println!(\"&#123;:x&#125;\", 255); // 十六进制 小写 println!(\"&#123;:X&#125;\", 255); // 十六进制 大写 println!(\"&#123;:p&#125;\", &amp;0); // 指针 println!(\"&#123;:b&#125;\", 15); // 二进制 println!(\"&#123;:e&#125;\", 10000f32); // 科学计数(小写) println!(\"&#123;:E&#125;\", 10000f32); // 科学计数(大写) println!(\"&#123;:?&#125;\", \"test\"); // 打印Debug println!(\"&#123;:#?&#125;\", (\"test1\", \"test2\")); // 带换行和缩进的Debug打印 输出非基本类型的类JSON格式的值 println!(\"&#123;a&#125; &#123;b&#125; &#123;b&#125;\", a = \"x\", b = \"y\"); // 命名参数 宏的类型 声明宏（Declarative Macro） 使用macro_rules!宏创建 过程宏（Procedural Macro） 更高级形式,完全控制代码的操作和生成. 声明宏（Declarative Macro）和过程宏（Procedural Macro）。前者指的是用某种语法直接声明出的宏。后者是对应直接生成抽象语法树的过程的宏。直觉上过程宏更隐式，更全能；声明宏更可读，更直接。 编写一个声明宏,实例: use std::io; // 定义一个输入宏 macro_rules! scanline &#123; ($x:expr) => &#123; io::stdin().read_line(&amp;mut $x).unwrap(); &#125;; &#125; fn main() &#123; let mut input = String::new(); scanline!(input); println!(\" read &#123;:?&#125;\",input); &#125; 过程宏(Procedural Macro）: 自定义 #[derive] 宏在结构体和枚举上指定通过 derive 属性添加的代码,在函数上使用#[proc_macro_derive]属性, 类属性（Attribute-like）宏定义可用于任意项的自定义属性, 在函数上使用#[proc_macro_attribute]属性, 类函数宏看起来像函数不过作用于作为参数传递的 token, 在函数上使用#[proc_macro]属性, 标准库中的内置宏 dbg!: 允许使用他们的值输出表达式的值 compile_error!: 在编译期从代码中报告错误. concat! 链接传递给它的任意数量的文字, 并将链接的文字作为&amp;'static str返回 env!: 检查编译期的环境变量, 安全版本的宏为 : option_env! eprint!和eprintln! 与println!类型, 将消息输出到标准异常流中 include_bytes!: 作为一种将文件读取为字节数组的快捷方式, stringify!: 获得类型或标记作为字符串的字面转换 vec!: vector","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Rust","slug":"技术向/Rust","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://www.sizaif.com/tags/rust/"}],"author":"sizaif"},{"title":"Rust学习1-入门","slug":"rust学习1-入门","date":"2022-02-03T09:25:08.000Z","updated":"2022-02-04T08:36:01.244Z","comments":true,"path":"posts/dba35a1e/","link":"","permalink":"https://www.sizaif.com/posts/dba35a1e/","excerpt":"","text":"Rust学习1-入门 安装Rust &amp;VScode集成Rust 目标: windows 环境下使用VScode IDE 进行rust编写和测试运行 VScode集成rust windows 安装Rust It looks like you’re running Windows. To start using Rust, download the installer, then run the program and follow the onscreen instructions. You may need to install the Visual Studio C++ Build tools when prompted to do so. If you are not on Windows see “Other Installation Methods”. 安装 Visual Studio 2019 的构建工具 https://visualstudio.microsoft.com/visual-cpp-build-tools/ 语言包: 选择中文和英文 安装rust https://www.rust-lang.org/tools/install 选择64位 默认安装即可 测试是否安装成功: $ cargo --version cargo 1.58.0 (f01b232bc 2022-01-19) VSCode集成rust 安装Rust and Friends 集成包 集成包中包括: rust-analyzer 使用rust-analyzer 进行编译运行 Rust语言 基元类型 bool,char 整型 最大支持128位 有符号 无符号 i8 u8 i16 u16 i32 u32 i64 u64 i126 u128 isize 尺寸可变的有符号整型 usize 尺寸可变的无符号整型 f32 32位浮点数 f64 64位浮点数 [T,N] 固定大小的数组, T元素类型,N数组大小 [T] 动态大小的连续序列的视图,T任意类型 str 字符串切片,主要做引用, 即&amp;str (T,U,…) 有限序列,T,U为不同类型 fn(i32) -&gt; i32 接受i32类型参数并返回i32类型参数的函数 变量声明和不可变性 使用关键字let声明变量, 变量初始,无法分配其他值,若要修改,则前面添加mut关键字 fn main() &#123; let a = 1; let mut b = 2; a = 3; b = 4; print!(\"&#123;&#125;,&#123;&#125;\",a,b); &#125; 报错. 函数 函数表示: fn (u64,u64) ->u64 闭包 简单闭包, 通过a来调用, ||内存放参数 let a = ||(); 实例: fn main() &#123; let double = |x| x*2; let value = 5; let twice = double(value); let big_c = |b,c| &#123; let z = b+c; z * twice &#125;; let some = big_c(1,2); print!(\"&#123;&#125;\",some); &#125; Running `target\\debug\\helloworld.exe` 30 字符串 &amp;str, String 两种类型, 保证字符串为有效的UTF-8 条件和判断 类似 C++ if-else 但Rust的if-else 不是语句,而是一个表达式,表达式会返回值 花括号最后一行成为表达式的返回值, if-else分支应具有相同的返回类型 match 表达式 类似于c语言switch语句 fn main()&#123; math a &#123; b => println(\"b\"), c => println(\"c\"), other =>&#123; xxxx; &#125; &#125; &#125; 循环 loop,while,for loop 无限循环 break 跳出 rust中的for 循环只适用用可以转换为迭代器的类型 for i in 0..10&#123; println!(\"&#123;&#125;\",i); &#125; // 0..10 0-10 不包括10 // 0..=10 0-10 包括10 结构体 Rust结构体类似C语言结构体 Rust 中的结构体（Struct）与元组（Tuple）都可以将若干个类型不一定相同的数据捆绑在一起形成整体，但结构体的每个成员和其本身都有一个名字，这样访问它成员的时候就不用记住下标了。元组常用于非定义的多值传递，而结构体用于规范常用的数据结构。结构体的每个成员叫做&quot;字段&quot;。 这是一个结构体定义： struct Site &#123; domain: String, name: String, nation: String, found: u32 &#125; 注意：如果你常用 C/C++，请记住在 Rust 里 struct 语句仅用来定义，不能声明实例，结尾不需要 ; 符号，而且每个字段定义之后用 , 分隔。 有一种更简单的定义和使用结构体的方式：元组结构体。 元组结构体是一种形式是元组的结构体。 与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据： struct Color(u8, u8, u8); struct Point(f64, f64); let black = Color(0, 0, 0); let origin = Point(0.0, 0.0); &quot;颜色&quot;和&quot;点坐标&quot;是常用的两种数据类型，但如果实例化时写个大括号再写上两个名字就为了可读性牺牲了便捷性，Rust 不会遗留这个问题。元组结构体对象的使用方式和元组一样，通过 . 和下标来进行访问： fn main() &#123; struct Color(u8, u8, u8); struct Point(f64, f64); let black = Color(0, 0, 0); let origin = Point(0.0, 0.0); println!(\"black = (&#123;&#125;, &#123;&#125;, &#123;&#125;)\", black.0, black.1, black.2); println!(\"origin = (&#123;&#125;, &#123;&#125;)\", origin.0, origin.1); &#125; Rust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象的珍贵思想可以在 Rust 实现。 结构体方法的第一个参数必须是 &amp;self，不需声明类型，因为 self 不是一种风格而是关键字。 struct Rectangle &#123; width: u32, height: u32, &#125; impl Rectangle &#123; fn output(&amp;self) -> u32&#123; println!(\"&#123;&#125;,\",self.width * self.height); self.height + self.width &#125; &#125; fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; Rectangle::output(&amp;rect1); println!(\"rect.1调用&#123;&#125;\",rect1.output()); &#125; --------------------- 输出: 1500, 1500, rect.1调用80 self 调用此方法后,不允许后续使用该类型 &amp;self 类型实例的读取访问权限 &amp;mut self 类型实例的可变访问 module,import,use 模块 每个rust程序都需要root模块, 可执行文件,通常为main.rs, 对于程序库,通常为lib.rs 模块可以在其他模块内部声明,也可以组织为文件和目录 使用mod声明, 使用use引用 模块中定义的元素默认为私有的, 使用pub 公共访问 Rust 中有两种简单的访问权：公共（public）和私有（private）。 默认情况下，如果不加修饰符，模块中的成员访问权将是私有的。 如果想使用公共权限，需要使用 pub 关键字。 对于私有的模块，只有在与其平级的位置或下级的位置才能访问，不能从其外部访问。 use 关键字能够将模块标识符引入当前作用域： 当存在两个相同的名称，且同样需要导入，可以使用 as 关键字为标识符添加别名： mod nation &#123; pub mod government &#123; pub fn govern() &#123;&#125; &#125; pub fn govern() &#123;&#125; &#125; use crate::nation::government::govern; use crate::nation::govern as nation_govern; fn main() &#123; nation_govern(); govern(); &#125; use 关键字可以与 pub 关键字配合使用： mod nation &#123; pub mod government &#123; pub fn govern() &#123;&#125; &#125; pub use government::govern; &#125; fn main() &#123; nation::govern(); &#125; 数组,元组,项目列表 数组具有固定长度, 存储相同类型元素, 数组大小必须是usize确定值,不能是变量 元组可以是不同类型, 元组是异构集合, 项目列表: 类似数组, 但内容和长度可以不用事先指定; 从堆上分配,使用Vec::new 构造或 宏vec![]创建 let mut number_vec: Vec&lt;u8> = Vec::new(); number_vec.push(1); number_vec.push(2); let mut vec_with_macro = vec![1,2,3,4,6]; vec_with_macro.push(3); let _ = vec_with_macro.pop(); println!(\"number_vec :&#123;:?&#125;, vec_with_macro:&#123;:?&#125;\",number_vec,vec_with_macro); ----------- 输出: number_vec :[1, 2], vec_with_macro:[1, 2, 3, 4, 6] HashMap 键/值 对 来自std::collections 模块 使用HashMap::new 创建 let mut fmap = HashMap::new(); fmap.insert(\"a\", 1); fmap.insert(\"b\", 2); fmap.insert(\"c\", 3); fmap.insert(\"d\", 4); for (k,v) in &amp;fmap&#123; println!(\" got &#123;&#125;,&#123;&#125;\",k,v); &#125; //fmap[\"a\"] = 11; 错误语法 fmap.insert(\"a\", 11); *fmap.get_mut(\"a\").unwrap() = 13; println!(\"fmap[\\\"a\\\"] : &#123;&#125;\",fmap[\"a\"]); 修改内容无法直接使用fmap[&quot;a&quot;] = 11; 进行修改 HashMap does not implement IndexMut, while Vec does. 修改方法: 若famp存在其值的话, 直接用insert方法修改 若不确定可以使用: *fmap.get_mut(&quot;a&quot;).unwrap() = 13; 这种方法","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Rust","slug":"技术向/Rust","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://www.sizaif.com/tags/Rust/"}],"author":"sizaif"},{"title":"Azure RBAC","slug":"Azure-RBAC","date":"2021-12-22T07:42:59.000Z","updated":"2022-02-23T09:44:17.000Z","comments":true,"path":"posts/e56d5251/","link":"","permalink":"https://www.sizaif.com/posts/e56d5251/","excerpt":"","text":"Azure RBAC https://docs.microsoft.com/zh-cn/azure/role-based-access-control/overview https://docs.microsoft.com/zh-cn/azure/role-based-access-control/conditions-overview https://docs.microsoft.com/zh-cn/azure/role-based-access-control/rbac-and-directory-admin-roles 什么是 Azure 基于角色的访问控制 (Azure RBAC)？ Azure RBAC 有什么用途？ 下面是 Azure RBAC 的用途的一些示例： 让一个用户管理订阅中的虚拟机，另一个用户管理虚拟网络 让 DBA 组管理订阅中的 SQL 数据库 让某个用户管理资源组中的所有资源，例如虚拟机、网站和子网 允许某个应用程序访问资源组中的所有资源 Azure RBAC 的工作原理 使用 Azure RBAC 控制资源访问权限的方式是分配 Azure 角色。 这是一个需要理解的重要概念 — 它涉及到如何强制实施权限。 角色分配包含三个要素：安全主体、角色订阅和范围。 安全主体 安全主体是一个对象，表示请求访问 Azure 资源的用户、组、服务主体或托管标识。 可以将角色分配给其中任何一个安全主体。 角色定义 角色定义是权限的集合。 它通常直接称为“角色”。 角色定义列出可执行的操作，例如读取、写入和删除。 角色可以是高级别的（例如所有者），也可以是特定的（例如虚拟机读取者）。 Azure 包含多个可用的内置角色。 例如，虚拟机参与者角色允许用户创建和管理虚拟机。 如果内置角色不能满足组织的特定需求，你可以创建自己的 Azure 自定义角色。 范围 范围是访问权限适用于的资源集。 分配角色时，可以通过定义范围来进一步限制允许的操作。 若要将某人分配为网站参与者，但只针对一个资源组执行此分配，则可使用范围。 在 Azure 中，可在四个级别指定范围：管理组、订阅、资源组或资源。 范围采用父子关系结构。 可以在其中任何一个范围级别分配角色。 有关范围的详细信息，请参阅了解范围。 角色分配 角色分配是出于授予访问权限的目的，将角色定义附加到特定范围内的用户、组、服务主体或托管标识的过程。 通过创建角色分配来授予访问权限，通过删除角色分配来撤销访问权限。 下图显示了角色分配的示例。 在此示例中，为“营销”组分配了医药销售资源组的参与者角色。 这意味着，“营销”组中的用户可以在医药销售资源组中创建或管理任何 Azure 资源。 “营销”用户无权访问医药销售资源组外部的资源，除非他们属于另一个角色分配。 可使用 Azure 门户、Azure CLI、Azure PowerShell、Azure SDK 或 REST API 分配角色。 有关详细信息，请参阅分配 Azure 角色的步骤。 组 角色分配对组来说是可传递的，这意味着如果某用户是某个组的成员，而该组属于具有角色分配的另一个组，那么该用户将具有该角色分配中的权限。 多角色分配 如果有多个重叠的角色分配，将会发生什么情况？ Azure RBAC 是一个加法模型，因此有效权限是角色分配的总和。 请考虑以下示例，其中在订阅范围内向用户授予了“参与者”角色，并且授予了对资源组的“读者”角色。 “参与者”权限与“读者”权限的总和实际上是订阅的“参与者”角色。 因此，在这种情况下，“读者”角色分配没有任何影响。 拒绝分配 以前，Azure RBAC 是一种只能执行允许操作的模型，没有拒绝功能，但 Azure RBAC 现在以有限方式支持拒绝分配。 拒绝分配类似于角色分配，可将一组拒绝操作附加到特定范围内的用户、组、服务主体或托管标识，以便拒绝访问。 角色分配定义了一组允许的操作，而拒绝分配定义了一组不允许的操作。 换而言之，即使角色分配授予用户访问权限，拒绝分配也会阻止用户执行指定的操作。 拒绝分配优先于角色分配。 有关详细信息，请参阅了解 Azure 拒绝分配。 Azure RBAC 如何确定用户是否有权访问资源 下面是 Azure RBAC 用于确定你是否可访问资源的概要步骤。 这些步骤适用于与 Azure RBAC 集成的 Azure 资源管理器或数据平面服务。 如果正在尝试对访问问题进行故障排除，这有助于了解问题。 用户（或服务主体）获取 Azure 资源管理器的令牌。 令牌包含用户的组成员身份（包括可传递的组成员身份）。 用户使用附加的令牌对 Azure 资源管理器发出 REST API 调用。 Azure 资源管理器检索适用于对其执行操作的资源的所有角色分配和拒绝分配。 如果拒绝分配适用，则阻止访问。 否则，评估将继续进行。 Azure 资源管理器缩小适用于此用户或其组的角色分配范围，并确定用户针对此资源拥有的角色。 Azure 资源管理器确定 API 调用中的操作是否包含在用户针对此资源拥有的角色中。 如果角色包含的 Actions 具有通配符 (*)，则通过从允许的 Actions 中减去 NotActions 来计算有效权限。 同样，对任何数据操作执行相同的减法运算。 Actions - NotActions = Effective management permissions DataActions - NotDataActions = Effective data permissions 如果用户在请求的范围内没有包含该操作的角色，则不允许访问。 否则，将评估任何条件。 如果角色分配包含条件，则对这些条件进行评估。 否则将允许访问。 如果满足条件，则允许访问。 否则将不允许访问。 下图是评估逻辑的摘要。 经典订阅管理员角色、Azure 角色和 Azure AD 角色 经典订阅管理员角色 Azure 角色 Azure Active Directory (Azure AD) 角色 角色之间的相互关系 若要更好地理解 Azure 中的角色，最好是先了解一些历史信息。 Azure 最初发布时，对资源的访问权限只是通过以下三种管理员角色进行管理：帐户管理员、服务管理员和共同管理员。 后来添加了 Azure 基于角色的访问控制 (Azure RBAC)。 Azure RBAC 是一个较新的授权系统，它针对 Azure 资源提供精细的访问管理。 Azure RBAC 包括许多内置角色，可在不同的范围进行分配，并允许你创建自己的自定义角色。 若要管理 Azure AD 中的资源（例如用户、组和域），可以使用多种 Azure AD 角色。 下图从较高的层面显示了经典订阅管理员角色、Azure 角色与 Azure AD 角色之间的相互关系。 经典订阅管理员角色 帐户管理员、服务管理员和共同管理员是 Azure 中的三种经典订阅管理员角色。 经典订阅管理员对 Azure 订阅拥有完全访问权限。 他们可以使用 Azure 门户、Azure 资源管理器 API 和经典部署模型 API 来管理资源。 用于注册 Azure 的帐户会自动同时设置为帐户管理员和服务管理员。其次，可以添加其他共同管理员。 服务管理员和共同管理员拥有在订阅范围内分配有“所有者”角色（一个 Azure 角色）的用户的等效访问权限。 下表描述了这三种经典订阅管理角色之间的差别。 经典订阅管理员 限制 权限 说明 帐户管理员 每个 Azure 帐户有 1 个 可以访问 Azure 门户并管理计费管理帐户中所有订阅的计费创建新订阅取消订阅更改订阅的计费更改服务管理员除非具有服务管理员或订阅所有者角色，否则无法取消订阅 在概念上是订阅的计费所有者。 服务管理员 每个 Azure 订阅有 1 个 在 Azure 门户中管理服务取消订阅将用户分配到共同管理员角色 默认情况下，新订阅的帐户管理员也是服务管理员。 服务管理员拥有在订阅范围内分配有“所有者”角色的用户的等效访问权限。 服务管理员具有 Azure 门户的完全访问权限。 共同管理员 每个订阅有 200 个 与服务管理员的访问特权相同，但无法更改订阅与 Azure 目录之间的关联。将用户分配到共同管理员角色，但无法更改服务管理员 共同管理员拥有在订阅范围内分配有“所有者”角色的用户的等效访问权限。 在 Azure 门户中，可以使用“经典管理员”选项卡管理共同管理员或查看服务管理员。 在 Azure 门户中，可以在订阅的属性边栏选项卡上，查看或更改服务管理员，或是查看帐户管理员。 有关详细信息，请参阅 Azure 经典订阅管理员。 Azure 帐户和 Azure 订阅 Azure 帐户代表计费关系。 一个 Azure 帐户代表一个用户标识、一个或多个 Azure 订阅和一组关联的 Azure 资源。 创建帐户的人员是该帐户中创建的所有订阅的帐户管理员。 此人也是订阅的默认服务管理员。 Azure 订阅可帮助你组织 Azure 资源的访问权限。 它们还可帮助控制如何根据资源使用量生成报告、计费及付费。 每个订阅可以采用不同的计费和付款设置，因此，根据办公室、部门、项目等因素，可以采用不同的订阅和不同的计划。 每个服务属于一个订阅，执行编程操作时可能需要订阅 ID。 每个订阅都与一个 Azure AD 目录相关联。 若要查找与订阅关联的目录，请在 Azure 门户中打开“订阅”，然后选择一个订阅以查看目录。 帐户和订阅在 Azure 门户中进行管理。 Azure 角色 Azure RBAC 是基于 Azure 资源管理器构建的授权系统，它针对 Azure 资源（例如计算和存储）提供精细的访问权限管理。 Azure RBAC 包括 70 多个内置角色。 有四个基本的 Azure 角色。 前三个角色适用于所有资源类型： Azure 角色 权限 说明 所有者 对所有资源的完全访问权限将访问权限委托给其他人 服务管理员和共同管理员在订阅范围内分配有“所有者”角色 适用于所有资源类型。 参与者 创建和管理所有类型的 Azure 资源在 Azure Active Directory 中创建一个新租户无法将访问权限授予其他人 适用于所有资源类型。 读取者 查看 Azure 资源 适用于所有资源类型。 用户访问管理员 管理用户对 Azure 资源的访问 剩余的内置角色允许管理特定的 Azure 资源。 例如，虚拟机参与者角色允许用户创建和管理虚拟机。 有关所有内置角色的列表，请参阅 Azure 内置角色。 只有 Azure 门户和 Azure 资源管理器 API 支持 Azure RBAC。 分配有 Azure 角色的用户、组和应用程序无法使用 Azure 经典部署模型 API。 在 Azure 门户中，使用 Azure RBAC 的角色分配显示在“访问控制(标识和访问管理)”边栏选项卡上。 在整个门户中都可以找到此边栏选项卡，例如，在管理组、订阅、资源组和各种资源所在的部分。 单击“角色”选项卡时，会看到内置角色和自定义角色的列表。 有关详细信息，请参阅使用 Azure 门户分配 Azure 角色。 Azure AD 角色 Azure AD 角色用于管理目录中的 Azure AD 资源，例如，创建或编辑用户、将管理角色分配给其他人、重置用户密码、管理用户许可证以及管理域。 下表描述了几个更重要的 Azure AD 角色。 Azure AD 角色 权限 说明 全局管理员 管理对 Azure Active Directory 中所有管理功能的访问，以及与 Azure Active Directory 联合的服务将管理员角色分配给其他人重置任何用户和其他所有管理员的密码 注册 Azure Active Directory 租户的人员将成为全局管理员。 用户管理员 创建和管理用户与组的所有方面管理支持票证监视服务运行状况更改用户、支持管理员和其他用户帐户管理员的密码 计费管理员 购买产品管理订阅管理支持票证监视服务运行状况 在 Azure 门户中的“角色和管理员”边栏选项卡上，可以看到 Azure AD 角色的列表。 有关所有 Azure AD 角色的列表，请参阅 Azure Active Directory 中的管理员角色权限。 Azure 角色与 Azure AD 角色之间的差别 从较高层面讲，Azure 角色控制 Azure 资源的管理权限，而 Azure AD 角色控制 Azure Active Directory 资源的管理权限。 下表比较了两者之间的一些差别。 Azure 角色 Azure AD 角色 管理对 Azure 资源的访问 管理对 Azure Active Directory 资源的访问 支持自定义角色 支持自定义角色 可在多个级别（管理组、订阅、资源组、资源）指定范围 范围可以在租户级别（组织范围）、管理单元或单个对象（例如，特定应用程序）上指定 可在 Azure 门户、Azure CLI、Azure PowerShell、Azure 资源管理器模板、REST API 中访问角色信息 可在 Azure 管理门户、Microsoft 365 管理中心、Microsoft Graph、AzureAD PowerShell 中访问角色信息 Azure 角色与 Azure AD 角色是否重叠？ 默认情况下，Azure 角色与 Azure AD 角色不会跨越 Azure 与 Azure AD。 但是，如果全局管理员通过在 Azure 门户中选择“Azure 资源的访问管理”开关，提升了自己的访问权限，则会针对特定租户的所有订阅为全局管理员授予用户访问管理员角色（Azure 角色）。 “用户访问管理员”角色允许用户向其他用户授予对 Azure 资源的访问权限。 此开关可帮助重新获取订阅的访问权限。 有关详细信息，请参阅提升访问权限以管理所有 Azure 订阅和管理组。 有多个 Azure AD 角色（例如全局管理员和用户管理员角色）可跨越 Azure AD 和 Microsoft 365。 例如，如果你是全局管理员角色的成员，则会获得 Azure AD 和 Microsoft 365 中的全局管理员功能，例如，对 Microsoft Exchange 和 Microsoft SharePoint 进行更改。 但是，在默认情况下，全局管理员无权访问 Azure 资源。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Azure","slug":"技术向/Azure","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Azure/"}],"tags":[{"name":"Azure","slug":"Azure","permalink":"https://www.sizaif.com/tags/Azure/"},{"name":"微软","slug":"微软","permalink":"https://www.sizaif.com/tags/%E5%BE%AE%E8%BD%AF/"}],"author":"sizaif"},{"title":"什么是OIDC(OpenID Connect)","slug":"什么是OIDC-OpenID-Connect","date":"2021-12-19T07:31:38.000Z","updated":"2021-12-22T07:50:06.000Z","comments":true,"path":"posts/de08e406/","link":"","permalink":"https://www.sizaif.com/posts/de08e406/","excerpt":"","text":"什么是 OIDC？ OIDC 的全称是 OpenID Connect，是一套基于 OAuth 2.0 的认证 + 授权协议，用于用户身份认证，将用户数据安全地暴露给第三方。 OIDC 与 OAuth 2.0 有何不同？ OAuth 2.0 是用于授权的行业标准协议。OAuth 2.0 致力于简化客户端开发人员的工作，同时为Web 应用程序，桌面应用程序，移动电话和物联网设备提供特定的授权流程。 以上是 OAuth 2.0 的官方定义。我们举一个实际的例子，你在登录京东的时候，会发现在京东的登录框中有使用 QQ 登录、使用 QQ 登录的按钮，这些地方就是 OAuth 2.0 协议的用武之地。京东希望从 QQ 获取你的 QQ 用户数据，从而完成在京东的注册，这就需要数据的主人——你的授权。完成授权之后， QQ 会给京东一个 access_token，京东携带这个凭证，就能以你的名义，以及你授予此网站的权限（例如你授权京东能够访问你的个人信息而不是转账能力），访问你在 QQ 服务器上的数据，从而获取你的信息，在此过程中，你无须告诉京东你的 QQ 账号和密码，你输入账密信息的时候，是在腾讯的服务器完成的认证。 OIDC 与 OAuth 2.0 相比，多了认证的能力。不但能够返回用户的 access_token，让第三方通过 access_token 调用用户授权过的接口（用户授权），还可以返回用户的 id_token，第三方可以将 id_token 用作用户身份标识（用户认证）。 回到刚才的例子，京东获取到 QQ 颁发的 access_token（是一个随机字符串）之后确实能够获取到你的信息，但是如果不借助其他手段，是不具备用户身份认证功能的。而在 OIDC 协议中，获取 access_token 的同时，会返回一个 JWT 格式的 id_token，可直接用作身份标识，供第三方确认用户身份。 JWT Token 是这个样子的： eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk 格式为“点分 base64 编码”，一共三段，第一部分叫作头部（JOSE Header），第二部分叫作荷载（Payload），第三部分叫作签名（Signature）。其中的签名根据头部、荷载和一个密钥计算得出，不可伪造。 base64 解码之后是这样子的： &#123;\"typ\":\"JWT\", \"alg\":\"HS256\"&#125;.&#123;\"iss\":\"joe\", \"exp\":1300819380, \"http://example.com/is_root\":true&#125;.&lt;签名> 总结成一句话：OAuth 2.0 能做的 OIDC 都能做，OAuth 2.0 不具备的认证能力，OIDC 也具备。 OIDC 协议的应用场景 所有使用 OAuth 2.0 的场景都可以升级为 OIDC 协议，OIDC 协议是 OAuth 2.0 的超集。以下是一些 OIDC 协议的应用场景： 社会化登录场景，网站登录框上常见许多按钮「使用 XXX 登录」。 物联网设备的身份认证和授权。 企业内多个应用统一身份，单点登录。 开放平台对外暴露应用数据，做用户认证与授权。 Serverless 中的身份层。 OIDC 协议是 OAuth 2.0 协议的下一代，是身份认证协议升级的不二之选。 OIDC 协议中的四个主体 在介绍 OIDC 授权模式之前，先要明确四个主体：第三方应用、资源服务器、资源所有者、认证授权服务器。我们继续沿用前文京东与 QQ 登录的例子。 P.S. QQ 使用的是变种 OAuth 2.0 协议，并不完全符合 OIDC 规范，在此假设 QQ 使用 OIDC 协议进行对外数据授权。 第三方应用 京东的角色是第三方应用。 资源服务器 QQ 的个人信息存放于资源服务器。 资源所有者 用户是 QQ 账号的所有者。 认证授权服务器 QQ 的授权服务器负责用户的身份认证和授权，管理第三方应用、受保护资源、资源所有者之间的关系。 OIDC 的三种授权模式 Authorization Code Flow 应用最为广泛的是授权码模式，此模式的交互过程如下图**：** 第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录） 用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码） 认证服务器向第三方应用返回授权码 code。（QQ 服务器将用户的浏览器重定向，将授权码发送到京东服务器） 第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互） 认证服务器返回 access_token 和 id_token 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器） 此后，第三方应用可以利用 access_token 到资源服务器获取用户的信息，完成在第三方应用的注册和登录业务，并可以将 id_token 作为用户的身份凭证，存放在前端。第三方应用的前端需要访问受保护的资源（例如用户账单信息、购物车）时需要携带 id_token，后端验证 id_token 合法性，核实用户身份之后，返回相关资源数据。 OIDC 认证时相关 Token 解释 OIDC 认证时会签发两种 Token，一类叫 id_token，还有一类叫 access_token。 id_token 是用户身份的凭证，只起到判定用户身份的作用。 id_token 示例： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZTQ5NjBkZmJkOTE1OGZiODQ0OTAzYTkiLCJiaXJ0aGRhdGUiOiIiLCJmYW1pbHlfbmFtZSI6IiIsImdlbmRlciI6IiIsImdpdmVuX25hbWUiOiIiLCJsb2NhbGUiOiIiLCJtaWRkbGVfbmFtZSI6IiIsIm5hbWUiOiIiLCJuaWNrbmFtZSI6IiIsInBpY3R1cmUiOiJodHRwczovL3VzZXJjb250ZW50cy5hdXRoaW5nLmNuL2F1dGhpbmctYXZhdGFyLnBuZyIsInByZWZlcnJlZF91c2VybmFtZSI6IiIsInByb2ZpbGUiOiIiLCJ1cGRhdGVkX2F0IjoiIiwid2Vic2l0ZSI6IiIsInpvbmVpbmZvIjoiIiwiY29tcGFueSI6IiIsImJyb3dzZXIiOiJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNF82KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODAuMC4zOTg3Ljg3IFNhZmFyaS81MzcuMzYiLCJkZXZpY2UiOiIiLCJsb2dpbnNfY291bnQiOjEsInJlZ2lzdGVyX21ldGhvZCI6ImRlZmF1bHQ6dXNlcm5hbWUtcGFzc3dvcmQiLCJibG9ja2VkIjpmYWxzZSwibGFzdF9pcCI6IjEyMS4yMS41Ni4xNzEiLCJyZWdpc3Rlcl9pbl91c2VycG9vbCI6IjVjOTU5MDU1NzhmY2U1MDAwMTY2Zjg1MyIsImxhc3RfbG9naW4iOiIyMDIwLTAyLTE2VDE1OjMzOjUyLjQ0NFoiLCJzaWduZWRfdXAiOiIyMDIwLTAyLTE2VDE1OjMzOjUxLjY2NVoiLCJlbWFpbCI6InRlc3QxQDEyMy5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsInBob25lX251bWJlciI6IiIsInBob25lX251bWJlcl92ZXJpZmllZCI6ZmFsc2UsImF0X2hhc2giOiJWYW9sSnVqWXltQjUxNlNGOGNaQkpBIiwic2lkIjoiZGYzMGFlNDgtOTkzMS00YjZlLWI0YzgtMWI5NjRkOGZjOWIyIiwiYXVkIjoiNWQwMWUzODk5ODVmODFjNmMxZGQzMWRlIiwiZXhwIjoxNTgxODcwOTc4LCJpYXQiOjE1ODE4NjczODEsImlzcyI6Imh0dHBzOi8vb2F1dGguYXV0aGluZy5jbi9vYXV0aC9vaWRjIn0.pH-bWm-Im0wnOcUEA-OG_iKwy9DTZlAXuik50HPsfGY ​ 解码后： &#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;.&#123; &quot;sub&quot;: &quot;5e3a3b2315a0b8398cdaaa08&quot;, &quot;birthdate&quot;: &quot;&quot;, &quot;family_name&quot;: &quot;&quot;, &quot;gender&quot;: &quot;&quot;, &quot;given_name&quot;: &quot;&quot;, &quot;locale&quot;: &quot;&quot;, &quot;middle_name&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;nickname&quot;: &quot;&quot;, &quot;picture&quot;: &quot;https:&#x2F;&#x2F;usercontents.authing.cn&#x2F;authing-avatar.png&quot;, &quot;preferred_username&quot;: &quot;&quot;, &quot;profile&quot;: &quot;&quot;, &quot;updated_at&quot;: &quot;&quot;, &quot;website&quot;: &quot;&quot;, &quot;zoneinfo&quot;: &quot;&quot;, &quot;company&quot;: &quot;&quot;, &quot;browser&quot;: &quot;&quot;, &quot;device&quot;: &quot;&quot;, &quot;logins_count&quot;: 8, &quot;register_method&quot;: &quot;default:username-password&quot;, &quot;blocked&quot;: false, &quot;last_ip&quot;: &quot;127.0.0.1&quot;, &quot;register_in_userpool&quot;: &quot;5e3a3b2315a0b8398cdaaa04&quot;, &quot;last_login&quot;: &quot;2020-02-16T09:04:09.764Z&quot;, &quot;signed_up&quot;: &quot;2020-02-05T03:48:51.447Z&quot;, &quot;email&quot;: &quot;test@test.com&quot;, &quot;email_verified&quot;: false, &quot;phone_number&quot;: &quot;&quot;, &quot;at_hash&quot;: &quot;6k-IWJwh-Dd3_hLOay0s7A&quot;, &quot;sid&quot;: &quot;d50a8c9d-23db-4156-80ea-1c82d199d0e9&quot;, &quot;aud&quot;: &quot;5e3a3b2315a0b8398cdaaa0e&quot;, &quot;exp&quot;: 1581948533, &quot;iat&quot;: 1581944933, &quot;iss&quot;: &quot;https:&#x2F;&#x2F;core.littleimp.cn&#x2F;oauth&#x2F;oidc&quot;&#125;.签名 access_token 是用户授权给第三方应用的一个令牌，第三方应用可以使用这个令牌访问用户在资源服务器上受保护的资源，一般不用于用户凭证和身份标识。 ​ access_token 示例： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJXaXdndEdHYzVMeGtZRUFRY012RFkiLCJzdWIiOiI1ZTNhM2IyMzE1YTBiODM5OGNkYWFhMDgiLCJpc3MiOiJodHRwczovL2NvcmUubGl0dGxlaW1wLmNuL29hdXRoL29pZGMiLCJpYXQiOjE1ODE5NDQ5MzMsImV4cCI6MTU4MTk0ODUzMywic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBlbWFpbCBwaG9uZSIsImF1ZCI6IjVlM2EzYjIzMTVhMGI4Mzk4Y2RhYWEwZSJ9.MnAAGj6HlYvN3FOAo6PA2cxNxZDZbL3yhxTM3uxnt0M 解码后： &#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;.&#123; &quot;jti&quot;: &quot;WiwgtGGc5LxkYEAQcMvDY&quot;, &quot;sub&quot;: &quot;5e3a3b2315a0b8398cdaaa08&quot;, &quot;iss&quot;: &quot;https://core.littleimp.cn/oauth/oidc&quot;, &quot;iat&quot;: 1581944933, &quot;exp&quot;: 1581948533, &quot;scope&quot;: &quot;openid profile email phone&quot;, &quot;aud&quot;: &quot;5e3a3b2315a0b8398cdaaa0e&quot;&#125;.签名 Implicit Flow 在隐式模式中，认证服务器的授权接口不会返回授权码 code，而是在与用户完成认证后返回 id_token 和 access_token，交互模式如下图所示： 第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录） 用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码） 认证服务器向第三方应用返回 id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面） 隐式模式比授权码模式简单，经常用于将 id_token、access_token 直接返回到前端，方便前端直接存储 id_token 用于证明用户身份。也需要前端自行将 access_token 发回后端，后端用于获取用户的详细信息，这增加了暴露 access_token 的风险。隐式模式不支持返回 refresh_token，即不能从后端刷新 access_token，登录一旦过期需要用户重新登录。 Hybrid Flow 混合模式是以上两种模式的组合，特点是能够在授权接口一次性获取到 code、id_token、access_token，一般 code 会与 id_token、access_token 混合出现，混合模式的交互如下图所示： 第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录） 用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码） 认证服务器向第三方应用返回 code、id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面） 第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互） 认证服务器返回 access_token 和 id_token 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器） 混合模式可以灵活满足 code、id_token、access_token 的各种处理方式，可以在享有隐式模式便利的同时，利用 code 获取 refresh_token，从而可以在后端刷新用户 access_token，不必重复让用户登录。 总结 OIDC 协议是 OAuth 2.0 协议的超集，是可以替代 OAuth 2.0 的下一代身份认证协议，能够解决认证 + 授权两个问题。OIDC 的授权流程与 OAuth 2.0 完全一致，能够保持向下兼容。 授权服务器的意义在于管理第三方应用、受保护资源、资源所有者之间的关系，让互相不信任的应用之间安全地暴露数据——应用之间约定好某种规范，按照这种规范，就能在用户授权的前提下，安全地将数据暴露给第三方，而第三方也无需获知用户的账密信息。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Azure","slug":"技术向/Azure","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Azure/"}],"tags":[{"name":"OIDC","slug":"OIDC","permalink":"https://www.sizaif.com/tags/OIDC/"},{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"https://www.sizaif.com/tags/OAuth2-0/"}],"author":"sizaif"},{"title":"Azure Tenant,subscription的关系","slug":"Azure-tenant-subscription的关系","date":"2021-12-14T12:46:26.000Z","updated":"2021-12-14T14:01:58.000Z","comments":true,"path":"posts/1bfddf42/","link":"","permalink":"https://www.sizaif.com/posts/1bfddf42/","excerpt":"","text":"[toc] Subscriptions, licenses, accounts, and tenants 微软提供了组织、订阅、许可证和用户帐户的层次结构，以便在其云产品中一致使用身份和账单 Organization(tenants租户) 租户与Azure相关，指的是Azure Active Directory的单个实例，或者通常被称为“Azure AD”。Azure AD是Microsoft的云平台的关键部分，因为它提供了一个单一的位置来管理用户、组以及他们所持有的与在Azure AD中发布的应用程序相关的权限。 Azure AD提供的主要Microsoft应用程序包括Office 365、Dynamics 365和Azure。 每个Azure AD租户都是全球唯一的，通常使用以“onmicrosoft.com”结尾的域（即 myazuread.onmicrosoft.com），并且每个租户都有一个 UUID/GUID 形式的“租户 ID”。独立于其他的Azure AD 租户。 一个租户可以关联多个订阅，但是一个订阅只能个一个租户绑定 通俗理解租户： Azure AD是用来身份认证管理的。组织由多个用户组成，如果一个组织里的好多人都需要注册登录使用一个应用程序，那么租户将这个组织里的人和应用程序圈在一起，租户里面有用户的AD 以及 注册这个应用程序，那么这个租户里面的人就可以通过AD登录进去这个应用程序。 多租户技术的好处在于： 1）多个租户里面有相应的应用程序，在多租户构架下享有一样的软件环境，这样软件更新可以统一进行，也可以共享底层资源（多种共享模式）。 2）租户与租户之间进行数据隔离。 一言以蔽之：多租户的关键就是同一套应用程序下实现多用户组织的数据隔离。 Subscriptions 订阅是与 Microsoft 针对使用一个或多个 Microsoft 云平台或服务签订的协议，其费用基于每个用户许可证费用或云资源使用累计。 订阅是一个逻辑容器，可以在其中部署任意数量的资源(虚拟机、Web应用程序、存储帐户等)。它还可以用于对这些资源进行访问控制，不过目前正确的方法是利用基于角色的访问控制(Role Based access control, RBAC)或管理组。 一句话说订阅就是用来关联Azure账户和Azure资源服务的东西。 一个租户可以关联多个订阅。比如，公司可以把订阅命名为财务部、市场部、销售部等等来管理。每个订阅的费用和计费方式和使用都是独立分开的。但是一个订阅只能个一个租户绑定。 账户和订阅的关系可以理解为： 账户是人的身份证，订阅是手机号码，手机号码需要用身份证去注册申请，一个人可以有好几个手机号码，拿一个工作用，一个家人用，两者分别单独计费不同用途，而且一个手机号只能对应一个身份证号。 组织可订阅多个 Micrososft 云服务 Licenses 许可证允许特定用户帐户使用云产品的服务。管理员将许可证分配给订阅中的各个用户帐户 对于图中的示例，Contoso 公司订阅了具有 100 个许可证的 Office 365 E5，允许最多 100 个单个用户帐户使用 Microsoft 365 E5 的功能和服务。 AD Active Directory 所有 Microsoft 云服务的用户帐户均存储在 Active Directory (Azure AD) 租户(tenant)中，其中包含用户帐户和组。Azure AD tenant 可以使用基于 Windows 服务器服务的 Azure AD Connect与现有的Active Directory Domain Services (AD DS)帐户同步。这叫做目录同步。 组织使用同一 Azure AD 租户进行的多个订阅 活动目录是一个系统，用来存储目录数据，管理用户和资源之间的通信 AD有 Azure AD 和本地的 AD域服务（AD DS） ​ AD DS是本地Windows server服务器上的角色。 ​ Azure AD 是多用户公共目录服务，这意味着Azure AD为云服务和应用程序创建租户。 Azure AD是云上的多租户目录和标识管理服务，提供核心目录和身份管理功能，user可以使用单一登录SSO来访问其他云的SaaS应用程序，如Office365。比如，每个Office365，Azure，CRM online租户实际上都是Azure AD的租户。用租户来为Azure AD里面的app管理访问权限。 AAD是多租户服务，意味着能够同时支持多个不同的组织，可存储每个组织中用户的目录信息。 AAD十一目录为单位来区分范围的。每个目录相当于一个房间。这些房间同在一个大楼里面，但是每个房间又是相对独立的一个个体。要想在AAD中添加人或者添加程序时首先需要创建一个目录，目录是最基本的存在，AAD中所有的东西都是保存在目录中。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"}],"tags":[{"name":"Azure","slug":"Azure","permalink":"https://www.sizaif.com/tags/Azure/"},{"name":"Azure AD","slug":"Azure-AD","permalink":"https://www.sizaif.com/tags/Azure-AD/"}],"author":"sizaif"},{"title":"Python 处理Soap-Post方法","slug":"python-处理soap-post方法","date":"2021-11-25T04:08:42.000Z","updated":"2021-11-25T04:24:12.000Z","comments":true,"path":"posts/d61d731c/","link":"","permalink":"https://www.sizaif.com/posts/d61d731c/","excerpt":"","text":"导语 最近项目用到处理soap接口协议，使用post方法发送数据 在这个地方停留许久，故将解决方法记录下来 soap soap 依赖于XML文件 首先要处理XML文件 python中有xmltodict,dicttoxml两个库可以使用 使用方法 两种解决方法： 一种是 requests方法 另一种是使用suds库 两种方法可参考： Call a SOAP Service with plain old requests Calling a SOAP WebService with Python Suds # Call a SOAP Service with plain old requests import requests url=\"http://wsf.cdyne.com/WeatherWS/Weather.asmx?WSDL\" #headers = &#123;'content-type': 'application/soap+xml'&#125; headers = &#123;'content-type': 'text/xml'&#125; body = \"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;SOAP-ENV:Envelope xmlns:ns0=\"http://ws.cdyne.com/WeatherWS/\" xmlns:ns1=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"> &lt;SOAP-ENV:Header/> &lt;ns1:Body>&lt;ns0:GetWeatherInformation/>&lt;/ns1:Body> &lt;/SOAP-ENV:Envelope>\"\"\" response = requests.post(url,data=body,headers=headers) print response.content ---------------------华丽的分割线1---------------------- # Calling a SOAP WebService with Python Suds from suds.client import Client url=\"http://wsf.cdyne.com/WeatherWS/Weather.asmx?WSDL\" client = Client(url) print client ## shows the details of this service result = client.service.GetWeatherInformation() print result ## see: restult.txt below 这里采用的是requests方法 遇到问题 构造header``body,uri 后 无论是使用python代码还是使用postman工具 获得返回的结果都是二进制流，解析后乱码 如下图： 尝试各种设置编码为'utf-8' 仍输出乱码， 初步判断： 对返回的结果解析编码的问题 构造的body为： body = \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n&lt;soap:Envelope xmlns:exm=\\\"http://schemas.microsoft.com/exchange/services/2006/messages\\\" xmlns:ext=\\\"http://schemas.microsoft.com/exchange/services/2006/types\\\" xmlns:a=\\\"http://www.w3.org/2005/08/addressing\\\" xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\">\\n&lt;soap:Header>\\n&lt;a:Action soap:mustUnderstand=\\\"1\\\">http://schemas.microsoft.com/exchange/2010/Autodiscover/Autodiscover/GetFederationInformation&lt;/a:Action>\\n&lt;a:To soap:mustUnderstand=\\\"1\\\">https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc&lt;/a:To>\\n&lt;a:ReplyTo>\\n&lt;a:Address>http://www.w3.org/2005/08/addressing/anonymous&lt;/a:Address>\\n&lt;/a:ReplyTo>\\n&lt;/soap:Header>\\n&lt;soap:Body>\\n&lt;GetFederationInformationRequestMessage xmlns=\\\"http://schemas.microsoft.com/exchange/2010/Autodiscover\\\">\\n&lt;Request>\\n&lt;Domain>\" + domain + \"&lt;/Domain>\\n&lt;/Request>\\n&lt;/GetFederationInformationRequestMessage>\\n&lt;/soap:Body>\\n&lt;/soap:Envelope>\" 构造的header为 headers = &#123; 'content-type': 'text/xml', 'SOAPAction': 'http://schemas.microsoft.com/exchange/2010/Autodiscover/Autodiscover/GetFederationInformation', 'User-Agent': 'AutodiscoverClient', &#125; 解决方法： 判断为返回结果解码造成的 尝试在header中添加'Accept-Encoding':'utf-8' 如下: headers = &#123; 'content-type': 'text/xml', 'SOAPAction': 'http://schemas.microsoft.com/exchange/2010/Autodiscover/Autodiscover/GetFederationInformation', 'User-Agent': 'AutodiscoverClient', 'Accept-Encoding':'utf-8', &#125; 结果： 乱码问题成功解决：","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"python","slug":"技术向/python","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.sizaif.com/tags/python/"},{"name":"soap","slug":"soap","permalink":"https://www.sizaif.com/tags/soap/"}],"author":"sizaif"},{"title":"python解析DNS记录","slug":"python解析DNS记录","date":"2021-11-24T16:11:48.000Z","updated":"2021-11-25T04:07:51.000Z","comments":true,"path":"posts/c3784c4e/","link":"","permalink":"https://www.sizaif.com/posts/c3784c4e/","excerpt":"","text":"导语 最近项目用到 python 解析DNS记录，故将过程记录下来 常用解析记录 1.主机[A]记录 描述: 主机地址记录。在 DNS 域名与 IP 地址之间建立映射关系语法: owner class ttl A IP_v4_address 例子: host1.example.microsoft.com. IN A 127.0.0.1 2.别名[CNAME] 描述: 用来表示用在该区域中的其它资源记录类型中已指定名称的替补或别名 DNS 域名。语法: owner ttl class AFSDB subtype server_host_name 例子: aliasname.example.microsoft.com. AFSDB 1 truename.example.microsoft.com. 3.主机信息[HINFO] 描述: 用来说明映射到特定 DNS 主机名的 CPU 类型和操作系统类型的 RFC-1700 保留字符串类型，这个信息可以被应用程序通信协议使用。语法: owner ttl class HINFO cpu_type os_type 例子: my-computer-name.example.microsoft.com. HINFO INTEL-386 WIN32 4.邮箱[MB] 描述: 用来将指定的域邮箱名映射到这个邮箱的主机的当前区域中的主机地址记录语法: owner ttl class MB mailbox_hostname 例子: mailbox.example.microsoft.com. MB mailhost1.example.microsoft.com 5.邮箱或通信信息 MINFO 描述: 用来指定负责维护该记录中特定通信名单或邮箱的联系域邮箱名称。同时，还被用来指定接收与该记录中特定通信名单或邮箱有关的错误信息的邮箱语法: owner ttl class MINFO responsible_mailbox error_mailbox 例子: administrator.example.microsoft.com. MINFO resp-mbox.example.microsoft.com err-mbox.example.microsoft.com 6.邮件交换器 [MX] 描述: 用来向特定邮件交换器提供消息路由，该主机作为指定 DNS 域名的邮件交换器。MX 记录需要一个16-位整数来表示消息路由中的主机优先级，多个邮件交换在消息一中被指定。对于这个记录类型中的每个邮件交换主机，需要一个相应的主机地址类型记录。语法: owner ttl class MX preference mail_exchanger_host 例子: example.microsoft.com. MX 10 mailserver1.example.microsoft.com 7.指针记录 [PTR] 描述:用来指向域名空间中的某个位置。PTR记录通常在特殊域中来执行地址到名称镜像的反向搜索。每个记录提供要指向域名称空间的某个其它位置的简单数据。 Syntax: owner ttl class PTR targeted_domain_name 例子: 1.0.0.10.in-addr.arpa. PTR host.example.microsoft.com. 8.服务记录 [SRV] 描述: SRV 资源记录允许管理员使用单一 DNS 域的多个服务器，容易的用管理功能将 TCP/IP 服务从一个主机移到另一个主机，并且将服务提供的程序主机分派为服务的主服务器，将其它的分派为辅助的语法: service.protocol.name ttl class SRV preference weight port target 例子: ldap.tcp.ms-dcs SRV 0 0 389 dc1.example.microsoft.com SRV 10 0 389 dc2.example.microsoft.com 9.已知服务记录 [WKS] 描述: 用来描述一个特定 IP 地址上特定通讯协议支持的 TCP/IP 服务，它提供 TCP 和 UDP 可使用性信息。如果服务器同时支持 TCP 和 UDP 的已知服务，或者有多个支持服务的 IP 地址，多个 WKS 记录会被使用语法: owner ttl class WKS address protocol service_list 例子: example.microsoft.com. WKS 10.0.0.1 TCP ( telnet smtp ftp ) 在&quot;起始颁发机构&quot; SOA 中，记录了这个 Zone 中 DNS 服务器是那一台主机，也记录着负责本 zone 的管理员的邮件地址，如果以后在安装邮件服务器需要修改该信息时，注意将邮件地址中的 “@” 符改为句点 “.” ，因为 “@” 是保留字，代表 zone；另外，要使用域完整名称 FQDN，不要漏掉最后的句点。可以通过 &quot;zone→属性→起始颁发机构&quot;对管理员邮件地址进行修改。 dnspython库 如果查询不到对应的结果报dns.resolver.NoAnswer错误： dns.resolver.NoAnswer: The DNS response does not contain an answer to the question: baidu.com. IN XXX 可以使用如下： try: re = dns.resolver.query(qname,rdtype) except dns.resolver.NoAnswer: XXXX 解析 A记录 ''' 如果不知道返回的Re 结果怎么取值， 可以通过 print(re.__dict__) 查看返回结果的内置对象 或者print(dir(re)) ''' import dns if __name__ == '__main__': re = dns.resolver.query(\"www.bai.com\",\"A\") print(re.__dict__) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线1\")) for i in re.rrset: print(i) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线2\")) for i in re.response.answer: for j in i.items: print(j.to_text()) ''' output: &#123;'qname': &lt;DNS name baidu.com.>, 'rdtype': 1, 'rdclass': 1, 'response': &lt;DNS message, ID 22745>, 'canonical_name': &lt;DNS name baidu.com.>, 'rrset': &lt;DNS baidu.com. IN A RRset>, 'expiration': 1637812232.3766685&#125; ---------------------华丽的分割线1---------------------- 220.181.38.148 220.181.38.251 ---------------------华丽的分割线2---------------------- 220.181.38.148 220.181.38.251 ''' 解析 CNAME记录 import dns if __name__ == '__main__': re = dns.resolver.query(\"www.baidu.com\",'CNAME') print(re.__dict__) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线1\")) for i in re.rrset: print(i.to_text().replace('\\\"','')) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线2\")) for i in re.response.answer: for j in i.items: print(j.to_text()) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线3\")) for i in re: print(i.to_text()) ''' output: &#123;'qname': &lt;DNS name www.baidu.com.>, 'rdtype': 5, 'rdclass': 1, 'response': &lt;DNS message, ID 21322>, 'canonical_name': &lt;DNS name www.baidu.com.>, 'rrset': &lt;DNS www.baidu.com. IN CNAME RRset>, 'expiration': 1637813064.512025&#125; ---------------------华丽的分割线1---------------------- www.a.shifen.com. ---------------------华丽的分割线2---------------------- www.a.shifen.com. ---------------------华丽的分割线3---------------------- www.a.shifen.com. ''' 解析 MX记录 import dns if __name__ == '__main__': re = dns.resolver.query(\"baidu.com\",\"MX\") print(re.__dict__) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线1\")) for i in re.rrset: print(i) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线2\")) for i in re.response.answer: for j in i.items: print(j.to_text()) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线3\")) for i in re: print('MX preference =', i.preference, 'mail exchanger =', i.exchange) ''' output: &#123;'qname': &lt;DNS name baidu.com.>, 'rdtype': 15, 'rdclass': 1, 'response': &lt;DNS message, ID 47237>, 'canonical_name': &lt;DNS name baidu.com.>, 'rrset': &lt;DNS baidu.com. IN MX RRset>, 'expiration': 1637817511.307147&#125; ---------------------华丽的分割线1---------------------- 20 mx1.baidu.com. 15 mx.n.shifen.com. 20 mx50.baidu.com. 20 usmx01.baidu.com. 20 jpmx.baidu.com. 10 mx.maillb.baidu.com. ---------------------华丽的分割线2---------------------- 20 mx1.baidu.com. 15 mx.n.shifen.com. 20 mx50.baidu.com. 20 usmx01.baidu.com. 20 jpmx.baidu.com. 10 mx.maillb.baidu.com. ---------------------华丽的分割线3---------------------- MX preference = 20 mail exchanger = mx1.baidu.com. MX preference = 15 mail exchanger = mx.n.shifen.com. MX preference = 20 mail exchanger = mx50.baidu.com. MX preference = 20 mail exchanger = usmx01.baidu.com. MX preference = 20 mail exchanger = jpmx.baidu.com. MX preference = 10 mail exchanger = mx.maillb.baidu.com. ''' 解析 NS记录 import dns if __name__ == '__main__': re = dns.resolver.query(\"baidu.com\",\"NS\") print(re.__dict__) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线1\")) for i in re.rrset: print(i) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线2\")) for i in re.response.answer: for j in i.items: print(j.to_text()) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线3\")) for i in re: print(i.to_text()) ''' output: &#123;'qname': &lt;DNS name baidu.com.>, 'rdtype': 2, 'rdclass': 1, 'response': &lt;DNS message, ID 64405>, 'canonical_name': &lt;DNS name baidu.com.>, 'rrset': &lt;DNS baidu.com. IN NS RRset>, 'expiration': 1637815874.9459918&#125; ---------------------华丽的分割线1---------------------- dns.baidu.com. ns4.baidu.com. ns3.baidu.com. ns7.baidu.com. ns2.baidu.com. ---------------------华丽的分割线2---------------------- dns.baidu.com. ns4.baidu.com. ns3.baidu.com. ns7.baidu.com. ns2.baidu.com. ---------------------华丽的分割线3---------------------- dns.baidu.com. ns4.baidu.com. ns3.baidu.com. ns7.baidu.com. ns2.baidu.com. Process finished with exit code 0 ''' 解析 DMARC 记录 import dns if __name__ == '__main__': re = dns.resolver.query(\"_dmarc.\"+\"google.com\",\"TXT\") print(re.__dict__) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线1\")) for i in re.rrset: print(i.to_text().replace('\\\"','')) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线2\")) for i in re.response.answer: for j in i.items: print(j.to_text()) print(\"&#123;:-^50s&#125;\".format(\"华丽的分割线3\")) for i in re: print(i.to_text()) ''' output: ---------------------华丽的分割线1---------------------- v=DMARC1; p=reject; rua=mailto:mailauth-reports@google.com ---------------------华丽的分割线2---------------------- \"v=DMARC1; p=reject; rua=mailto:mailauth-reports@google.com\" ---------------------华丽的分割线3---------------------- \"v=DMARC1; p=reject; rua=mailto:mailauth-reports@google.com\" '''","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"python","slug":"技术向/python","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.sizaif.com/tags/python/"},{"name":"DNS","slug":"DNS","permalink":"https://www.sizaif.com/tags/DNS/"}],"author":"sizaif"},{"title":"5G空口协议栈","slug":"5G空口协议栈","date":"2021-11-14T07:23:13.000Z","updated":"2021-11-17T08:22:59.000Z","comments":true,"path":"posts/f5bfc31f/","link":"","permalink":"https://www.sizaif.com/posts/f5bfc31f/","excerpt":"","text":"5G 空口协议栈 create date: 2021-10-28 09:03:43 [TOC] 一、空口协议栈概述 （一）、控制面 ● 层三 NAS：会话管理、用户管理、安全管理、计费。 RRC：系统消息、准入控制、安全管理、测量与上报、切换和移动性、NAS消息传输、无线资源管理。 ● 层二 对不同的层三数据进行区分标识，并提供不同的服务 PDCP（分组数据汇聚协议层）：传输用户面和控制面数据、维护PDCP的SN号、路由和重复（双连接场景）、加密/解密和完整性保护、重排序、支持乱序递交、 重复丢弃、ROHC（用户面）。 RLC（无线链路控制层）：检错、纠错ARQ（AM实体）；分段重组（UM实体和AM实体）；重分段（AM实体）；重复包检测（AM实体）。 MAC（媒体接入层）：逻辑信道和传输信道之间的映射、复用/解复用、调度、HARQ、逻辑信道优先级设置。 ● 层一 物理层为高层的数据提供无线资源及物理层的处理 PHY（物理层） 场景编码：控制信道Polar码，业务信道LDPC码； 调制：QPSK、16QAM、64QAM、256QAM； massiveMIMO：详见第1部分-massiveMIMO概述 （二）、用户面 ● 层二增加SDAP层(Service Data Adaptation Protocol,服务数据适配协议) 在SA组网下，4G网络中的无线承载的概念依然被沿用，但5G核心网为了使业务实现更加的精细化，5G的基本业务的传输单位从4G时代承载的概念细化到以QoS Flow。SDAP协议栈功能就是完成无线侧的承载（DRB）与5GC中的QoSFlow进行映射 二、RRC层功能介绍 RRC（Radio Resource Control，无线资源控制）层，是整个无线通信协议栈接入层的消息配置中心及控制中心，其重要性不言而喻。RRC层的主要作用是给其下层（PDCP,RLC,MAC,PHY）控制和配置所有无线资源，从而可以使UE与基站之间进行通信。 （一）、功能 RRC层位于PDCP层之上，功能和LTE基本一致 系统消息 准入控制 安全管理 测量与上报 切换和移动性 NAS消息传输 无限资源管理 （二）、RRC状态 ● Connected/IDEL LTE时仅有这两个状态，用户要传数据必须在RRC_C0NNECTED状态，因为该状态下各个节点之间的通道都需要打通；IDEL状态是与基站的资源（DRB承载、S1承载）都要释放，而核心网资源保留。两种状态通过寻呼和RRC释放转换。5G两种状态与LTE一致。 ● Inactive 相对于LTE，NR新增了Inactive状态。在该状态下UE存储AS上下文信息，监听寻呼以及执行小区重选流程。在RRC Inactive状态下，UE和gNB只会维持RRC和PDCP层的链接，gNB和UE会释放C-RNTI上下文；为了标识用户，gNB和UE侧会新建立I-RNTI用于用户的标识。仅释放空口资源，简化了RRC状态转换的流程，节省了用户返回链接态的时延，减少了信令开销，但现网尚未启用。 （三）、定义RNA（RAN-Based Notification Area） RNA可以覆盖一个基站或者多个基站，但一定要在核心网配置的注册区范围内 当UE的RNA定时器超时或者UE移动出了RNA范围时，UE都要发起RANU（RAN-based notification area update）流程 关于如何配置RNA有几种不同的选择： -小区列表： –gNB给UE提供一个明确的小区列表作为RNA。 -RAN area列表： –gNB给UE提供一个RAN area ID列表作为RNA，这里提供的RAN area是CN Tracking Area的一个子集或者等于CN Tracking Area，一个RAN area对应一个RAN area ID，一个RAN area由TAI和一个可选的RAN area Code组成。 –一个小区会在其系统消息广播它的RAN area ID。 参考：TS23.501、TS38.413 ● 当UE处于RRC_INACTIVE时，如果最后一个服务gNB收到来自UPF的下行数据或者来自AMF的下行信令，则该gNB在RNA的所有小区寻呼UE，如果RNA的小区属于邻gNB的，则通过Xn口给对应的邻gNB发送XnAP-RAN-Paging消息。如果RAN寻呼失败，则【见于TS23.501 5.3.3.2.5】： 如果NG-RAN有NAS PDU要发给UE，则RAN节点应该发起AN Release流程释放UE的N2口连接，将UE的CM状态迁移到CM_IDLE状态。 如果NG-RAN仅仅只有用户面数据要发送给UE，则NG-RAN节点可以继续保留N2连接或者发起AN Release流程释放N2口连接，如何选择取决于NG-RAN的本地配置。 注：在RAN寻呼失败时触发RAN寻呼的用户面数据包可能会丢失。 ● AMF给NG-RAN提供RRC Inactive Assistance Information，以供NG-RAN用于决定UE是否可以进入RRC_INACTIVE状态；这个RRC Inactive Assistance Information信息包括：配置给UE的注册区、UE特定的DRX、周期注册定时器、MICO指示、UE id index值等。 ● RNA更新流程 ● UE触发的RNA更新过程，包括在Xn接口上的上下文检索。这个过程可能会在UE移动出所配置的RNA时触发，或者周期性地触发。 UE从RRC_INACTIVE状态恢复，提供由最后服务的gNB分配的I-RNTI和适当的原因值，例如RNA更新。 如果gNB能够解析I-RNTI中包含的gNB标识，则请求最后服务的gNB提供UE上下文，提供步骤1中接收到的原因值。 最后服务的gNB可以提供UE上下文(如下所述)。另外,最后服务gNB可能决定把问题转移到RRC_IDLE(且程序遵循步骤3和图9.2.2.5-3之后),或者如果问题仍在前面配置的RNA,使问题过去服务上下文gNB和保持问题RRC_INACTIVE(且程序遵循步骤3和图9.2.2.5-2之后)。 gNB可以将UE转移到RRC_CONNECTED状态，或者使UE重回RRC_IDLE态(这种情况下，gNB发送一条RRCRelease消息)，或者使UE返回RRC_INACTIVE，如下假定。 如果要防止在最后服务gNB中缓冲的下行用户数据的丢失，则接入的gNB给最后服务gNB提供下行数据转发地址 6/7. gNB进行路径切换（向服务AMF发路径切换请求消息，AMF回复路径切换响应消息 ） gNB通过发送带有挂起指示的RRCRelease来使终端处于RRC_INACTIVE状态 通知最后服务的gNB释放UE上下文 ● 当UE仍然在所配置的RNA，并且最后服务的gNB判定不重新定位UE上下文，并保持UE在RRC_INACTIVE的情况下的RNA更新过程 UE从RRC_INACTIVE状态恢复，提供由最后服务的gNB分配的I-RNTI和适当的原因值，例如RNA更新。 如果gNB能够解析I-RNTI中包含的gNB标识，则请求最后服务的gNB提供UE上下文，提供步骤1中接收到的原因值。 最后提供服务的gNB存储接收到的用于下次尝试恢复的消息(例如与要恢复小区相关的C-RNTI和PCI)，并以检索UE上下文失败消息(包括封装的RRCRelease消息)响应gNB。RRCRelease消息包括暂停指示。 gNB将RRCRelease消息转发到UE。 ● 当最后服务的gNB决定移动终端到RRC_IDLE的情况下的RNA更新过程 UE从RRC_INACTIVE状态恢复，提供由最后服务的gNB分配的I-RNTI和适当的原因值，例如RNA域更新。 如果gNB能够解析I-RNTI中包含的gNB标识，则请求最后服务的gNB提供UE上下文，提供步骤1中接收到的原因值。 最后服务的gNB提供一条RRC Release消息，使UE转换到RRC_IDLE状态，而不提供UE上下文。 最后服务的gNB删除UE上下文。 gNB发送RRC Release消息，触发转换到RRC_IDLE状态。 （四）、状态转换 RRC_CONNECTED 和 RRC_INACTIVE可以互相转换 ；RRC_CONNECTED 和 RRC_IDLE可以互相转换 ；RRC_INACTIVE 只能单向释放资源转换到RRC_IDLE 参考：TS38.300、TS38.331 ● RRC_CONNECTED to RRC_INACTIVE 通过定时器超时触发（T380） ● RRC_INACTIVE to RRC_IDLE 通过定时器超时触发（一般是1500s） ● RRC_INACTIVE to RRC_CONNECTED UE发起：UE上下文检索成功状态下：UE触发从RRC_INACTIVE到RRC_CONNECTED的转换 1.UE从RRC_INACTIVE恢复，提供由最后服务gNB分配的I-RNTI 2.如果能够解析I-RNTI中包含的gNB身份，则gNB请求最后服务gNB提供UE上下文数据 3.最后服务gNB提供UE上下文数据 4/5.gNB完成RRC连接的恢复 注意:如果授权允许，用户数据也可以在步骤5中发送 6.如果要防止在最后服务gNB中缓冲的下行用户数据的丢失，则接入的gNB给最后服务gNB提供下行数据转发地址 7/8.gNB执行路径切换（向服务AMF发路径切换请求消息,AMF回复路径切换响应消息 ） 9.通知最后服务gNB释放UE的资源 UE发起：UE上下文检索失败状态下：UE触发从RRC_INACTIVE到RRC_CONNECTED的转换 \\1. UE从RRC_INACTIVE恢复，提供I-RNTI，由最后服务的gNB分配。 \\2. 如果gNB能够解析I-RNTI中包含的gNB标识，就请求最后服务的gNB提供UE上下文数据。 \\3. 最后一个服务的gNB无法检索或验证终端上下文数据。 \\4. 最后一次服务的gNB向gNB返回失败信息。 \\5. gNB执行回退，通过发送RRCSetup来建立新的RRC连接。 \\6. 建立新的RRC Connection。 网络拒绝：终端试图从RRC_INACTIVE恢复连接时，网络拒绝的情况 \\1. UE尝试从RRC_INACTIVE恢复连接。 \\2. gNB无法处理这个流程，例如由于拥塞。 \\3. gNB发送RRCReject(带有等待时间信息)来保持UE处于RRC_INACTIVE状态。 网络发起：网络触发的从RRC_INACTIVE到RRC_CONNECTED的转换 1.发生RAN寻呼触发事件（收到下行用户面数据，来自5GC的下行信令等） 2.触发RAN寻呼，寻呼范围是RNA 3.使用 I-RNTI寻呼UE 4.如果UE被寻呼到，则后续流程同上面的“UE发起：UE触发从RRC_INACTIVE到RRC_CONNECTED的转换” 三、SDAP层 (Service Data Adaptation Protocol,服务数据适配协议层)属于层二，只存在于用户面，位于PDCP层以上，直接承载IP数据包。 负责QoS流与DRB（数据无线承载）之间的映射 为数据包添加QFI（QoS flow ID）标识 （一）、承载 ● 4G基于EPS承载 ● 特点： QoS控制的基本粒度是EPS承载(Bearer)； 需要通过建立多个专用承载为UE提供具有不同QoS保障的业务。 ● 局限： LTE QoS机制更适用于运营商内部应用； 基于承载的QoS管理机制粒度较粗，无法实现业务流粒度的QoS控制； 承载建立信令开销大、较慢，无法跟踪TCP session变化。 ● 5G承载基于QoS架构： 5GC会为每个UE建立一个或多个PDU（协议数据单元）会话（PDU session），PDU会话可能会建立一个或多个QoS流，NG-RAN会为拥有不同需求的QoS流建立不同的DRB，或将属于同一PDU会话的多个QoS流映射到同一个DRB上 ● 5G QoS模型基于QoS流，QoS流是PDU会话内区分QoS差异的最佳粒度，并且由QoS流ID（QFI）唯一标记，每个QoS流都把其相关联的QoS属性进行集合。 ● 一个QoS规则包含：关联的QoS流的QFI、数据包过滤器集（一个过滤器列表）、优先级。一个QoS流可以有多个QoS规则。 ● UE和UPF（用户平面功能）通过Packet Filter Set将业务和QoS流关联，RAN侧将QoS流映射到DRB上，来确保服务的质量 ● 5G QoS 架构只用于SA组网 ● 一个QoS流的QoS配置包含的QoS参数如下： 每条GBR QoS流的QoS配置可能还会包含：指示控制、最大丢包率。 每条GBR QoS流的QoS配置还会包含参数：保证流比特率(GFBR)、最大流比特率(MFBR)、AMBR（Aggregate Maximum Bit Rate，用来钳制Non GBR总带宽）。 每条Non-GBR QoS流的QoS配置可能还会包含参数：反射QoS属性（RQA）。 每条QoS流的QoS配置都会包含的QoS参数：5QI（定义QoS等级：时延、误块、优先级）、ARP。 （二）、SDAP层处理流程 是否添加SDAP头取决于UE上行的QoS流的映射方法，如果采用反射式映射，则gNB必须添加SDAP头，用于标识该数据包的QoS流。若果采用基于配置的映射，则gNB无需添加SDAP包头 四、PDCP层 数据分流的节点；Cloud RAN中CU,DU分离的节点 （一）、功能 ● LTE原有 传输用户面和控制面数据 维护PDCP的SN号 加密/解密和完整性保护（5G：用户面和控制面；4G：仅控制面 ） 重复丢弃 RoHC头压缩（用户面，需基站和UE均支持） ● NR新增 路由和重复（双连接场景时） 重排序（从RLC层移至PDCP层） 支持乱序递交 （二）、参数 ● 在RoHC的框架下，针对不同协议的数据流，有不同的头部压缩算法。5G RFC定义了如下一些Profile用于RoHC压缩 ● RoHC（RObust Header Compression)是一种专为无限连路设计的数据包头压缩机制，以适应无线链路高误码率和长环回时间的链路特性。 可靠性高：由于RoHC提供了反馈机制，因此它在高误码高时延东无线链路中具有更高的可靠性 压缩效率高：最小可将包头压缩成1个字节 ● 安全流程算法 NIA0/NEA0：不进行完整性保护 128-NIA1/NEA1：128-bit SNOW 3G 欧洲 128-NIA2/NEA2：128-bit AES 美国 128-NIA3/NEA3：128-bit ZUC 中国 五、RLC层 位于PDCP层以下 实体分为TM实体、UM实体、AM实体，AM数据收发共用一个实体，UM和TM收发实体分开 不同于LTE，NR RLC层组装RLC层PDU时，不需要底层MAC通知是否有发送机会，可先行封装PDU包，RLC也没有串联功能（下移到MAC层），但RLC PDU要真正发送出去同样需要等待MAC层指示 （一）、实体 TM：透传，不做任何处理 AM：确认，需要ACK/NACK UM：非确认，没有纠错机制，时延低（VoIP业务） （二）、功能 检错、纠错ARQ（AM） 分段重组（UM,AM） 重分段（AM） 重复包检测（AM） 取消了串联功能 ● 六、MAC层 MAC层用于逻辑信道到传输信道的映射 UE和基站侧都有MAC层实体,但存在DC（双连接）时，终端则会存在多个MAC实体 ● 调度 关键功能 ● UE调度请求 PRACH：当手机空口IDEL态 SR-PUCCH：RRC链接还在，只是没有上行资源 ● gNB授权 ● UE状态报告 ● gNB上下行调度PDCCH ● UE解时频资源位置，数据传输，HARQ ● 逻辑信道和传输信道之间的映射（信道的复用和解复用） ● HARQ控制 同步HARQ：一个HARQ进程发生在固定的时刻，接收端预先知道重传的时刻。 异步HARQ：一个HARQ进程可以发生在任何时刻，接收端预先不知道重传的时刻 根据重传的数据特征是否发生变化（重传的MCS与初始的一致为非自适应，不一样则为自适应），可以分为自适应和非自适应。目前NR上下行全部采用异步自适应重传。 （1）上行采用异步自适应的HARQ,基站侧不需要反馈ACK/NACK,所以5G取消了PHICH,节省了信道资源。在下次调度时，通过NDI（新老数据指示，0为重传，1为初传）字段，间接通知UE上行数据解调是否成功。 （2）下行采用异步自适应的HARQ，需要指示UE反馈ACK/NACK的时域位置 ● 逻辑信道优先级控制 七、PHY层 （一）、物理层处理流程 物理层是空口协议栈最复杂的一层，如图所示的是物理层的典型流程，但不同信道的处理过程会有所变化。 TB（Transport Block，传输块）：1个TB包含1个MAC PDU的数据块 CW（Code Word，码字）：首先对每个TB添加CRC，然后进行码块分段生成若干CB（Code Block，码块），对每个码块增加CRC、信道编码、速率匹配之后，得到码字 层：也就是流，码字通过层映射到不同的流上，实现串行到并行的转换。流越多，速率就会越高。 调制：更高阶的调制方式使每符号携带的比特数更大，从而实现更高的传输速率。 天线端口：天线的逻辑端口，每个端口号上有自己独立的DMRS信号。取代了LTE中CRS参考信号，节省了功率的开销，缓解了MOD 3干扰。 编码：eMBB场景，控制信道使用Polar码编码，业务信道使用LDPC码编码 层映射：把码字映射到多个层并行发送的过程 预编码：经过加权，使数据流映射到天线端口 波束：各层数据通过赋型加权后映射到天线上发送，在权值的作用下，波束指向UE。波束的个数与流的个数相同。 （二）、准共址（QCL,Quasi Co-Location) ● 功能：5G数据通过波束的方式发送，每个信道在空口的波束上如何发送写一种没有定义，终端通过两个信号的QCL关系可以从某已知信号的传播特征中推导出未知信号的传播特征，进而提高终端对未知信道的解调能力。 ● QCL类型：由于不同信号的波束发送方式不同，特性可能存在差异，所以有QCL类型之分。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"5G","slug":"5G","permalink":"https://www.sizaif.com/tags/5G/"},{"name":"[object Object]","slug":"object-Object","permalink":"https://www.sizaif.com/tags/object-Object/"}],"author":"sizaif"},{"title":"4G&5G缩写词定义","slug":"4G-5G缩写词定义","date":"2021-11-13T09:07:17.000Z","updated":"2021-11-13T09:54:30.000Z","comments":true,"path":"posts/cdc9cc72/","link":"","permalink":"https://www.sizaif.com/posts/cdc9cc72/","excerpt":"","text":"缩写 全称 解释 4G-GUTI 4G-Globally Unique Temporary Identifier 4G-全球唯一临时标识符 5GCN 5G Core Network 5G核心网络 5G-GUTI 5G-Globally Unique Temporary Identifier 5G-全球唯一临时标识符 5GMM 5GS Mobility Management 5GS移动管理 5G-RG 5G Residential Gateway 5G住宅网关 5G-BRG 5G Broadband Residential Gateway 5G宽带住宅网关 5G-CRG 5G Cable Residential Gateway 5G有线住宅网关 5GS 5G System 5G系统 5GSM 5GS Session Management 5G会话管理 5G-S-TMSI 5G S-Temporary Mobile Subscription Identifier 5G S-临时移动订阅标识符 5G-TMSI 5G Temporary Mobile Subscription Identifier 5G 临时移动订阅标识符 5QI 5G QoS Identifier 5G QoS 标识符 ACS Auto-Configuration Server 自动配置服务器 AKA Authentication and Key Agreement 身份验证和密钥协议 AKMA Authentication and Key Management for Applications 应用程序的 AKMA 身份验证和密钥管理 A-KID AKMA Key Identifier AKMA 密钥标识符 A-TID AKMA Temporary Identifier AKMA 临时标识符 AMBR Aggregate Maximum Bit Rate 聚合最大比特率 AMF Access and Mobility Management Function 访问和移动管理功能 APN Access Point Name 接入点名称 ATSSS Access Traffic Steering, Switching and Splitting 接入流量转向、切换和分流 AUSF Authentication Server Function 认证服务器功能 CAG Closed access group 封闭访问组 CHAP Challenge Handshake Authentication Protocol 质询握手认证协议 DDX Downlink Data Expected 预期 DDX 下行数据 DL Downlink 下行链路 DN Data Network 数据网络 DNN Data Network Name 数据网络名称 DNS Domain Name System 域名系统 eDRX Extended DRX cycle 扩展 DRX 周期 DS-TT Device-Side TSN Translator 设备端 TSN 转换器 EUI Extended Unique Identifier 扩展唯一标识符 E-UTRAN Evolved Universal Terrestrial Radio Access Network 演进的通用陆地无线接入网络 EAC Early Admission Control 早期进入控制 EAP-AKA’ Improved Extensible Authentication Protocol method for 3rd generation Authentication and Key Agreement 用于第三代身份验证和密钥协议的改进的可扩展身份验证协议方法 EAS Edge Application Server 边缘应用服务器 EASDF Edge Application Server Discovery Function 边缘应用服务器发现功能 ECIES Elliptic Curve Integrated Encryption Scheme 椭圆曲线集成加密方案 ECS Edge Configuration Server 边缘配置服务器 EEC Edge Enabler Client Edge Enabler 客户端 EPD Extended Protocol Discriminator EPD 扩展协议鉴别器 EMM EPS Mobility Management EPS 移动性管理 EPC Evolved Packet Core Network 演进分组核心网 EPS Evolved Packet System 演进分组系统 ESM EPS Session Management EPS 会话管理 FN-RG Fixed Network RG 固网RG FN-BRG Fixed Network Broadband RG 固网宽带RG FN-CRG Fixed Network Cable RG 固网电缆 RG Gbps Gigabits per second 千兆位每秒 GFBR Guaranteed Flow Bit Rate 保证浏览比特率 GUAMI Globally Unique AMF Identifier 全球唯一 AMF 标识符 IAB Integrated access and backhaul 集成接入和回传 IMEI International Mobile station Equipment Identity 国际移动台设备标识 IMEISV International Mobile station Equipment Identity and Software Version number IMEISV 国际移动台设备标识和软件版本号 IMSI International Mobile Subscriber Identity 国际移动用户身份 IP-CAN IP-Connectivity Access Network IP-连通性接入网络 KSI Key Set Identifier 密钥集标识符 LADN Local Area Data Network 局域网数据网络 LCS LoCation Services 位置服务 LMF Location Management Function 位置管理功能 LPP LTE Positioning Protocol LTE 定位协议 MAC Message Authentication Code 消息认证码 MA PDU Multi-Access PDU 多路访问 PDU Mbps Megabits per second 兆比特每秒 MFBR Maximum Flow Bit Rate 最大流比特率 MICO Mobile Initiated Connection Only 仅限 MICO Mobile 发起的连接 MUSIM Multi-USIM 多USIM N3IWF Non-3GPP Inter-Working Function 非 3GPP 互通功能 N5CW Non-5G-Capable over WLAN 不支持 5G 的 WLAN N5GC Non-5G Capable 非 5G 能力 NAI Network Access Identifier 网络访问标识符 NITZ Network Identity and Time Zone 网络身份和时区 NR New Radio 新无线电 ngKSI Key Set Identifier for Next Generation Radio Access Network 下一代无线接入网络的 ngKSI 密钥集标识符 NPN Non-public network 非公网 NSAC Network Slice Admission Control 网络切片准入控制 NSACF Network Slice Admission Control FunctionNSSAA Network slice-specific authentication and authorization 网络切片准入控制功能NSSAA 网络切片专用认证授权 NSSAAF NSSAA Function NSSAA 功能 NSSAI Network Slice Selection Assistance Information 网络切片选择辅助信息 OS Operating System 操作系统 OS Id OS Identity 操作系统 ID 操作系统身份 PAP Password Authentication Protocol 密码认证协议 PCO Protocol Configuration Option 协议配置选项 PEI Permanent Equipment Identifier 永久设备标识符 PNI-NPN Public Network Integrated Non-Public Network 公网综合非公网 ProSe Proximity based Services 就近服务 ProSeP 5G ProSe policy 5G ProSe 政策 PTI Procedure Transaction Identity 程序事务标识 PVS Provisioning Server 供应服务器 QFI QoS Flow Identifier QoS 流标识符 QoS Quality of Service QoS 服务质量 QRI QoS Rule Identifier QoS 规则标识符 RACS Radio Capability Signalling Optimisation 无线电能力信令优化 ®AN (Radio) Access Network 无线电接入网络 RFSP RAT Frequency Selection Priority RAT 频率选择优先级 RG Residential Gateway 住宅网关 RPLMN Registered PLMN 注册 PLMN RQA Reflective QoS Attribute 反射 QoS 属性 RQI Reflective QoS Indication 反射式 QoS 指示 RSNPN Registered SNPN 注册 SNPN S-NSSAI Single NSSAI 单 NSSAI SA Security Association SA安全协会 SDF Service Data Flow 服务数据流 SMF Session Management Function 会话管理功能 SGC Service Gap Control 服务差距控制 SNN Serving Network Name 服务网络名称 SNPN Stand-alone Non-Public Network 独立非公网 SOR Steering of Roaming 漫游转向 SOR-CMCI Steering of Roaming Connected Mode Control Information 漫游连接模式控制信息的 SOR-CMCI 转向 SUCI Subscription Concealed Identifier 订阅隐藏标识符 SUPI Subscription Permanent Identifier 订阅永久标识符 TA Tracking Area 追踪区 TAC Tracking Area Code 追踪区号 TAI Tracking Area Identity 跟踪区域标识 Tbps Terabits per second 每秒 Tbps 太比特 TNGF Trusted Non-3GPP Gateway Function 可信非 3GPP 网关功能 TSC Time Sensitive Communication 时间敏感通信 TWIF Trusted WLAN Interworking Function 可信 WLAN 互通功能 TSN Time-Sensitive Networking 时间敏感网络 UAS Uncrewed Aerial System 无人空中系统 UAV Uncrewed Aerial Vehicle 无人驾驶飞行器 UDM Unified Data Management 统一数据管理 UL Uplink 上行链路 UPDS UE policy delivery service UE 策略交付服务 UPF User Plane Function 用户面功能 UPSC UE Policy Section Code UE 策略部分代码 UPSI UE Policy Section Identifier UE 策略部分标识符 URN Uniform Resource Name 统一资源名称 URSP UE Route Selection Policy UE 路由选择策略 USS UAS Service Supplier UAS 服务供应商 UUAA USS UAV Authorization/Authentication USS 无人机授权/认证 V2X Vehicle-to-Everything 车联网 V2XP V2X policy V2X 策略 W-AGF Wireline Access Gateway Function 有线接入网关功能 WLAN Wireless Local Area Network 无线局域网 WUS Wake-up signal 唤醒信号","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"5G","slug":"5G","permalink":"https://www.sizaif.com/tags/5G/"}],"author":"sizaif"},{"title":"3GPP 5G 常用协议规范下载整理","slug":"3GPP-5G-常用协议规范下载整理","date":"2021-11-13T02:18:57.000Z","updated":"2021-11-14T06:54:40.000Z","comments":true,"path":"posts/be65a0a1/","link":"","permalink":"https://www.sizaif.com/posts/be65a0a1/","excerpt":"","text":"常用协议标准 系统架构 编号 协议 全称 描述 下载地址 1 RAN Architecture NG-RAN Architecture description 系统架构 TS 38.473 2 Overall NR and NG-RAN Overall Description NR and NG-RAN 总体技术要求 TS 38.300 3 5GS NG-RAN Architecture description 系统架构 TS 23.501 4 5GC Procedures for the 5G System (5GS) 系统架构 TS 23.502 无线侧（RAN/NR） 编号 协议 全称 描述 下载地址 1 RRC Radio Resource Control 无线资源控制 TS 38.331 2 SDAP Service Data Adaptation Protocol 服务数据适配协议 TS 37.324 3 PDCP Packet Data Convergence Protocol 分组数据汇聚协议 TS 38.323 4 RLC Radio Link Control 无线链路层控制协议 TS 38.322 5 MAC Media Access Control 媒体接入控制协议 TS 38.321 6 F1Ap F1 Application Protocol F1 应用程序协议 TS 38.401 7 XnAp Xn Application Protocol Xn 应用程序协议 TS 38.423 核心网（CN/5GC） 编号 协议 全程 描述 下载地址 1 NgAp NG Application Protocol NG 应用程序协议 TS 38.413 2 NAS Non-Access-Stratum 非接入层 TS 24.501 3 PCF Policy Control Function 策略控制功能 TS 29.507 3GPP协议下载链接 整体 整体描述：TS38.300 5G接入网架构：TS38.401 频点相关 频率、频点相关F R1：TS38.101-1 频率、频点相关F R2：TS38.101-2 EN-DC相关：TS38.101-3 频率、频点相关基站类型：TS38.104 空口协议L2L3 SDAP层协议：TS37.324 5G-RAN无线接口框架总体描述：TS38.300 定义了UE空闲态和非活动态下载接入层部分的过程（包括PLMN选择、小区选择、重选相关门限）：TS38.304 MAC层协议：TS38.321 RLC协议层：TS38.323 RRC层协议：TS38.331 空口协议层L1 物理层概述：TS38.201 物理层的功能与服务：TS38.202 物理层信道定义：TS38.211（物理层信号的生成、调制，DMRS和额外DMRS，PRACH configuration index，Point A等介绍） 传输信道和控制信道的数据处理：TS38.212（包括复用，信道编码，交织，DCI，DMRS端口号等） 物理层控制过程：TS38.213（同步，上行功控，随机接入，UE上报和接收控制消息的过程，SSB等） 物理层数据过程：TS38.214（功率控制，PDSCH PUSCH数据处理过程，步长275） 物理层测量：TS38.215（UE和网络的测量控制，UE测量能力） Xn口协议 Xn接口综述：TS38.420 Xn口物理层：TS38.421 Xn如何传信令：TS38.422 NG-RAN信令：TS38.423 Xn数据传输规范：TS38.424 Xn用户面协议栈：TS38.425 NR UE能力相关 手机的最低性能要求：TS38.101-4 终端定位相关协议：TS38.305 UE在接入网的能力参数：TS38.306 UE支持的特性要求：TS38.307 NG接口协议 NG接口综述：TS38.410 NG接口相关物理层：TS38.411 NG如何传输信令消息：TS38.412 NG-RAN和AMF控制信令：TS38.413 NG接口用户面数据：TS38.414 用户面协议：TS38.415 F1接口协议 架构综述：TS38.470 物理层：TS38.471 信令如何传：TS38.472 控制面：TS38.473 数据面：TS38.474 数据面协议：TS38.475","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"5G","slug":"5G","permalink":"https://www.sizaif.com/tags/5G/"}],"author":"sizaif"},{"title":"LTE(4G)–USIM基础","slug":"LTE-4G-–USIM基础","date":"2021-11-13T01:42:43.000Z","updated":"2021-11-13T02:43:12.000Z","comments":true,"path":"posts/a71e591c/","link":"","permalink":"https://www.sizaif.com/posts/a71e591c/","excerpt":"","text":"USIM是在身份验证中的作用 当您启动手机时，其中的基带模块会与卡上的 USIM 应用程序进行通信。 当需要向网络进行身份验证并验证网络本身时，基带模块将提供的质询信息从网络发送到 USIM，USIM 执行加密以生成对网络发出的身份验证质询的响应，然后 USIM问题是它自己对网络的挑战。 What’s Inside? 所有GSM用于传统SIM应用程序的GSM内容 一般来说USIM也有能力在GSM网络中作为SIMs运行，毕竟它只是一个不同的软件堆栈。我们在这里不涉及GSM SIM。 ICCID 由于USIM只是在通用集成电路卡上运行的应用程序，因此它得到了ICCID或通用集成电路卡ID。通常这是卡本身上印有的长条形码/数量。 网络一般不关心这个值，但运营商可能会把它用于物流，如发货卡。 PIN &amp; PUK pin和PUKs是解锁卡的密码。如果你的PIN错了太多次，你需要更长的PUK来解锁它。 这些字段可以写入(在验证到卡片时)，但不能直接读取，只有尝试。(你可以尝试一个密码，但你不能看到它的设置)。 正如我们之前提到的，终端会询问卡是否正确，但终端也不知道密码。 IMSI 每个订阅者都有一个IMSI，是一个国际移动用户标识。 IMSIS是分层的，从3位数移动国家/地区代码MCC开始，然后移动网络代码(MNC)(2/3位)以及最终是移动订阅识别号(MSIN)，由操作员分配给用户的唯一号码网络。 这意味着虽然两个订阅者理论上可以具有相同的MSIN，但它们不会分享相同的MNC和MCC，因此ISMI仍然是唯一的。 除非订户更改运营商时，IMSI永远不会发生变化，除非新的操作员发出新的USIM卡，具有不同的IMSI（不同的MNC）。 MSIN与电话号码/MSISDN号码不同，但IMSI通常具有网络相关联的MSISDN。这允许您在不更改USIM / SIM的情况下移植/更改MSISDN号码。 K – Subscriber Key 仅针对订户和认证中心(AUC/HSS)已知的订户的秘密密钥。 所有身份验证都依赖于仅为USIM和AUC/HHS已知的单个密钥(k)的原则。 OP – Operator Code 操作员代码 - 来自单个操作员的所有SIM卡相同。 与K结合使用作为一些身份验证/授权加密生成的输入。 由于操作员代码对网络中的所有订阅者都是通用的，因为要恢复此密钥可能会导致安全问题，因此通常使用OPC。 OPc – Operator Code (Derived) 当USIM用K键写入USIM时，可以预先计算Operator代码，而不是给出每个USIM的操作员代码。 这意味着OP不存储在USIM上。 OPc=Encypt-Algo(OP,Key) PLMN (Public Land Mobile Network) PLMN是MCC和MNC的组合，用于识别运营商的无线接入网(RAN)。 虽然在大多数USIMs中没有特定的PLMN字段，但值得理解的是，有几个字段需要PLMN。 HPLMNwAcT (HPLMN selector with Access Technology) 按优先级顺序包含指定接入技术的Home-PLMN编码 这允许USIM计算出哪个PLMN附加到哪个访问技术(RAN)，例如，如果操作员的PLMN是50599，我们可以 50599 E-UTRAN 50599 UTRAN 尝试4G，如果失败了就使用3G。 在运营商可能合作共享不同地区的网络的情况下，可以先设置运营商的PLMN，然后再设置合作运营商的PLMN。 OPLMNwACT (Operator controlled PLMN selector with Access Technology) 这是运营商与优先顺序和访问技术有关漫游协议的PLMNS列表。 操作员可以漫游到运营商X，但仅允许UTRAN访问，而不是E-TRAN。 FEHPLMN (Equivalent HPLMN) 用于定义等效的HPMN，例如，如果两个载波合并并仍有两个PLMN。 FPLMN (Forbidden PLMN list) 用户不能浏览的plmn列表。 HPPLMN (Higher Priority PLMN search period) 在HPLMNWACT列表中的每个PLMN / Access技术之间花费多长时间。 ACC (Access Control Class) ACC允许0-15的值，并确定订户的访问控制类。 在英国，ACC值用于限制紧急情况期间对手机网络的平民访问。 普通用户在0 - 9.较高的优先级用户分配12-14中的普通订阅者。 在紧急情况下，禁用范围0 - 9中的某些或所有访问类。 这意味着可以将服务截止到具有0-9的ACC值的公众，但第一个响应者和紧急服务等人将具有更高的ACC值，网络将允许它们附加。 AD (Administrative Data) 与ACC字段一样，AD字段允许运营商在没有与网络附加的有效支付订阅者的情况下驱动测试网络 The defined levels are: '00’正常运行。 '80’型批准操作。 '01’正常运行+特定设施。 '81’型批准操作+特定设施。 '02’维护（离线）。 '04’单元测试操作。 GID 1 / 2 – Group Identifier 两个组标识符字段，允许操作符为特定应用程序标识一组USIMs。 SPN (Service Provider Name) SPN是包含网络的人类可读名称的可选字段。 SPN允许MVNOS以手机上的操作员提供自己的USIM。 ECC (Emergency Call Codes) 多达6位数的代码长时间允许从主屏幕/紧急/不经过身份验证等拨号。 MSISDN 移动台国际订户目录号码。E.164格式的用户的电话号码。 这是可选的，因为移植可能会覆盖此操作，因此它并不总是匹配。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"USIM","slug":"USIM","permalink":"https://www.sizaif.com/tags/USIM/"}],"author":"sizaif"},{"title":".Pcap包学习","slug":"Pcap包学习","date":"2021-11-06T02:13:04.000Z","updated":"2021-11-06T02:19:55.000Z","comments":true,"path":"posts/a30ed9b8/","link":"","permalink":"https://www.sizaif.com/posts/a30ed9b8/","excerpt":"","text":".pacp/.cap 文件结构 1.Pcap Header 文件头，每一个pcap文件只有一个文件头，总共占24（B ）字节，以下是总共7个字段的含义。 detail Magic(4B)： 标记文件开始，并用来识别文件和字节顺序。值可以为0xa1b2c3d4或者0xd4c3b2a1，如果是0xa1b2c3d4表示是大端模式，按照原来的顺序一个字节一个字节的读，如果是0xd4c3b2a1表示小端模式，下面的字节都要交换顺序(从后往前)。现在的电脑大部分是小端模式。Major(2B)： 当前文件的主要版本号，一般为0x0200Minor(2B)： 当前文件的次要版本号，一般为0x0400ThisZone(4B)： 当地的标准事件，如果用的是GMT则全零，一般全零SigFigs(4B)： 时间戳的精度，一般为全零SnapLen(4B)： 最大的存储长度，设置所抓获的数据包的最大长度，如果所有数据包都要抓获，将值设置为65535LinkType(4B)： 链路类型。解析数据包首先要判断它的LinkType，所以这个值很重要。一般的值为1，即以太网常用的LinkType（链路类型）：值类型描述0BSD loopback devices, except for later OpenBSD1Ethernet, and Linux loopback devices6802.5 Token Ring7ARCnet8SLIP9PPP10FDDI100LLC/SNAP-encapsulated ATM101“raw IP”, with no link102BSD/OS SLIP103BSD/OS PPP104Cisco HDLC105802.11108later OpenBSD loopback devices (with the AF_value in network byte order)113special Linux “cooked” capture114LocalTalk ​ 2.Packet Header 数据包头可以有多个，每个数据包头后面都跟着真正的数据包。以下是Packet Header的4个字段含义 Timestamp(4B)： 时间戳高位，精确到seconds，这是Unix时间戳。捕获数据包的时间一般是根据这个值 Timestamp(4B)： 时间戳低位，能够精确到microseconds Caplen(4B)： 当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。 Len(4B)： 离线数据长度，网路中实际数据帧的长度，一般不大于Caplen，多数情况下和Caplen值一样 3.Packet Data Packet是链路层的数据帧，长度就是Packet Header中定义的Caplen值，所以每个Packet Header后面都跟着Caplen长度的Packet Data。也就是说pcap文件并没有规定捕获的数据帧之间有什么间隔字符串。Packet数据帧部分的格式就是标准的网络协议格式了。 eg： 下图为16进制pcap文件： 备注： 红色部分：Pcap Header 蓝色部分：Packet Header PcapHeader Magic(4B)： D4 C3 B2 A1 表示小端模式，后面的字节从后往前读； Major(2B)： 02 00，计算机读的是00 02； Minor(2B)： 04 00，计算机读的是00 04； ThisZone(4B)： 00 00 00 00，全零； SigFigs(4B)： 00 00 00 00，全零； SnapLen(4B)： FF FF 00 00, 计算机读的是：00 00 FF FF，所以是2^16-1=65535 LinkType(4B)： 01 00 00 00, 计算机读的是：00 00 00 01，表示是以太网类型 Packet Header Timestamp(4B)： CA 4D A4 5C，计算机读的是：5C A4 4D CA，十进制：1554271690，日期为：2019-04-03 14:08:10； Timestamp(4B)： 4F 2A 08 00，计算机读的是：00 08 2A 4F，十进制：535119，代表535119ms； Caplen(4B)： BA 1C 00 00, 计算机读的是：00 00 1C BA，十进制：7354，代表后面的7354个字节为一个数据帧，之后又是一个新的PacketHeader，如 此循环； Len(4B)： BA 1C 00 00，和Caplen相同","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"Wireshark","slug":"笔记/Wireshark","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/Wireshark/"}],"tags":[{"name":"Pcap","slug":"Pcap","permalink":"https://www.sizaif.com/tags/Pcap/"}],"author":"sizaif"},{"title":"Deep Packet Inspection,DPI","slug":"Deep-Packet-Inspection-DPI","date":"2021-10-31T09:10:18.000Z","updated":"2021-10-31T09:41:54.000Z","comments":true,"path":"posts/ac712918/","link":"","permalink":"https://www.sizaif.com/posts/ac712918/","excerpt":"","text":"什么是DPI? Deep packet inspection,DPI 也被叫做信息提取,IX或完整的数据包检查. 是一种网络数据包过滤. 深度数据包检查是对通过检查点传输的报文的数据部分和报文头进行评估，排除任何不符合协议、垃圾邮件、病毒、入侵和任何其他阻止报文通过检查点的定义标准。 深度数据包检查也用于确定特定数据包是否被重定向到另一个目的地。简而言之，深度数据包检查能够定位、检测、分类、阻塞或重路由具有特定代码或数据负载的包，这些包是传统包过滤无法检测、定位、分类、阻塞或重定向的。与普通数据包过滤不同，深度数据包检查不仅仅是检查包头 DPI 怎样工作? 深度数据包检查是包过滤的一种形式，通常作为防火墙的功能执行。它被应用于开放系统互连的应用层。 深度数据包检查是对通过检查点的包的内容进行评估。使用由你、Internet服务提供商或网络或系统管理员分配的规则，深度包检查确定如何实时处理这些包 深度数据包检查能够检查这些包的内容，然后找出它来自哪里，比如发送它的服务或应用程序。此外，它还可以与过滤器一起工作，以便从在线服务(如Twitter或Facebook)或特定IP地址查找和重定向网络流量 DPI VS 传统包过滤 传统的包过滤只读取每个包的头信息。这是一种基本方法，主要由于当时的技术限制而没有现代数据包过滤方法复杂。防火墙的处理能力非常低，不足以处理大量数据包。换句话说，传统的数据包过滤类似于阅读一本书的书名，而不知道或评估封面内的内容。 随着新技术的出现，深度数据包检测变得可行。随着它变得更加彻底和完整，它变得更像是拿起一本书，打开它，从头到尾阅读。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"}],"tags":[{"name":"DPI","slug":"DPI","permalink":"https://www.sizaif.com/tags/DPI/"}],"author":"sizaif"},{"title":"使用Wireshark抓包LTE RRC","slug":"使用Wireshark抓包LTE-RRC","date":"2021-10-07T08:18:15.000Z","updated":"2021-10-07T08:47:24.000Z","comments":true,"path":"posts/172b8d62/","link":"","permalink":"https://www.sizaif.com/posts/172b8d62/","excerpt":"","text":"[TOC] 使用Wireshark抓包LTE RRC 包 实验环境说明 一台ubuntu20.04虚拟机 Wireshark 基于srsRAN 模拟LTE环境 使用ZeroMQ RF 实现无RF硬件构建srsUE与srsENB 通信 With srsRAN this can be achieved by replacing the radio link between eNodeB and UE with a mechanism that allows to exchange baseband IQ samples over an alternative transport. For this purpose, we’ve implemented a ZeroMQ-based RF driver that essentially acts as a transmit and receive pipe for exchanging IQ samples over TCP or IPC. Wireshark配置 在srsran doc 文档中由提到wireshark 抓取用法 Examining PCAPs with Wireshark 打开DLT_User选项 添加配置 保存后即可开始抓取, 按照原文的意思设置此项后就可以抓取到LTE消息. 但在使用ZeroMQ 实现免RF中并没有出现上述的情况, 因为ZeroMQ的流量都是通过localhost:2000 和 localhost:2001 端口 实现流量交换 既然如此,尝试添加解析选项 分析-&gt; 解码为, 添加对应端口, 以及要解析成的协议,保存即可 srsRAN配置 在~/.config/srsran/ 目录下, 修改epc.conf, enb.conf,ue.conf 文件 在对应的pcap 选项下, 设置 enable = true 当运行完成后,即可以用wireshark 打开 /tmp/目录下对应的pcap文件, 设置对应解析查看","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://www.sizaif.com/tags/Wireshark/"}],"author":"sizaif"},{"title":"提取3GPP TS中RRC ASN.1模式及编译","slug":"提取3GPP-TS中RRC-ASN-1模式及编译","date":"2021-10-05T03:30:26.000Z","updated":"2021-10-06T08:53:55.000Z","comments":true,"path":"posts/b0e1c2b9/","link":"","permalink":"https://www.sizaif.com/posts/b0e1c2b9/","excerpt":"","text":"整体流程图 ASN.1 标准简介 在电信和计算机网络领域，ASN.1（Abstract Syntax Notation One) 是一套标准，是描述数据、编码、传输、解码的灵活的抽象语义记法。它提供了一套正式、无歧义和精确的规则以描述独立于特定计算机硬件的对象结构。 3GPP协议 5G NR 的无线资源控制(RRC)协议是 38.331 38.331https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3197 LTE 的无线资源控制(RRC)协议是 36.331 36.331https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=2440 提取RRC,ASN1样式 转换工具下载 将下载后的3GPP协议Word 文档去掉页眉页脚后转换成纯文本txt, 编码选择UTF-8 使用txt2asn1 转换 txt2asn1https://github.com/Dybinx/txt2asn1 请下载ZIP格式并解压,避免出现exe权限无法运行问题 在同目录下终端运行 得到xxx.asn1文件 ./txt2asn1.exe XXX.txt 使用extract_asn1_from_spec.pl extract_asn1_from_spechttps://gitlab.eurecom.fr/oai/openairinterface5g/-/blob/master/openair2/RRC/LTE/MESSAGES/asn1c/ASN1_files/extract_asn1_from_spec.pl 下载文件后, 源文件同目录终端运行 perl extract_asn1_from_spec xxxx.txt 得到 EUTRA-RRC-Definitions.asn, EUTRA-UE-Variables.asn ,EUTRA-InterNodeDefinitions 三个文件 ASN1C编译ASN.1文件 ASN1C 是将 ASN.1 规范转换为 C 源代码的免费开源编译器。 它支持一系列 ASN.1 语法，包括 ISO/IEC/ITU ASN.1 1988、'94、'97、2002 和以后的修正。 支持的编码规则集是 BER: ITU-T Rec. X.690 | ISO/IEC 8825-1 (2002) (BER/DER/CER) PER: X.691|8825-2 (2002) (PER). XER: X.693|8825-3 (2001) (BASIC-XER/CXER). asn1c官网http://www.lionet.info/asn1c/ asn1c源码https://github.com/vlm/asn1c ubuntu 可直接通过 sudo apt-get install asn1c 进行安装 sudo apt update sudo apt install asn1c 使用asn1c 编译 asn1c -S /usr/share/asn1c -fcompound-names -gen-PER -pdu=auto 36331-f40.asn1 # -pdu=auto 产生pdu_colletion.c文件 # -fcompound-names 去除重定义 # -gen-PER 使用PER编码 # -S /usr/share/asn1c 指定asn1c库文件位置, 通过使用whereis asn1c命令查看其库位置 FAQ Q.: Does asn1c support BER encoding? I see only DER encoding in documentation.A.: Yes, the asn1c compiler fully supports BER encoding. Any DER encoded data is, by definition, a valid BER data, from the receiver’s point of view.If you want data to be BER or DER encoded, just invoke der_encode().Q.: My linker complains: Undefined symbols: _asn_DEF_PDU.A.: If you have your own file with main() routine, just delete the converter-sample.cfile, you won’t need it. If you haven’t created the main() routine yourself and wish to rely on converter-sample.c for your transcoding needs, add -DPDU=YourPdu to the list of compiler flags.Q.: How to compile the 3GPP Radio Resource Control specification?A.: The asn1c distribution includes an RRC 25.331 (version 7.1.0) example, check out https://github.com/vlm/asn1c/tree/master/examples/sample.source.RRC. You can also use the pre-compiled rrc-dump.exe program, which is part of Windows ASN.1 compiler installer.Q.: How to compile the ISO 13522 (MHEG-5) specification?A.: The ASN.1 compiler comes with a MHEG-5 decoder. Follow the https://github.com/vlm/asn1c/tree/master/examples/sample.source.MHEG5 README file instructions. You can also use the pre-compiled mheg5dump.exe program, which is part of Windows ASN.1 compiler installer.Q.: How to compile the XYZ decoder?A.: If XYZ is one of MEGACO (Media Gateway Control), PKIX1/X.509, LDAP, GSM TAP3 or OAM ULP, just go to examples/sample.source.XYZ and run make. The Windows ASN.1 compiler installer already contains the pre-compiled decoders for these encoding formats.If you have something else, you should either use the Online ASN.1 compiler, or download the ASN.1 compiler source code. 如果不使用自己的main()函数, 直接使用converter-sample.c的化, 需要在其中添加一个目标PDU #include &lt;asn_application.h&gt; #include &lt;asn_internal.h&gt; &#x2F;* for ASN__DEFAULT_STACK_MAX *&#x2F; #define PDU BCCH_BCH_Message &#x2F;* Convert &quot;Type&quot; defined by -DPDU into &quot;asn_DEF_Type&quot; *&#x2F; #define ASN_DEF_PDU(t) asn_DEF_ ## t #define DEF_PDU_Type(t) ASN_DEF_PDU(t) #define PDU_Type DEF_PDU_Type(PDU) 或者在Makefile.am.sample 文件中, 修改 CFLAGS 添加 -DPDU= 选项 CFLAGS += -DHAVE_CONFIG_H -DJUNKTEST -D_DEFAULT_SOURCE -DPDU=BCCH_BCH_Message -DASN_PDU_COLLECTION -I. OBJS=$&#123;ASN_MODULE_SRCS:.c=.o&#125; $&#123;ASN_CONVERTER_SOURCES:.c=.o&#125; all: $(TARGET) $(TARGET): $&#123;OBJS&#125; $(CC) $(CFLAGS) -o $(TARGET) $&#123;OBJS&#125; $(LDFLAGS) $(LIBS)","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"ASN.1","slug":"ASN-1","permalink":"https://www.sizaif.com/tags/ASN-1/"}],"author":"sizaif"},{"title":"LTE 基础知识","slug":"LTE-基础知识","date":"2021-10-04T03:06:13.000Z","updated":"2021-10-05T04:01:19.000Z","comments":true,"path":"posts/cdac3e0/","link":"","permalink":"https://www.sizaif.com/posts/cdac3e0/","excerpt":"","text":"LTE相关基础知识 LTE架构 第一层物理层(PHY),在时间和频率域使用无线电资源进行通信。 第二层由介质访问控制(MAC)、无线链路控制(RLC)、分组数据收敛协议(PDCP)三层组成。它们支持上行和下行调度、分组分割、加密和完整性保护等功能。 RRC是一个第三层协议，负责创建和维护无线电连接、广播系统信息、发送分页通知、配置和报告无线电测量以及隧道化NAS消息。 NAS是终端与CN之间的控制平面协议;它负责设置安全性，处理移动性和会话管理。 UE代表手机; RAN为终端提供无线通信服务; CN(EPC)(包括其他功能)在终端和Internet之间路由数据。 RAN由无线基站组成，在5G中称为gNB，在4G中称为eNB。gNB所使用的无线电接入技术被称为新无线电(NR)， eNB所使用的无线电接入技术被称为进化通用地面无线电接入(E-UTRA)。 CN由几个网络功能组成，其中5G的接入和移动性管理功能(AMF)和4G的移动性管理实体(MME)如图所示。UE到RAN/CN的方向称为上行，另一个方向称为下行。 4G和5G的流量有两种类型: 一种称为控制平面的类型负责建立和维护连接，并建立安全性; 用户平面: 承载实际数据，如语音通话和互联网数据。每种类型都由几个协议组成。 控制平面上使用的协议栈的空中接口,包括无线电资源控制协议(RRC)和不可访问层协议(NAS)， RRC(Radio Resource Control) 无线资源控制 RRC是一个第三层协议，负责创建和维护无线电连接、广播系统信息、发送分页通知、配置和报告无线电测量以及隧道化NAS消息。 在NG-RAN中，RRC在UE和gNB之间的控制平面消息中进行操作。它携带了与RAN控制平面程序相关的信息 RRC层还为终端和核心网接入移动性管理功能(Access and Mobility Management Function, AMF)之间发送的NAS消息提供服务。 RRC中的消息依赖于PDCP,在必要时提供一个具有加密和完整性保护的通道。 RRC负责广播系统信息或获取系统信息以便在小区内进行通信，用于在RRC_IDLE状态下发送寻呼消息、连接管理、移动性管理等。 RRC三种状态转换 5G NR中 引入了额外的状态RRC_INACTIVE RRC_IDLE: 网络不包含终端RRC连接信息的状态。因此，设备不能发送或接收数据。设备定期醒来，接收来自网络的寻呼消息，将状态更改为RRC_CONNECTED。小区和网络之间的移动性可以通过小区重新选择过程实现 RRC_INACTIVE: 无法发送或接收数据。 在UE和gNB中都维护RRC上下文。UE可以类似于RRC_IDLE模式休眠，以节省电池电量。减少到RRC_CONNECTED模式的转换时间,用于数据传输，因为已经在核心网络建立了上下文。 通过小区重选程序的移动性 RRC_CONNECTED: 在UE和gNB之间建立RRC上下文，用于在网络上传输数据。通过小区无线网络临时标识符(C-RNTI)用于信令的网络识别设备。由RAN管理的移动性，在需要时进行切换 新的状态RRC_INACTIVE有助于减少发送用户数据之前的状态转换所涉及的信令量。 RRC_INACTIVE充当了一个中介状态，用于在RRC上下文已经建立时直接转换。在RRC_INACTIVE状态下，设备会像RRC_IDLE一样休眠。 RRC层负责控制平面过程中的大量消息，对于任何RRC层的实现来说，健壮地抵御恶意攻击并向上层提供可靠的服务都是非常重要的。 RRC组成 RC消息是使用平台无关的ASN.1定义的，可以看作图2中的树。每个RRC消息由结构化的(SEQUENCE, SEQUENCE OF, CHOICE) 和原语(BOOLEAN,INTEGER, ENUMERATED,BIT STRING,OCTET STRING) 数据类型, 每个结构化数据类型可以进一步由结构化数据类型和基本数据类型组成. 在传输过程中，RRC消息使用Unaligned Packed Encoding Rules (UPER)[36]进行编码，该规则将数据结构转换为紧凑的字节序列。 [36] ITU. Recommendation ITU-T X.691 International Standard 8825-2: Information technology – ASN.1 encoding rules: Specification of Packed Encoding Rules (PER), Aug 2015. Available at https://www.itu.int/rec/T-REC-X.680-X.693-201508-I/en. RRC 消息 RRC层利用底层的服务实现RRC消息的可靠、安全的传递。上行通道为ULCCCH、UL-DCCH，下行通道为DL-CCCH、DL-DCCH、BCCH、PCCH。 CCCH、PCCH和BCCH通道中的消息通过RLC中的透明模式™以明文形式发送，用于初始AS激活和随机访问过程。因此这些消息不使用PDCP层的服务进行加密和完整性保护。RLC仍然提供检测到错误的重传和RRC有效负载的无重复交付。在上行链路中，RRC报文只通过UL-CCCH和UL-DCCH发送。 5G NR 5G New Radio Fuzzing Radio Resource Control messages in 5G and LTE systems 5G系统提出新的无线电标准, 5G New Radio; 新标准应该支持为将来使用而确定的需求，如更高的数据速度、更低的延迟、移动性和可靠性。5G NR是在RAN和UE之间使用经过许可的电磁频谱传输数据的接入机制。5G系统中的NG-RAN可以由多个下一代节点基站(gNB)或单个gNB组成。NG-RAN将为LTE、3G等传统无线接入技术提供支持。RAN为终端提供了与核心网络和数据网络交互的接口。5G NR由处理控制平面的网络协议栈和处理用户平面消息的网络协议栈组成，分别如下所示 UE和NG-RAN之间的接口叫做Uu，它同时承载着控制平面和用户平面的流量。 缩写名词解释","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"标签二","slug":"标签二","permalink":"https://www.sizaif.com/tags/%E6%A0%87%E7%AD%BE%E4%BA%8C/"}],"author":"sizaif"},{"title":"Docker文件夹映射权限问题思考及可能解决方法","slug":"docker文件夹映射权限问题思考及可能解决方法","date":"2021-09-23T02:19:50.000Z","updated":"2021-09-23T11:41:25.000Z","comments":true,"path":"posts/39ff9093/","link":"","permalink":"https://www.sizaif.com/posts/39ff9093/","excerpt":"","text":"docker文件夹映射权限问题思考及可能解决方法 背景分析 在多用户服务器上公用docker搭建环境时,初步设想为宿主机用户为普通用户,容器内用户为root, 用户在容器内自由搭建自己所需的环境,而不影响其他人以及容器外的环境. 但当用户在使用docker挂载磁盘的时候,由于容器内使用root运行程序，会导致挂载中产生的文件属于root:root。而容器外用户并不是root，会使的文件共享甚至阅读日志产生权限上的问题,导致不可读或不可写之类的问题。 本文旨在宿主机使用普通用户,而容器内仍然使用root用户,且不会产生文件权限的问题. 案例截图: 可以看到创建映射的 srs和srsRAN 文件夹 因为是由docker run 命令自动创建的,权限被化为root 普通用户在这个文件夹下没有权限!, 需求 容器外使用普通用户(没有sudo权限等管理员权限) 容器内使用带管理员权限的root用户 文件挂载原理 简而言之，docker的文件挂载中，容器内外uid与gid相同。 最简单的挂载磁盘，例如：docker run -v $PWD:/data bash，就是将当前目录挂载到容器内的/data目录。文件的权限可以通过ls -l查看。 容器内可能有使用root用户和非root用户运行程序的两种情况。 若容器内使用root运行程序，可以想象，产生的文件属于0:0，也就是root:root。容器外文件也会属于0:0，同样是root:root。这样产生的文件就需要容器外的root权限才可以操作。 若容器内使用非root运行程序，例如demo:x:1000:1000::/home/blog:/bin/bash，产生的文件属于1000:1000。容器外文件也会属于1000:1000，而容器外uid为1000的用户可能是test，这是若碰巧你就是test，你就可以顺利读取这个文件。但若你是uid为1001的test2，而且t是个test2讨厌鬼，你就告别这个文件了。甚至容器外根本没有uid为1000的用户，那这个文件就不属于任何人。 docker用户组 docker用户组的出现,目的在于当普通用户既无sudo权限,有想运行docker命令时出现. 一般来说,在linux环境下安装完成docker,系统会自动创建id=999的docker组 . 此时只需要将普通用户加入到docker组中即可. 具体 docker组的id, 请自行查看 方式有两种(需要在拥有sudo权限的账号下修改): 使用usermod命令 $ sudo usermod -aG docker &lt;用户名> # e.g sudo usermod -aG docker test1 直接修改 /etc/group 中 docker 所在组 $ sudo vim /etc/group # 在docker所在行,按格式在后面添加用户名即可 修改完成后,重启ssh或重新登即可, 使用id &lt;用户名&gt; 检查是否在docker所在组 三种可能解决方法 1. 限定开启用户 即运行 docker run -u &lt;xxx&gt;:&lt;xxx&gt; 但这个方法无法解决上述的需求 2.使用子用户 若容器内外文件的uid:gid可以不同，这个问题就可以很容易解决。的确有这么一个方案，让容器内所有的uid:gid以一定的规则映射，我推荐使用这一方案。文章的方案演示节中我会演示这一方案。 在官方文档中，这个方案本身是为了解决安全问题，见这里。发生容器挂载磁盘root权限提权也不是一次两次了，这算是一个官方的解决方案。 https://docs.docker.com/engine/security/userns-remap/ 但这个方案会有一些限制： 不可使用--pid=host 或 --network=host 不可使用无法识别或使用用户映射的挂载磁盘 若使用docker run --privileged则必须同时使用--userns=host 都是不大的限制，使用的时候留个心眼即可。 解释: 因为docker 权限映射的原理是, 容器内外uid与gid相同, 那么我是否可以 通过 userns-remap 命令实现, 将容器内的root 映射到容器外宿主机上一个具有管理员(sudo)的用户(称为siz)上呢,而其他普通用户(test&lt;xxx&gt;)只需要在这个siz所在的组即可. 而这个组的小组管理员即为siz. 但此时一个新的问题出现了: 当普通用户创建文件夹映射时, 此文件夹的所属者为siz,但小组权限仅为xr 即所在组的成员没有修改的权限,只有读和运行的权限, 并且此时普通用户(test&lt;xxx&gt; 并没有sudo权限,也就无法通过chmod g+w 等命令来实现提权. 此时该如何解决呢? 答: 通过进入容器内提权实现, ​ 因为容器内的用户为root,即对应的权限为小组管理员siz, 而小组管理员拥有(sudo) 权限, 又因为文件映射是容器内外相同的, 在容器内修改了文件权限, 那么在容器外普通用户就有了读写执行的权限. 操作实现 修改/etc/subuid 与 /etc/subgid 查看小组的管理员id $ id siz uid=1000(siz) gid=1000(siz) groups=1000(siz) # 得到 siz的id 为 1000 使用带sudo的权限账号修改 /etc/subuid 与 /etc/subgid 文件 格式为: &lt;name>:start:number 对应方式: 如果组管理员id 为1000 , 则对应容器内的root 为1 , 即&lt;name&gt;:1000:1 如果组管理员id为 1003 ,则对应容器内的root 为 1+(1003-1000)=4 即 &lt;name&gt;:1003:4 根据组管理员id 对应设置好映射 例如本文组管理员siz 的 id 为1000 , 则修改为如下样式, 并保存修改 # sudo vim /etc/subuid siz:1000:1 siz:100000:65536 test1:165536:65536 test2:231072:65536 demo:296608:65536 # sudo vim /etc/subgid siz:1000:1 siz:100000:65536 test1:165536:65536 test2:231072:65536 demo:296608:65536 修改docker 守护程序 /etc/docker/daemon.json 注意修改 /etc/docker/daemon.json 文件后, 会导致之前的 镜像与容器不被识别, 所以请做好备份. 容器-&gt;打包成镜像-&gt; 推送到hub Enabling userns-remap effectively masks existing image and container layers, as well as other Docker objects within /var/lib/docker/. This is because Docker needs to adjust the ownership of these resources and actually stores them in a subdirectory within /var/lib/docker/. It is best to enable this feature on a new Docker installation rather than an existing one. # 没有这个文件的化, 请创建 # sudo vim /etc/docker/daemon.json &#123; \"userns-remap\":\"&lt;组管理员名称>\" &#125; # sudo service docker restart # 查看docker 状态 sudo systemctl status docker.service 这里 `“userns-remap”:&quot;&lt;组管理员名称&gt;&quot;的格式 参考官方文档 https://docs.docker.com/engine/security/userns-remap/ Edit /etc/docker/daemon.json. Assuming the file was previously empty, the following entry enables userns-remap using user and group called testuser. You can address the user and group by ID or name. You only need to specify the group name or ID if it is different from the user name or ID. If you provide both the user and group name or ID, separate them by a colon (:) character. The following formats all work for the value, assuming the UID and GID of testuser are 1001: testuser testuser:testuser 1001 1001:1001 testuser:1001 1001:testuser 修改普通用户的组 当在进行测试的时候发现一个新的问题: 即组内普通用户创建的文件在容器中因为没有相应的`uid:gid` 映射, 并且容器中的`root`用户的权限很低时(组管理员拥有sudo权限,但需要输入sudo才可以; 而容器中时没有sudo命令的,所有说这里的`root`权限很低)在这种情况下: 就会出现普通用户创建的文件,在容器中被识别为: `nobody ,nogroups 现象 暂时的解决方法 普通用户删除私有组,即让普通用户的主组为(docker容器映射的管理员所在的组)​ 例如: 本文演示小组管理员为siz, 组名为(siz) 则让 普通用户test&lt;xxx&gt; 的主组为siz# 命令: sudo usermod -g &lt;小组管理员名称> &lt;普通用户名称> # 将普通用户的主组从私有组改为小组管理员所在的组 $ sudo usermod -g test1 siz对宿主机(容器外)组成员中普通用户创建的文件或文件夹提升组权限目的: 使容器内root获得对这个文件夹拥有修改(w) 权限$ chmod g+wxr &lt;xxx>对容器内root 创建的文件或文件夹提升组权限目的: 使宿主机(容器外) 组成员普通用户获得对这个文件夹拥有修改(w) 权限$ chmod g+wxr &lt;xxx>缺陷:当内外创建新的文件和文件夹使, 内外要不断的使用chmod 命令进行授权, 演示: 组成员 组管理员(siz) 进行映射测试: 组成员test1 进行映射测试 使用entrypoint.sh 定制脚本 这个过程是在编写Dockerfile文件时使用的, 目的是让容器内外对应的用户相等来解决文件夹映射目录权限的问题. 主要的思路是,从主机中读取当前用户的id, 然后再创建容器时相应的在容器内部新建一个对应的用户, 这样保证了容器内外的uid:gid 相等. 但在这个里不符合我们的需求, 故不讨论. 总结 为了解决让宿主机使用普通用户来使用docker,而在容器中相对给与较高的root 权限用户需求. 本文采用了修改docker守护程序的方法,其官方文件本意是docker为了解决容器内root升权的问题 所谓升权, 即不做任何修改情况下, 容器内root 与宿主机root相对应, 虽然这个容器内的权限是有一定限制的root 权限, 但可以通过映射宿主机根目录,将所有内容映射到容器中, 实现在容器中获得所有文件的权限,来实现恶意攻击. 通过映射用户, 容器中的root 权限与宿主机被映射的用户权限相等, 可以思考这样一个问题: 如果我映射的宿主机用户是一个普通用户(没有sudo)权限,那么容器里的root 有没有sudo权限呢? 答案 答案是没有的, 可以尝试一下. 容器的的root 仅仅是个名称, 它可以叫做superhero 也可以叫做 tom , 只是个名字,并无所谓,真正相关的是uid:gid","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"实验室服务器用户分级管理+Docker多环境运行设想","slug":"实验室服务器用户分级管理-docker多环境运行设想","date":"2021-09-10T14:39:54.000Z","updated":"2021-09-20T00:45:22.000Z","comments":true,"path":"posts/55127002/","link":"","permalink":"https://www.sizaif.com/posts/55127002/","excerpt":"","text":"[TOC] 用户分级管理 初步设想: root 用户为超级管理员, 管理员-A 拥有管理权限,负责维护. 普通群组无超级管理员权限, 但拥有对docker镜像容器的创建修改删减启动等权限. 普通用户从dockerhub中拉取镜像,创建容器环境 跳转 docker使用手册v1 步骤 安装Docker 查看版本 $ cat /proc/version $ uname -a $ lsb_release -a $ cat /etc/issue 对症下药 ubuntu 参考文档 https://docs.docker.com/engine/install/ubuntu/ 使用远程仓库安装 Install using the repository Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository. Update the apt package index and install packages to allow apt to use a repository over HTTPS $ sudo apt-get update # 必要软件 $ sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release Add Docker’s official GPG key: $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg Use the following command to set up the stable repository. To add the nightly or test repository, add the word nightly or test (or both) after the word stable in the commands below. Learn about nightly and test channels. ​ Note: The lsb_release -cs sub-command below returns the name of your Ubuntu distribution, such as xenial. Sometimes, in a distribution like Linux Mint, you might need to change $(lsb_release -cs) to your parent Ubuntu distribution. For example, if you are using Linux Mint Tessa, you could use bionic. Docker does not offer any guarantees on untested and unsupported Ubuntu distributions. x86_64 / amd64armhfarm64s390x$ echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null$ echo \\ \"deb [arch=armhf signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null$ echo \\ \"deb [arch=arm64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null$ echo \\ \"deb [arch=s390x signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null Install Docker Engine Update the apt package index, and install the latest version of Docker Engine and containerd, or go to the next step to install a specific version: $ sudo apt-get update $ sudo apt-get install docker-ce docker-ce-cli containerd.io Got multiple Docker repositories? If you have multiple Docker repositories enabled, installing or updating without specifying a version in the apt-get install or apt-get update command always installs the highest possible version, which may not be appropriate for your stability needs. Upgrade Docker Engine To upgrade Docker Engine, first run sudo apt-get update, then follow the installation instructions, choosing the new version you want to install. 添加测试用户 $ sudo adduser test1 Adding user `test1' ... Adding new group `test1' (1001) ... Adding new user `test1' (1001) with group `test1' ... Creating home directory `/home/test1' ... Copying files from `/etc/skel' ... New password: Retype new password: passwd: password updated successfully Changing the user information for test1 Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] y $ sudo adduser test2 Adding user `test2' ... Adding new group `test2' (1002) ... Adding new user `test2' (1002) with group `test2' ... Creating home directory `/home/test2' ... Copying files from `/etc/skel' ... New password: Retype new password: passwd: password updated successfully Changing the user information for test2 Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] y siz@ubuntu:/etc/apt$ 查看test1,test2 用户 $ id test1 # uid=1001(test1) gid=1001(test1) groups=1001(test1) $ id test2 # uid=1002(test2) gid=1002(test2) groups=1002(test2) # 可以发现 test1 test2 没有sudo 等权限,为 普通用户 授予docker权限 将test1,test2 普通用户 添加到docker组中 $ sudo usermod -aG docker test1 $ sudo usermod -aG docker test2 重新登陆ssh 或者 log out 在登陆后, 查看 用户标识 $ id test1 # uid=1001(test1) gid=1001(test1) groups=1001(test1),,998(docker) # 可以发现多了docker的 组标识 # 此时运行docker info 测试 $ docker info Client: Context: default Debug Mode: false Plugins: app: Docker App (Docker Inc., v0.9.1-beta3) buildx: Build with BuildKit (Docker Inc., v0.6.1-docker) scan: Docker Scan (Docker Inc., v0.8.0) 拉取 docker images 测试test1拉去docker镜像 $ docker pull sizaif2000/ubuntu2004v1:1.0 ubuntu:20.04 V1 使用清华源 已安装基本工具: VIM - Vi IMproved 8.1 (2018 May 18, compiled Apr 15 2020 06:40:31) cmake version 3.16.3 gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) g++ (4:9.3.0-1ubuntu2). wget,git,autoconf,automake,build-essential Python 3.8.10 (default, Jun 2 2021, 10:49:15) pip3 pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) ubuntu:20.04 V2 使用清华源 已安装基本工具: VIM - Vi IMproved 8.1 (2018 May 18, compiled Apr 15 2020 06:40:31) cmake version 3.16.3 gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) g++ (4:9.3.0-1ubuntu2). wget,git,autoconf,automake,build-essential Python 3.8.10 (default, Jun 2 2021, 10:49:15) pip3 pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) ==java-jdk1.8.0_291== 参考知识 添加/移除 sudo 权限 给某个用户添加 sudo 权限 $ sudo adduser XXXX sudo 移除某个用户sudo权限 $ sudo deluser xxxx sudo ==注意!!!== 移除sudo时, 管理用不要把唯一的管理员的sudo权限移除掉, 否则需要 root 用户重新添加 ubuntu用户组 用户和用户标识号 用户 我们登录到Linux系统，使用的登录名和密码实际上就是用户的信息标识。用户拥有账号、登录名、真实姓名、密码、主目录、默认shell等属性。每个用户实际上代表了一组权限，而这些权限分别表示可以执行不同的操作，是能够获取系统资源的权限的集合。 用户标识号 Linux实际上并不直接认识用户的账号，而是查看用户标识号。 用户标识号（整数）： 0： root，超级用户。 1-499：系统用户，保证系统服务正常运行，一般不使用。 500-60000：普通用户，可登录系统，拥有一定的权限。管理员添加的用户在此范围内。 用户名和标识号不一定一一对应，Linux允许几个登录名对应同一个用户标识号。 系统内部管理进程和文件访问权限时使用用户标识号。 账号和标识号的对应关系在/etc/passwd文件中。 /etc/passwd文件 该文件所有者和所属组为root，除了root用户外只有读取的权限。 格式：登录名：口令：用户标识号：组标识号：注释：用户主目录：Shell程序 登录名：同意系统中唯一，大小敏感。 口令：密码，root和用户可使用passwd命令修改。 用户标识号：唯一。 组标识号：每个用户可以同时属于多个组。 注释：相关信息，真实姓名、联系电话等。mail和finger等会使用这些信息。 用户主目录：用户登录后的默认工作目录。root为/root，一般用户在/home下。 Shell程序：登录后默认启动的Shell程序。 /etc/shadow文件 包含用户的密码和过期时间，只有root组可读写。 格式：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：密码禁用期：账户失效时间：保留字段 登录名：略。 加密口令：*表示账户被锁定，！表示密码被锁定。其他的前三位表示加密方式。 最后一次修改时间：最近修改密码的时间，天为单位，1970年1月1日算起。 最小时间间隔：最小修改密码的时间间隔。 最大时间间隔：最长密码有效期，到期要求修改密码。 警告时间：密码过期后多久发出警告。 密码禁用期：密码过期后仍然接受的最长期限。 账号失效时间：账户的有效期，1970年1月1日算起，空串表示永不过期。 保留字段：保留将来使用。 用户组和组标识号 用户组 用户组指，一组权限和功能相类似的用户的集合。 Linux本身预定义了许多用户组，包括root、daemon、bin、sys等，用户可根据需要自行添加用户组。 用户组拥有组名、组标识号、组成员等属性。 用户组编号 Linux内部通过组标识号来标识用户组。 用户组信息保存在 /etc/group 中。 /etc/group文件 格式：组名：口令：组标识符：成员列表 /etc/passwd文件指定的用户组在/etc/group中不存在则无法登录。 用户管理 添加用户 useradd命令 $ useradd [option] 登录名 # option参数自行查阅。 # 一般加-m创建目录。 adduser命令 $ adduser [option] user 如果没有指定–system和–group选项，则创建普通用户。 否则创建系统用户或用户组。 修改用户信息：usermod $ usermod [option] 用户名 # 具体选项信息自行查阅。 删除用户：userdel $ userdel [option] 用户名 # -f：强制删除（谨慎使用） # -r：主目录中的文件一并删除。 修改用户密码：passwd $ passwd [option] 登录名 显示用户信息 $ id [option] [用户] 用户间切换：su命令 $ su [option] [用户名] # 用户名为 - ，则切换到root用户。 受限的特权：sudo命令 sudo使得用户可以在自己的环境下，执行需要root权限的命令。 该信息保存在/etc/sudoers中。 用户组管理 添加用户组 addgroup命令 类似adduser groupadd 类似useradd 修改用户组 类似usermod，使用groupmod。 删除用户组 类似userdel，使用groupdel。 权限管理 权限组 一般创建文件的人为所有者，其所属的主组为所属组，其他用户为其他组。 基本权限类型 三种：读、写、执行。 权限及其表示值： 读：r或4 写：w或2 执行：x或1 特殊权限 setuid、setgid和黏滞位。 setuid和setgid能以文件所有者或所属组的身份运行。 黏滞位使得只有文件的所有者才可以重命名和删除文件。 访问控制列表 访问控制表ACL可以针对某个用户或者用户组单独设置访问权限。 改变文件所有者chown命令 $ chown [option]...[owner][:[group]] file... 改变文件所属组chgrp命令 用户不受文件的文件主或超级用户不能修改组。 设置权限掩码umask命令 文件的权限为666-掩码 目录的权限为777-掩码 修改文件访问权限 $ chmod [option]...mode[,mode]...file... “+”：增加权限 “-”：减少权限 “=”：设置权限 修改文件ACL：setfacl命令 $ setfacl [option] file... 查询文件的ACL $ getfacl [文件名]","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"TSW-2 列车操作手册合集","slug":"TSW-2-列车操作手册合集","date":"2021-08-29T03:27:02.000Z","updated":"2021-09-19T07:24:21.000Z","comments":true,"path":"posts/238e4ec1/","link":"","permalink":"https://www.sizaif.com/posts/238e4ec1/","excerpt":"","text":"F40PH-3C型号操作手册 the F40PH-3C is a locomotive used on the MBTA Commuter Rail. It is featured in Boston Sprinter. 快速启动 主电池打开 无线电保险丝打开 按住引擎启动开关4s 按住列车供电引擎启动4s 交流电按钮 打开 列车电力设置为 “长机罩拖车” 隔离开关设置为运行 断流阀设置为&quot;切入&quot; MU-2A阀门设置为 “导联或断开” 引擎运行设置为打开 电机磁场设置为打开 控制与燃料泵设置为打开 电空制动设置为打开 设置主钥匙插入 此时状态为: 打开车门迎客U 反向器设置为: 前牵位 ( 此时阀门要设置空挡) 设置列车单独制动为 &quot; 缓解&quot; 增加阀门上调动力 前进 列车启动 done CTC-3 型号操作手册 快速启动 发电机磁场设置为打开 引擎运行设置为打开 电空制动控制设置为打开 反向器设置为空挡 断流阀设置为客运 打开车门上客 反向器设置为: 前牵位 ( 此时阀门要设置空挡) 制动设置为缓解 增加阀门上调动力 列车启动done 德铁 403&quot;ICE3&quot;机型手册 快速启动 节流阀启动增加动力 423 机型手册 快速启动 插入反向器钥匙 反向器设置为前牵引 开启车门 施加动力开启火车 ( 主控器向前施加百分比动力/ 向后设置制动减速)","categories":[{"name":"游戏向","slug":"游戏向","permalink":"https://www.sizaif.com/navigation/categories/%E6%B8%B8%E6%88%8F%E5%90%91/"},{"name":"TSW2","slug":"游戏向/TSW2","permalink":"https://www.sizaif.com/navigation/categories/%E6%B8%B8%E6%88%8F%E5%90%91/TSW2/"}],"tags":[{"name":"TSW2","slug":"TSW2","permalink":"https://www.sizaif.com/tags/TSW2/"}],"author":"sizaif"},{"title":"解决Win平台上linux虚拟机脚本格式问题","slug":"解决Win平台上linux虚拟机脚本格式问题","date":"2021-08-24T12:26:15.000Z","updated":"2021-09-19T10:09:19.000Z","comments":true,"path":"posts/448c4b49/","link":"","permalink":"https://www.sizaif.com/posts/448c4b49/","excerpt":"","text":"解决Win平台上linux虚拟机脚本格式问题 问题描述 经常会有以下使用场景: 在windows平台上编写脚本,复制脚本到docker容器linux中运行,或者复制到linux虚拟机中运行. 尝尝会报错: $'\\r' command not found 这样的错误 原因在于: Carriage-Return 回车符\\r Line-Feed 换行符\\n windows平台使用的格式是CRLF 结尾是 \\r\\n; 而 linux 和macOS平台使用的是LF结尾是\\n ;而MAC平台使用的是CR 结尾是\\r 老的Mac系统（Mac OS, OS X）： \\r 新的Mac系统（macOS）:\\n 在2001年以前的Mac操作系统，称为Classic Mac OS，行末采用”\\r”，这一系列操作系统的最后一个版本是1999年发布的Mac OS 9； 从2001年3月发布的Mac OS 10.0开始，行末采用”\\n”，称为macOS或OS X 查看脚本格式 1.cat -A filename，如果输出结果中行末尾是^M$，则是dos格式，如果行末尾只是$，则是unix格式。 2.vim filename，编辑文件，执行“:set ff”,若执行结果为fileformat=dos则为dos格式，若执行结果为fileformat=unix则为unix格式。 3.od -t x1 filename，以16进制查看文件，若输出结果中存在“0d 0a”则为dos格式，如果只有“0a”则为unix格式。其中“0d”即为回车符“\\r”，“0a”即为换行符“\\n”。 解决方法 当然是想办法把windows平台下的脚本转换成 LF呀 如果有vim\\vi ​ vim内执行 Shift + ; :set ff = unix :wq 使用dos2unix 工具 如果用的是 git bash 那么该客户端已经自带了 dos2unix 如果不是的话前提需要先安装dos2unix http://dos2unix.sourceforge.net/ 例如: 我使用的是 CygWin64 Mintty 控制台 那么我只需要执行即可 $ apt-cyg install dos2unix dos2unix 使用方法 # 使用方法 $ dos2unix filename # 或者使用以下命令,强制转换 $ find . -type f -exec dos2unix &#123;&#125; + # -f --force Force conversion of all files. Also binary files. 使用sed 命令 $ sed -e ‘s/.$//’ dosfile > unixfile 通常情况下是完全可以实现的, 但这个方法不是100%的解决方法 git 跨平台协作开发, 经场会出现在win平台下,使用git clone 命令将项目源码下载下来后,拿到linux虚拟机中运行,出现换行符错误的问题, 原因在于win平台使用git的时候, git自动将换行符替换为\\r\\n, 这时候再拿到linux中运行当然就不行了. 还好 Git 在设计时就考虑了这一点，其提供了一个 autocrlf 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项： true: 提交时转换为 LF，检出时转换为 CRLF false: 提交检出均不转换 input: 提交时转换为LF，检出时不转换 # 提交时转换为LF，检出时转换为CRLF git config --global core.autocrlf true # 提交时转换为LF，检出时不转换 git config --global core.autocrlf input # 提交检出均不转换 git config --global core.autocrlf false 查看当前git config 配置 $ git config --list http.proxy=socks5://127.0.0.1:7890 https.proxy=socks5://127.0.0.1:7890 user.name=XXXX user.email=XXXX core.autocrlf=true 如果把 autocrlf 设置为 false 时，那另一个配置项 safecrlf 最好设置为 ture。该选项用于检查文件是否包含混合换行符，其有三个可选项 true: 拒绝提交包含混合换行符的文件 false: 允许提交包含混合换行符的文件 warn: 提交包含混合换行符的文件时给出警告 # 拒绝提交包含混合换行符的文件 git config --global core.safecrlf true # 允许提交包含混合换行符的文件 git config --global core.safecrlf false # 提交包含混合换行符的文件时给出警告 git config --global core.safecrlf warn 像比如我, 再win上开发,使用git提交到github, 经常从github上下载项目,再win上修改后,拿到linux虚拟机/docker中运行, 那我的做法就是: 代码仓库使用统一的换行符(LF) $ git config --global core.autocrlf input $ git config --global core.safecrlf true 当遇到CRLF无法提交的时候, 用doc2unix 转换一下即可","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"}],"tags":[{"name":"Win","slug":"Win","permalink":"https://www.sizaif.com/tags/Win/"},{"name":"脚本格式","slug":"脚本格式","permalink":"https://www.sizaif.com/tags/%E8%84%9A%E6%9C%AC%E6%A0%BC%E5%BC%8F/"}],"author":"sizaif"},{"title":"Hexo博客优化","slug":"hexo博客优化","date":"2021-08-14T14:22:06.000Z","updated":"2021-09-19T10:09:19.000Z","comments":true,"path":"posts/83186147/","link":"","permalink":"https://www.sizaif.com/posts/83186147/","excerpt":"","text":"hexo博客优化 本地优化 文章链接唯一 Hexo默认使用的文章永久链接格式是： year/:month/:day/:title/ 缺点: 若标题为中文标题,则分享链接时会变成%X%X%X%之类的东西,非常难受.又臭又长,而且一旦更改标题和日期,链接会失效,非常不友好 解决方法: 采用 hexo-abbrlink 插件 在博客根目录（执行hexo命令的地方）安装插件： npm install hexo-abbrlink --save 编辑站点配置文件 _config.yml 首先注释掉原先的permalink设置 配置代码 # ======================================================= # # =====================abbrlink========================== # # ======================================================= # #permalink: :year/:month/:day/:title/ # permalink_defaults: # pretty_urls: # trailing_index: false # Set to false to remove trailing 'index.html' from permalinks # trailing_html: false # Set to false to remove trailing '.html' from permalinks permalink: posts/:abbrlink/ abbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex drafts: false #(true)Process draft,(false)Do not process draft. false(default) # Generate categories from directory-tree # depth: the max_depth of directory-tree you want to generate, should > 0 auto_category: enable: true #true(default) depth: #3(default) over_write: false auto_title: false #enable auto title, it can auto fill the title by path auto_date: false #enable auto date, it can auto fill the date by time today force: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. 项目链接: hexo-abbrlinkhttps://github.com/Rozbo/hexo-abbrlink 重新部署 hexo clean &amp;&amp; hexo g 重新部署后,会在front-matter 字段中增加 abbrlink 字段 验证查看 ,本地测试查看 hexo s -g Gulp压缩资源 安装gulp及相关插件 可以直接修改 package.json 添加 gulp-replace 版本号以及gulp依赖 修改完成后, 在blog根目录下控制台 输入: npm i 重新部署package.json 以下是我的package.json 可供参考 package.json &#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"scripts\": &#123; \"rebuild\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp\", \"rebuildJsd\": \"hexo clean &amp;&amp; hexo generate --config _github.yml &amp;&amp; gulp two\", \"deployGit\": \"hexo deploy --config _github.yml\", \"deployGitHub\": \"hexo deploy --config _githubOnly.yml\", \"deployOss\": \"hexo deploy --config _tencent.yml\", \"start\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d\", \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"server\": \"hexo server\" &#125;, \"hexo\": &#123; \"version\": \"5.4.0\" &#125;, \"dependencies\": &#123; \"aplayer\": \"^1.10.1\", \"gulp-replace\": \"^1.1.3\", \"hexo\": \"^5.0.0\", \"hexo-abbrlink\": \"^2.2.1\", \"hexo-autonofollow\": \"^1.0.1\", \"hexo-deployer-git\": \"^3.0.0\", \"hexo-generator-archive\": \"^1.0.0\", \"hexo-generator-baidu-sitemap\": \"^0.1.9\", \"hexo-generator-category\": \"^1.0.0\", \"hexo-generator-index\": \"^2.0.0\", \"hexo-generator-json-content\": \"^4.2.3\", \"hexo-generator-search\": \"^2.4.3\", \"hexo-generator-sitemap\": \"^2.1.0\", \"hexo-generator-tag\": \"^1.0.0\", \"hexo-renderer-ejs\": \"^1.0.0\", \"hexo-renderer-markdown-it\": \"^5.0.0\", \"hexo-renderer-stylus\": \"^2.0.0\", \"hexo-server\": \"^2.0.0\", \"hexo-theme-stellar\": \"^1.4.1\", \"hexo-wordcount\": \"^6.0.1\", \"markdown-it-emoji\": \"^2.0.0\" &#125;, \"devDependencies\": &#123; \"gulp\": \"^4.0.2\", \"gulp-html-minifier-terser\": \"^6.0.1\", \"gulp-htmlclean\": \"^2.7.22\", \"gulp-htmlmin\": \"^5.0.1\", \"gulp-minify-css\": \"^1.2.4\", \"gulp-terser\": \"^2.0.1\" &#125; &#125; 编辑gulpfile.js blog根目录下添加gulpfile.js 文件 添加代码 其中 minify_html_jsd 对应的是使用cdn 重定向, 后面链接对应改成自己的静态文件仓库即可 pipe(replace(xxx, xxx)) 是链接重定向, 跟根据需求自定义 gulpfile.js var gulp = require('gulp'); var minifycss = require('gulp-minify-css'); var htmlmin = require('gulp-html-minifier-terser'); // var uglify = require('gulp-uglify'); var htmlclean = require('gulp-htmlclean'); var terser = require('gulp-terser'); var replace = require('gulp-replace'); // 压缩css文件 const minify_css = () => ( gulp.src(['./public/**/*.css']) .pipe(minifycss(&#123; compatibility: 'ie8' &#125;)) // .pipe(minifycss()) .pipe(gulp.dest('./public')) ); // 压缩html文件 const minify_html = () => ( gulp.src(['./public/**/*.html','!./public/&#123;lib,lib/**&#125;','!./public/**.xml']) .pipe(replace('src=\"/js/', 'src=\"https://sizaif.com/js/')) .pipe(replace('href=\"/css/\"', 'href=\"https://sizaif.com/css/')) .pipe(replace('../img/img_article', 'https://sizaif.com/img/img_article/')) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public')) ) const minify_html_jsd = () => ( gulp.src(['./public/**/*.html','!./public/&#123;lib,lib/**&#125;']) .pipe(replace('src=\"/js/', 'src=\"https://cdn.jsdelivr.net/gh/sizaif/blog-cdn@main/js/')) .pipe(replace('href=\"/css/\"', 'href=\"https://cdn.jsdelivr.net/gh/sizaif/blog-cdn@main/css/\"')) .pipe(replace('../img/img_article', 'https://cdn.jsdelivr.net/gh/sizaif/blog-cdn@main/img/img_article')) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public')) ) // 压缩js文件 const minify_js = () => ( gulp.src(['./public/**/*.js', '!./public/**/*.min.js','!./public/&#123;lib,lib/**&#125;']) .pipe(terser()) // .pipe(uglify()) .pipe(gulp.dest('./public')) ) module.exports = &#123; minify_html: minify_html, minify_css: minify_css, minify_js: minify_js, minify_html_jsd: minify_html_jsd &#125;; gulp.task('one', gulp.parallel( minify_html, minify_css, minify_js )); gulp.task('two', gulp.parallel( minify_html_jsd, minify_css, minify_js )); gulp.task('default', gulp.series('one')); 运行 使用gulp后, 发布推送(hexo d)前需要添加一个命令 # 不使用cdn $ hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d # 使用cdn重定向 $ hexo clean &amp;&amp; hexo g &amp;&amp; gulp two &amp;&amp; hexo d SEO-sitemap 安装插件 百度 $ npm install hexo-generator-baidu-sitemap --save 谷歌 $ npm install hexo-generator-sitemap --save 编辑主站_config.yml 添加代码 ## ======================================================= # ## ==三、SEO 优化二网站地图 npm install hexo-generator-sitemap --save====== # ## npm install hexo-generator-baidu-sitemap --save ## ======================================================= # sitemap: path: sitemap.xml # tag: true # category: true baidusitemap: path: baidusitemap.xml 重新部署 会在public目录下生成: sitemap.xml -&gt; 谷歌 baidusitemap.xml -&gt; 百度 $ hexo clean &amp;&amp; hexo g 然后分别去对于站点网站提交即可 百度站点管理https://ziyuan.baidu.com/site/ 谷歌站点管理https://search.google.com/search-console/about robots.txt文件 robots.txt是一个纯文本文件，在这个文件中网站管理者可以声明该网站中不想被robots访问的部分，或者指定搜索引擎只收录指定的内容。 当一个搜索机器人（有的叫搜索蜘蛛）访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，那么搜索机器人就沿着链接抓取。 另外，robots.txt必须放置在一个站点的根目录下，而且文件名必须全部小写。 在source 目录下 新建 robots.txt 域名改成自己的 robots.txt # robots.txt www.sizaif.com User-agent: * Allow: /sitemap.xml Allow: /baidusitemap.xml Allow: /category-sitemap.xml Allow: /page-sitemap.xml Allow: /post-sitemap.xml Allow: /tag-sitemap.xml Allow: /posts/ Disallow: /css Disallow: /js Disallow: /fonts Disallow: /img Disallow: /fonts Disallow: /page Disallow: /navigation Disallow: /tags Disallow: /archives Disallow: /404.html Disallow: /403.html Disallow: /update.log Disallow: /search.xml Disallow: /README.md","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Hexo","slug":"技术向/Hexo","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.sizaif.com/tags/Hexo/"}],"author":"sizaif"},{"title":"七夕-杂谈","slug":"七夕-杂谈","date":"2021-08-14T09:28:28.000Z","updated":"2021-11-13T02:35:33.000Z","comments":true,"path":"posts/52b019f9/","link":"","permalink":"https://www.sizaif.com/posts/52b019f9/","excerpt":"","text":"送给每一对甜甜蜜蜜的你们!","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.sizaif.com/navigation/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.sizaif.com/tags/%E6%9D%82%E8%B0%88/"}],"author":"sizaif"},{"title":"Mybatis Insert 插入时拿到自增的主键ID","slug":"Mybatis-Insert-插入时拿到自增的主键ID","date":"2021-08-14T09:17:51.000Z","updated":"2021-09-19T10:09:19.000Z","comments":true,"path":"posts/eabbfbf/","link":"","permalink":"https://www.sizaif.com/posts/eabbfbf/","excerpt":"","text":"useGeneratedKeys=“true” : 是否开启生成主键 keyColumn=“数据库中主键名称” eyProperty=“(实体类中主键对应的名称或者自定义名称)”&gt; 如果你传入的参数是实体类, 那么请注意keyProperty 对应的应该是实体类中的主键ID; 如果你传入的参数是map,那么就可以自定义名称. 注意:新添加主键id并不是在执行添加操作时直接返回的，而是在执行添加操作之后将新添加记录的主键id字段返回到传入的参数类中. 例如: &lt;insert id=\"addUser\" parameterType=\"map\" useGeneratedKeys=\"true\" keyColumn=\"id\" keyProperty=\"id\"> INSERT INTO saishiguanli.users (createDate, modifyDate, isEnabled, isLocked, lastLoginDate, lastLoginIp, lockDate, name, encodePassword) VALUES (#&#123;createDate&#125;,#&#123;modifyDate&#125;,#&#123;isEnabled&#125;,#&#123;isLocked&#125;,#&#123;lastLoginDate&#125;,#&#123;lastLoginIp&#125;,#&#123;lockDate&#125;,#&#123;name&#125;,#&#123;encodePassword&#125;) &lt;/insert> 调用addUser方法后 int id = Integer.parseInt(hashMap.get(\"id\").toString()); 便可以取得主键ID; 若 传入的是实体类, 那么调用方法后 int id = user.getId(); 即可","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"}],"author":"sizaif"},{"title":"Mybatis中update使用动态SQL语句","slug":"Mybatis中update使用动态SQL语句","date":"2021-08-14T09:10:44.000Z","updated":"2021-09-19T10:09:19.000Z","comments":true,"path":"posts/119fdf75/","link":"","permalink":"https://www.sizaif.com/posts/119fdf75/","excerpt":"","text":"记个笔记:mybatis遇到的坑 Mybatis 进行Update 操作时; 有的数据不一定要进行修改,因此从前台传过来的数据,某些项可能为null; 在进行sql 语句时 就会进行异常;导致操作失败; 所以进行动态SQL语句拼接: 在UserMapper.xml中 更改:Mybatis中update使用动态SQL语句 &lt;update id=\"updateUser\" parameterType=\"map\" > update saishiguanli.user &lt;trim prefix=\"set\" suffixOverrides=\",\"> &lt;if test=\"ulevel!=null\">ulevel=#&#123;ulevel&#125;,&lt;/if> &lt;if test=\"ugender!=null\">ugender=#&#123;ugender&#125;,&lt;/if> &lt;if test=\"uname!=null\">uname=#&#123;uname&#125;,&lt;/if> &lt;if test=\"upwd!=null\">upwd=#&#123;upwd&#125;,&lt;/if> &lt;if test=\"unickname!=null\">unickname=#&#123;unickname&#125;,&lt;/if> &lt;if test=\"uimage!=null\">uimage=#&#123;uimage&#125;,&lt;/if> &lt;if test=\"uphone!=null\">uphone=#&#123;uphone&#125;,&lt;/if> &lt;if test=\"ucreatetime!=null\">ucreatetime=#&#123;ucreatetime&#125;,&lt;/if> &lt;/trim> where uid = #&#123;uid&#125; &lt;/update>","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"}],"author":"sizaif"},{"title":"解决Waline使用图片上传图床跨域错误问题","slug":"解决waline使用图片上传图床跨域错误问题","date":"2021-08-13T02:07:10.000Z","updated":"2021-09-21T06:09:52.000Z","comments":true,"path":"posts/db8bf7ad/","link":"","permalink":"https://www.sizaif.com/posts/db8bf7ad/","excerpt":"","text":"@auther by sizaf 错误描述: 说明 我采用的是Volantis 作为主题 在主题_config.yml 文件中 修改waline 配置 waline: js: https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js path: # 全局评论地址 目前设置全局评论地址后visitor失效,这是waline的问题 placeholder: 允许匿名评论，评论支持贴图，大家在截图后，在评论框粘贴，自动传至图床，欢迎使用体验~ # 评论占位提示 imageHosting: https://7bu.top/api/upload # 图床api「默认使用去不图床」 # 其他配置项按照yml格式继续填写即可 除了 [el path placeholder uploadImage] 选项 meta: [nick,mail,link] # waline comment header info requiredFields: [nick,mail] serverURL: # Waline 的服务端地址「必填」 测试用地址: https://waline-ruddy.vercel.app avatar: robohash # gravatar style https://waline.js.org/client/basic.html#avatar pageSize: 10 # 评论每页显示数量 lang: zh-CN visitor: true 其中 serverURL 选项 请参考文档使用说明 waline文档https://waline.js.org/guide/get-started.html 若采用其他主题,可按照官方设置加入 uploadImage 即可, 具体参考 &lt;head> .. &lt;script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'>&lt;/script> ... &lt;/head> &lt;body> ... &lt;div id=\"waline\">&lt;/div> &lt;script> new Waline(&#123; el: '#waline', path: location.pathname, serverURL: 'https://your-domain.vercel.app' uploadImage: function(file) &#123; const formData = new FormData(); formData.append('image', file); return fetch('https://7bu.top/upload/upload.html', &#123; method: 'POST', body: formData &#125;).then(resp => resp.json()).then(resp => resp.data.url); &#125; &#125;); &lt;/script> &lt;/body> 修改 如果你使用volantis作为主题, 那么只需要修改themes\\volantis\\layout\\_third-party\\comments\\waline\\script.ejs 文件中 的uploadImage函数 将your's token value 替换为你自己的 图床 token uploadImage: function(file) &#123; const formData = new FormData(); formData.append('image', file); const token = \"your's token value\"; return fetch('&lt;%= theme.comments.waline.imageHosting %>', &#123; method: 'POST', body: formData, headers: &#123;'Authorization': token&#125; &#125;).then(resp => resp.json()).then(resp => resp.data.url); &#125;, 若采用其他主题 请修改代码 将your's token value 替换为你自己的 图床 token &lt;head> .. &lt;script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'>&lt;/script> ... &lt;/head> &lt;body> ... &lt;div id=\"waline\">&lt;/div> &lt;script> new Waline(&#123; el: '#waline', path: location.pathname, serverURL: 'https://your-domain.vercel.app' uploadImage: function(file) &#123; const formData = new FormData(); const token = \" your's token value\"; formData.append('image', file); return fetch('https://7bu.top/upload/upload.html', &#123; method: 'POST', body: formData, headers: &#123;'Authorization': token&#125; &#125;).then(resp => resp.json()).then(resp => resp.data.url); &#125; &#125;); &lt;/script> &lt;/body>","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"杂项","slug":"技术向/杂项","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://www.sizaif.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Waline","slug":"Waline","permalink":"https://www.sizaif.com/tags/Waline/"}],"author":"sizaif"},{"title":"PicGo + Gitee(码云)实现markdown图床","slug":"PicGo-Gitee-码云-实现markdown图床","date":"2021-08-12T02:27:37.000Z","updated":"2021-09-19T10:12:20.000Z","comments":true,"path":"posts/373ab937/","link":"","permalink":"https://www.sizaif.com/posts/373ab937/","excerpt":"","text":"@auther by sizaif 转载https://www.jianshu.com/p/b69950a49ae2","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"图床","slug":"技术向/图床","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://www.sizaif.com/tags/PicGo/"},{"name":"Gitee","slug":"Gitee","permalink":"https://www.sizaif.com/tags/Gitee/"}],"author":"sizaif"},{"title":"HE 在人脸识别中的应用Demo 演示文档","slug":"HE-在人脸识别中的应用demo-演示文档","date":"2021-08-12T02:08:34.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/6c15e2cc/","link":"","permalink":"https://www.sizaif.com/posts/6c15e2cc/","excerpt":"","text":"@auther by sizaif HE 在人脸识别中的应用demo 演示文档 @[toc] 说明 使用的HE方案是CKKS / | Encryption parameters : | scheme: CKKS | poly_modulus_degree: 8192 | coeff_modulus size: 200 (60 + 40 + 40 + 60) bits | scale: pow(2.0,40) \\ 输入数据的长度 n = 10 , 因为没有用FaceNet数据集的缘故,演示所用的测试数据来源为简单生成,生成方式为: 编译平台: Visual Studio 2019 所需外部环境: seal.h ; examples.h ； bits/stdc++.h 项目代码上传至: github: https://github.com/sizaif/SEALExamples/tree/main 数据来源 输入的input数据和database数据来源生成代码如下: code // slot_count = poly_modulus_degree /2 => 4096 double curr_point = 0; double step_size = 1.0 / (static_cast&lt;double>(slot_count) - 1); ofstream out; out.open(\"database.txt\", ios::in | ios::out | ios::binary | ios::trunc); if (out.is_open()) &#123; int step = 0; for (size_t i = 0; i &lt; slot_count; i++) &#123; // 每10行一个数据 if(step %10 == 9) out &lt;&lt; curr_point &lt;&lt; \"\\n\"; else &#123; out &lt;&lt; curr_point &lt;&lt; \" \"; &#125; step++; curr_point += step_size; &#125; out &lt;&lt; endl; out.close(); cout &lt;&lt; \"Input vector: \" &lt;&lt; endl; &#125; 选取的input数据如下: [0.984127 0.984371 0.984615 0.98486 0.985104 0.985348 0.985592 0.985836 0.986081 0.986325] 从生成的database中最后10行中选取第6行生成 选取的database E 数据如下: data [0.974359 0.974603 0.974847 0.975092 0.975336 0.97558 0.975824 0.976068 0.976313 0.976557][0.976801 0.977045 0.977289 0.977534 0.977778 0.978022 0.978266 0.97851 0.978755 0.978999][0.979243 0.979487 0.979731 0.979976 0.98022 0.980464 0.980708 0.980952 0.981197 0.981441][0.981685 0.981929 0.982173 0.982418 0.982662 0.982906 0.98315 0.983394 0.983639 0.983883][0.984127 0.984371 0.984615 0.98486 0.985104 0.985348 0.985592 0.985836 0.986081 0.986325][0.986569 0.986813 0.987057 0.987302 0.987546 0.98779 0.988034 0.988278 0.988523 0.988767][0.989011 0.989255 0.989499 0.989744 0.989988 0.990232 0.990476 0.99072 0.990965 0.991209][0.991453 0.991697 0.991941 0.992186 0.99243 0.992674 0.992918 0.993162 0.993407 0.993651][0.993895 0.994139 0.994383 0.994628 0.994872 0.995116 0.99536 0.995604 0.995849 0.996093][0.996337 0.996581 0.996825 0.99707 0.997314 0.997558 0.997802 0.998046 0.998291 0.998535] 过程步骤 总览 首先计算 p 与 E 中的 $C_{i}$ 比较分数并用 $r_{i}$表示,求最佳的 $r_{i}$, $\\mathbf{r}{i}=\\operatorname{dist}\\left(\\mathbf{p}, \\mathbf{c}{i}\\right) \\cdot \\mathbf{k} ; k={1,0, \\ldots 0}$​ 处理完全部数据库内容后,N个单独结果的 vector $\\mathbf{R}=\\left[\\begin{array}{c}\\mathbf{r}{1} \\ \\mathbf{r}{2} \\ \\vdots \\ \\mathbf{r}{N}\\end{array}\\right]=\\left[\\begin{array}{c}\\left(\\mathbf{r}{1,1}, 0, \\ldots 0\\right) \\ \\left(\\mathbf{r}{2,1}, 0, \\ldots 0\\right) \\ \\vdots \\ \\left(\\mathbf{r}{N, 1}, 0, \\ldots 0\\right)\\end{array}\\right]$​ 每个$r_{i}$​是单独加密的, 可以随机打乱$r_{i}$​的顺序 通过将$r_{i}$​移位,变成对角矩阵 例如 $\\mathbf{R}=\\left[\\begin{array}{c} \\left(\\mathbf{r}{1,1}, 0, \\ldots 0\\right) \\ \\left(0, \\mathbf{r}{2,1}, \\ldots 0\\right) \\ \\vdots \\ \\left(0,0, \\ldots \\mathbf{r}_{N, 1}\\right) \\end{array}\\right]$​ 将对角线上vector组合成新的带有与P比较分数的vector格式 i.e. $R-&gt;\\left(\\mathbf{r}{1,1}, \\mathbf{r}{2,1}, \\ldots \\mathbf{r}_{N, 1}\\right)$​ 将上式跟预先设定的阈值${t}=(t, t, \\ldots t)$进行比较 形成新的vector d: $d = R - t$, 然后将d 传输给第三方 最终将 d 进行解密决定结果(decision),并传送给客户 $d = R - t$​​ ; $d=R-t ; \\quad$​​ decision $= \\begin{cases}\\text { accept } &amp; \\text { if } \\exists d \\in \\mathbf{d}: d&gt;0 \\ \\text { reject } &amp; \\text { if } \\forall d \\in \\mathbf{d}: d \\leq 0\\end{cases}$ 一: 将input和database中的数据分别加密获得encrypt_probe_p和 encrypt_E_matrix 1：加密得到probe_p Ciphertext get_encrypt_probe(CKKSEncoder&amp; ckks_encoder,Encryptor &amp; encryptor, vector&lt;double>v_input) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_encrypt_probe() begin------\" &lt;&lt; endl; /* * 加密获得probe_p; */ Plaintext v_plaintext; // v编码 ckks_encoder.encode(v_input, scale, v_plaintext); Ciphertext probe_p; // 加密 encryptor.encrypt(v_plaintext, probe_p); print_line(__LINE__); cout &lt;&lt; \"------get_encrypt_probe() end------\" &lt;&lt; endl; return probe_p; &#125; 将加密的probe_p解密做验证: 2：将database中的所有数据分别加密，组成矩阵E: vector&lt;Ciphertext> get_encrypt_E_matrix(CKKSEncoder&amp; ckks_encoder, Encryptor&amp; encryptor, vector&lt;vector&lt;double>>E_matrix) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_encrypt_E_matrix() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_E_matrix; for (auto it = E_matrix.begin(); it != E_matrix.end(); it++) &#123; Plaintext plain_E_ci; Ciphertext encrypt_E_ci; ckks_encoder.encode(*it, scale, plain_E_ci); encryptor.encrypt(plain_E_ci, encrypt_E_ci); encrypt_E_matrix.push_back(encrypt_E_ci); &#125; print_line(__LINE__); cout &lt;&lt; \"------get_encrypt_E_matrix() end------\" &lt;&lt; endl; return encrypt_E_matrix; &#125; 将加密的databse数据做解密验证: 输出前4行: 二: 计算 $\\mathbf{r}{i}=\\operatorname{dist}\\left(\\mathbf{p}, \\mathbf{c}{i}\\right) \\cdot \\mathbf{k}$ 分步骤: 总代码调用: code vector&lt;Ciphertext> get_dist(SEALContext&amp; context,CKKSEncoder&amp; ckks_encoder, Evaluator&amp; evaluator, vector&lt;Ciphertext> encrypt_E_matrix, Ciphertext probe_p,Encryptor &amp; encryptor ,Decryptor&amp; decryptor, RelinKeys&amp; relin_keys, GaloisKeys&amp; galois_keys) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_dist() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_R_matrix; /* * get (Ci - Pi)^2 */ cout &lt;&lt; \"sub &amp; square &amp;&amp; stored in encrypt_R_matrix: \" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_R_matrix_cache = get_sub_square(ckks_encoder, evaluator, decryptor,encrypt_E_matrix,probe_p, relin_keys); /* * get sum */ encrypt_R_matrix = get_sum_rotate(context,ckks_encoder,evaluator,encryptor, decryptor, encrypt_R_matrix_cache,galois_keys,relin_keys); print_line(__LINE__); cout &lt;&lt; \"------get_dist() end------\" &lt;&lt; endl; return encrypt_R_matrix; &#125; 1：求 ${(C_{i} - P_{i})}^{2}$ code vector&lt;Ciphertext> get_sub_square(CKKSEncoder&amp; ckks_encoder,Evaluator &amp; evaluator,Decryptor &amp; decryptor,vector&lt;Ciphertext> encrypt_E_matrix, Ciphertext probe_p,RelinKeys &amp; relin_keys) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_sub_square() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_R_matrix; for (auto it = encrypt_E_matrix.begin(); it != encrypt_E_matrix.end(); it++) &#123; Plaintext plain_sub_cache, plain_mult_cache; Ciphertext encrypt_sub_cache, encrypt_multiply_cache; vector&lt;double>result_sub_cache, result_mult_cache; evaluator.sub(probe_p, (*it), encrypt_sub_cache); evaluator.relinearize_inplace(encrypt_sub_cache, relin_keys); evaluator.square(encrypt_sub_cache, encrypt_multiply_cache); evaluator.relinearize_inplace(encrypt_multiply_cache, relin_keys); evaluator.rescale_to_next_inplace(encrypt_multiply_cache); encrypt_R_matrix.push_back(encrypt_multiply_cache); &#125; print_line(__LINE__); cout &lt;&lt; \"------get_sub_square() end------\" &lt;&lt; endl; return encrypt_R_matrix; &#125; 解码结果验证测试： ​ 1. $(C_{i} - P_{i})$结果: ${(C_{i} - P_{i})}^{2}$结果: 2: $\\sum_{i=0}{s}\\left(\\mathbf{c}_{i}-\\mathbf{p}_{i}\\right){2}$ 循环遍历encrypt_R_matrix， 将密文每次移位step步后加到encrypt_sum_cache上得到最终的结果， step从0到number-1 code vector&lt;Ciphertext> get_sum_rotate(SEALContext &amp;context,CKKSEncoder&amp; ckks_encoder, Evaluator&amp; evaluator,Encryptor &amp;encryptor ,Decryptor&amp; decryptor, vector&lt;Ciphertext>encrypt_R_matrix,GaloisKeys &amp; galois_keys,RelinKeys &amp; relin_keys) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_sum_rotate() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_RR_matrix; /* * get encryptor of vector K&#123;1,0,0,....0&#125; * begin */ size_t slot_count = ckks_encoder.slot_count(); vector&lt;double>vector_k(slot_count, 0ULL); vector_k[0] = 1ULL; //print_vector(vector_k, 3, 13); Plaintext plain_vector_k; Ciphertext encrypt_vector_k; ckks_encoder.encode(vector_k, pow(2.0, 40), plain_vector_k); encryptor.encrypt(plain_vector_k, encrypt_vector_k); evaluator.mod_switch_to_next_inplace(encrypt_vector_k); //end /* * Calculate begin */ for (auto it = encrypt_R_matrix.begin(); it != encrypt_R_matrix.end(); it++) &#123; Plaintext plain_rotated_cache, plain_sum_cache; Ciphertext encrypt_rotated_cache, encrypt_sum_cache; vector&lt;double>result_rotated_cache, result_sum_cache; encrypt_sum_cache = (*it); /* * rotated &amp; add to get sum of them */ for (auto i = 0; i &lt; number_n - 1; i++) &#123; evaluator.rotate_vector(encrypt_sum_cache, 1, galois_keys, encrypt_rotated_cache); encrypt_sum_cache = encrypt_rotated_cache; evaluator.add_inplace(encrypt_sum_cache,(*it) ); evaluator.relinearize_inplace(encrypt_sum_cache, relin_keys); &#125; evaluator.multiply_inplace(encrypt_sum_cache, encrypt_vector_k); evaluator.relinearize_inplace(encrypt_sum_cache, relin_keys); evaluator.rescale_to_next_inplace(encrypt_sum_cache); encrypt_RR_matrix.push_back(encrypt_sum_cache); &#125; /* * Calculate end; */ print_line(__LINE__); cout &lt;&lt; \"------get_sum_rotate() end------\" &lt;&lt; endl; return encrypt_RR_matrix; &#125; 解码结果验证测试(部分截取): 3: 求 $\\operatorname{dist}\\left(\\mathbf{p}, \\mathbf{c}_{i}\\right) \\cdot \\mathbf{k}$ 代码内嵌在第二步求 2: $\\sum_{i=0}{s}\\left(\\mathbf{c}_{i}-\\mathbf{p}_{i}\\right){2}$​中 evaluator.multiply_inplace(encrypt_sum_cache, encrypt_vector_k); evaluator.rescale_to_next_inplace(encrypt_sum_cache); encrypt_RR_matrix.push_back(encrypt_sum_cache); 解码结果验证: 三: 将得到 R 进行移位叠加操作: code vector&lt;Ciphertext> get_shifting_ri(SEALContext&amp; context,CKKSEncoder&amp; ckks_encoder,Evaluator&amp; evaluator,vector&lt;Ciphertext> encrypt_R_matrix, GaloisKeys&amp; galois_keys, Decryptor&amp; decryptor) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_shifting_ri() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_RR_matrix; Plaintext plain_shift_cache; vector&lt;double>result_shift_cache; int step = 0; for (auto it = encrypt_R_matrix.begin(); it != encrypt_R_matrix.end(); it++) &#123; Ciphertext after_shift; // 右移 evaluator.rotate_vector((*it),step, galois_keys,after_shift); step--; encrypt_RR_matrix.push_back(after_shift); &#125; print_line(__LINE__); cout &lt;&lt; \"------get_shifting_ri() end------\" &lt;&lt; endl; return encrypt_RR_matrix; &#125; 解码结果验证测试； 输出前10列前10行， 保留13位小数 四: 将得到 $R-&gt;\\left(\\mathbf{r}{1,1}, \\mathbf{r}{2,1}, \\ldots \\mathbf{r}_{N, 1}\\right)$: 通过移位操作得到对角矩阵后，将所有的$C_{i}$​ 累加起来得到$R-&gt;\\left(\\mathbf{r}{1,1}, \\mathbf{r}{2,1}, \\ldots \\mathbf{r}_{N, 1}\\right)$: code Ciphertext get_combined_R(SEALContext&amp; context,CKKSEncoder&amp; ckks_encoder,Evaluator&amp; evaluator, vector&lt;Ciphertext> encrypt_R_matrix, Encryptor&amp; encryptor, Decryptor&amp; decryptor, RelinKeys&amp; relin_keys) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_combined_R() begin------\" &lt;&lt; endl; Ciphertext encrypt_R_sum_cache; cout &lt;&lt; \" combined together: \" &lt;&lt; endl; int step = 0; for (auto it = encrypt_R_matrix.begin(); it != encrypt_R_matrix.end(); it++) &#123; if (step == 0) &#123; encrypt_R_sum_cache = (*it); step++; continue; &#125; else &#123; parms_id_type last_parms_id = (*it).parms_id(); evaluator.add_inplace(encrypt_R_sum_cache, (*it)); evaluator.relinearize_inplace(encrypt_R_sum_cache,relin_keys); step++; &#125; &#125; print_line(__LINE__); cout &lt;&lt; \"------get_combined_R() end------\" &lt;&lt; endl; return encrypt_R_sum_cache; &#125; 解密结果测试: 最终结果展示 ==注意！== (因为没有用FaceNet缘故,这里给定的阈值 t 不得知，故程序只运行到将R做完对角化后并加在一起变成一个 $R-&gt;(r1,1, r2,1, . . . rN,1).$形式 若给定的设定的t已知; 则只需要做如下操作判定结果: code // d = R - t Ciphertext encrypt_T,encrypt_d; evaluator.sub(mapping_R,encrypt_T,encrypt_d); // *d = Dec(d) Plaintext plain_dd_cache; vector&lt;double>result_dd_cache; decryptor.decrypt(encrypt_d, plain_dd_cache); ckks_encoder.decode(plain_dd_cache, result_dd_cache); // judge ∃d ∈ d∗: d > 0 ? accept : reject bool ok = 0; auto len = result_dd_cache.size(); for (auto i = 0; i &lt; len; i++) &#123; if (result_dd_cache[i] > 0) &#123; ok = 1; break; &#125; &#125; string ans = ok ? \"accept\" : \"reject\"; cout &lt;&lt; ans &lt;&lt; endl; //输出最后结果","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"Mybatis  XXX.ReflectionException_ There Is No Getter for Name XXX问题","slug":"Mybatis-XXX-ReflectionException-There-is-no-getter-for-name-XXX问题","date":"2021-08-11T14:22:32.000Z","updated":"2021-09-19T10:13:17.000Z","comments":true,"path":"posts/12adf317/","link":"","permalink":"https://www.sizaif.com/posts/12adf317/","excerpt":"","text":"[TOC] @auther by sizaif 解决方法 首先,这个肯定是因为数据库表中的字段名,和实体类中的字段名映射失败引起的; 1: 查看 是否拼写错误 &lt;!--映射表--> &lt;resultMap id=\"UsersMap\" type=\"com.sizaif.emsdemo.pojo.User.Users\"> &lt;!--column数据库中的字段，property实体类中的属性--> &lt;result column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/> &lt;result column=\"createDate\" property=\"createDate\" jdbcType=\"VARCHAR\" /> &lt;result column=\"modifyDate\" property=\"modifyDate\" jdbcType=\"VARCHAR\" /> &lt;result column=\"isEnabled\" property=\"isEnabled\" jdbcType=\"INTEGER\"/> &lt;result column=\"isLocked\" property=\"isLocked\" jdbcType=\"INTEGER\"/> &lt;result column=\"lastLoginDate\" property=\"lastLoginDate\" jdbcType=\"VARCHAR\" /> &lt;result column=\"lastLoginIp\" property=\"lastLoginIp\" jdbcType=\"VARCHAR\" /> &lt;result column=\"lockDate\" property=\"lockDate\" jdbcType=\"VARCHAR\" /> &lt;result column=\"uname\" property=\"name\" jdbcType=\"VARCHAR\"/> &lt;result column=\"encodePassword\" property=\"password\" jdbcType=\"VARCHAR\"/> &lt;result column=\"role\" property=\"role\" jdbcType=\"VARCHAR\"/> &lt;/resultMap> 2: 查看 sql动态插入或更新语句中字段是否拼写错误与实体类中字段不符** &lt;if test=\"XXX实体类字段名 != null\"> XXX数据库字段名, &lt;/if>","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"}],"author":"sizaif"},{"title":"Layui Tree 获取复选框选中节点的Id","slug":"layui-tree-获取复选框选中节点的id","date":"2021-08-11T14:11:34.000Z","updated":"2021-09-19T10:13:44.000Z","comments":true,"path":"posts/b7de2574/","link":"","permalink":"https://www.sizaif.com/posts/b7de2574/","excerpt":"","text":"[TOC] @auther by sizaif 说明 官方文档提供的代码只能获取到根节点的id,没有进行树遍历,无法获取到子树的id. Code 官方文档提供的 tree.render(&#123; elem: '#test' ,data: [] //数据源 ,id: 'demoId' //定义索引 &#125;); //获得选中的节点 var checkData = tree.getChecked('demoId'); 我的代码 var treecheckdata = tree.getChecked('demoId'); var nodeIds = new Array(); nodeIds = getCheckedId(treecheckdata); // 测试 var permList = nodeIds; console.log(\"permList:\"+permList); // 获取选中节点的id function getCheckedId(jsonObj) &#123; var id = \"\"; $.each(jsonObj, function (index, item) &#123; if (id != \"\") &#123; id = id + \",\" + item.id; &#125; else &#123; id = item.id; &#125; var i = getCheckedId(item.children); if (i != \"\") &#123; id = id + \",\" + i; &#125; &#125;); return id; &#125; 效果图","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Js","slug":"技术向/Js","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Js/"}],"tags":[{"name":"Js","slug":"Js","permalink":"https://www.sizaif.com/tags/Js/"},{"name":"Layui","slug":"Layui","permalink":"https://www.sizaif.com/tags/Layui/"}],"author":"sizaif"},{"title":"Layui Table 解决从后台传入数据为二维数组模式,即带有子类的数据格式","slug":"layui-table-解决从后台传入数据为二维数组模式-即带有子类的数据格式","date":"2021-08-11T14:11:12.000Z","updated":"2021-09-19T10:13:50.000Z","comments":true,"path":"posts/2b51004/","link":"","permalink":"https://www.sizaif.com/posts/2b51004/","excerpt":"","text":"[TOC] @auther by sizaif 后台传入的格式 前台处理 code ,response:&#123; statusName: 'code' //数据状态的字段名称，默认：code ,statusCode: 200 //成功的状态码，默认：0 ,countName: 'totals' //数据总数的字段名称，默认：count ,dataName: 'list' //数据列表的字段名称，默认：data &#125; ,parseData: function(res)&#123; //res 即为原始返回的数据 console.log(res); return &#123; \"code\":res.code, //解析接口状态 \"msg\": res.message, //解析提示文本 \"totals\": res.totals, //解析数据长度 \"list\": res.list //解析数据列表 &#125;; &#125; ,cols: [[ //表头 &#123;field: 'users', title: '上次登录IP',sort: true,templet:function(d)&#123;return d.users.lastLoginIp&#125; &#125; ,&#123;field: 'users', title: '角色',sort: true,templet:function(d)&#123;return d.users.role&#125;&#125; ]] 效果","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Js","slug":"技术向/Js","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Js/"}],"tags":[{"name":"Js","slug":"Js","permalink":"https://www.sizaif.com/tags/Js/"},{"name":"Layui","slug":"Layui","permalink":"https://www.sizaif.com/tags/Layui/"}],"author":"sizaif"},{"title":"Mybatis 单表自关联 实现树结构的几种方式","slug":"Mybatis-单表自关联-实现树结构的几种方式","date":"2021-08-11T14:10:32.000Z","updated":"2021-09-19T10:13:24.000Z","comments":true,"path":"posts/843fdcdc/","link":"","permalink":"https://www.sizaif.com/posts/843fdcdc/","excerpt":"","text":"@auther by sizaif @TOC 结构 Bean code @JsonIdentityInfo( generator = ObjectIdGenerators.IntSequenceGenerator.class) public class PermissionVO implements Serializable&#123; private static final long serialVersionUID = -2783081162690878303L; private Integer id; private String name; private Integer pid; private Integer istype; private String code; private String page; private boolean checked; private boolean open; private List&lt;PermissionVO> children; 法一:使用mybatis映射实现 mabatis.xml配置 code &lt;!--=Start findPerms 查找权限树列表 结果集映射--> &lt;resultMap id=\"findPermissionMap\" type=\"com.sizaif.emsdemo.dto.PermissionVO\"> &lt;id property=\"id\" column=\"id\"/> &lt;result property=\"name\" column=\"name\"/> &lt;result property=\"pid\" column=\"pid\"/> &lt;result property=\"istype\" column=\"istype\"/> &lt;result property=\"code\" column=\"code\"/> &lt;result property=\"page\" column=\"page\"/> &lt;collection property=\"children\" column=\"id\" ofType=\"com.sizaif.emsdemo.dto.PermissionVO\" select=\"findChildPerm\"/> &lt;/resultMap> &lt;!--=End findPerms 查找权限树列表--> &lt;!-- pID 对应 PermissionVO 中 pID--> &lt;sql id=\"PermColumn\" > id, name,pid,istype, code,page &lt;/sql> &lt;!--=Start findPerms 查找权限树列表--> &lt;select id=\"findPerms\" resultMap=\"findPermissionMap\"> SELECT &lt;include refid=\"PermColumn\" /> FROM permission WHERE pid = 0 OR pid is NULL &lt;/select> &lt;!--=End findPerms 查找权限树列表--> &lt;!--=Start findChildPerm 查找所有子节点权限--> &lt;select id=\"findChildPerm\" resultMap=\"findPermissionMap\"> select &lt;include refid=\"PermColumn\" /> from permission where pid = #&#123;pid&#125; &lt;/select> &lt;!--=End findChildPerm 查找所有子节点权限--> service层调用 @Override public List&lt;PermissionVO> findPerms() &#123; return permissionsMapper.findPerms(); &#125; controller List&lt;PermissionVO> pvos = authService.findPerms(); 法二:通过递归实现 mybatis.xml配置 code &lt;resultMap id=\"BaseResultMap\" type=\"com.sizaif.emsdemo.dto.PermissionVO\"> &lt;id property=\"id\" column=\"id\"/> &lt;result property=\"name\" column=\"name\"/> &lt;result property=\"pid\" column=\"pid\"/> &lt;result property=\"istype\" column=\"istype\"/> &lt;result property=\"code\" column=\"code\"/> &lt;result property=\"page\" column=\"page\"/> &lt;/resultMap> &lt;select id=\"getChildren\" resultMap=\"BaseResultMap\"> select id, pid, name, istype, code,page from permission where pid = #&#123;id&#125; &lt;/select> service @Override public List&lt;PermissionVO> getChildPerms(Integer id) &#123; return permissionsMapper.getChildren(id); &#125; controller code public PermissionVO initPermission1()&#123; PermissionVO permissionvo=new PermissionVO (); try&#123; permissionvo.setId(0);//这个地方应该通过数据库查询出根节点，因为根节点id在数据库是0， queryChildPermissions(permissionvo);//递归得到全部节点 &#125;catch (Exception e)&#123; throw e; &#125; return permissionvo; &#125; private void queryChildPermissions (PermissionVO permissionvo)&#123; List&lt;PermissionVO> children= authService.getChildPerms(permissionvo.getId());//通过id查询子集合 permissionvo.setChildren(children);//将查询出来的子节点集合放入到permissionvo集合中 for(PermissionVO innerChildren:children)&#123; //遍历出子集合的子集合 queryChildPermissions(innerChildren); //放入到子节点的子集合中 &#125; &#125; 法三: 一次查出全部记录，通过嵌套循环遍历结果 xml code &lt;resultMap id=\"BaseResultMap\" type=\"com.sizaif.emsdemo.dto.PermissionVO\"> &lt;id property=\"id\" column=\"id\"/> &lt;result property=\"name\" column=\"name\"/> &lt;result property=\"pid\" column=\"pid\"/> &lt;result property=\"istype\" column=\"istype\"/> &lt;result property=\"code\" column=\"code\"/> &lt;result property=\"page\" column=\"page\"/> &lt;/resultMap> &lt;select id=\"selectAll\" resultMap=\"BaseResultMap\"> select id, pid, name, istype,code,page from permission &lt;/select> service: @Override public List&lt;PermissionVO> selectAll() &#123; return permissionsMapper.selectAll(); &#125; controller: code public PermissionVO initPermissionVO()&#123; PermissionVO permissionvo = new PermissionVO (); List&lt;PermissionVO> lists= authService.selectAll();//查询所有节点 try&#123; for(PermissionVO ps:lists)&#123;//遍历节点 PermissionVO child = ps; if( ps.getPid().equals(0) || ps.getPid() == null)&#123;//获取根节点,Integer类型是包装类，判断对象引用 permissionvo = ps;//根节点 &#125;else&#123; for (PermissionVO innerpermissionvo:lists)&#123; if(child.getPid() == innerpermissionvo.getId())&#123;//如果节点的的pid和集合中某个节点的id一致 PermissionVO parent=innerpermissionvo;//将这个节点命名为父节点 parent.getChildren().add(child);//然后把child放入到它的父亲集合中 break; &#125; &#125; &#125; &#125; &#125;catch (Exception e)&#123; throw e; &#125; return permissionvo; &#125; 法四:一次查出所有数据,通过Map集合实现树结构 xml 与service 与法三一致, controller: code public PermissionVO initPermission()&#123; PermissionVO permissionvo=new PermissionVO (); List&lt;PermissionVO> lists = authService.selectAll();//查询所有节点 Map&lt;Integer,PermissionVO> map = new HashMap&lt;Integer,PermissionVO>();//将所有节点存入到map集合 try&#123; for(PermissionVO ps:lists) &#123; map.put(ps.getId(),ps);//将所有id做为key，Permissionvo对象做值，存入到map集合 &#125; for(PermissionVO ps:lists)&#123;//遍历所有节点 PermissionVO child = ps; if (child.getPid().equals(0)||child.getPid()==null)&#123; permissionvo = ps;//取出根节点 &#125;else&#123; PermissionVO parent = map.get(child.getPid());//通过子节点的pid获取父节点 parent.getChildren().add(child);//将子节点放入父节点中 &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return permissionvo; &#125; 四种方式查出来的结果是一样的,但效率方面法四最快","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"}],"author":"sizaif"},{"title":"linux安装java1.8 Jdk并配置环境变量","slug":"linux安装java1-8-jdk并配置环境变量","date":"2021-08-11T14:06:40.000Z","updated":"2021-09-19T10:13:35.000Z","comments":true,"path":"posts/f03f62f2/","link":"","permalink":"https://www.sizaif.com/posts/f03f62f2/","excerpt":"","text":"@auther by sizaif @TOC 下载jdk 百度网盘链接:提取码: krfa 使用fileZilla将jdk传输到linux上 安装 rpm -ivh jdk-8u251-linux-x64.rpm 配置环境变量 vim /etc/profile export JAVA_HOME=/usr/java/jdk1.8.0_251-amd64 export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 更新环境变量 source /etc/profile 验证: java -version","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"},{"name":"Linux","slug":"技术向/Linux","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Jdk","slug":"Jdk","permalink":"https://www.sizaif.com/tags/Jdk/"},{"name":"Linux","slug":"Linux","permalink":"https://www.sizaif.com/tags/Linux/"}],"author":"sizaif"},{"title":"使用Docker部署SpringBoot项目全流程记录,超详细!","slug":"使用Docker部署SpringBoot项目全流程记录-超详细","date":"2021-08-11T14:05:33.000Z","updated":"2021-09-19T10:14:19.000Z","comments":true,"path":"posts/dfba8e73/","link":"","permalink":"https://www.sizaif.com/posts/dfba8e73/","excerpt":"","text":"@auther by sizaif @TOC 引言 我的linux环境为: centos:7 服务器在国外,所以有一些操作像阿里云的端口安全组设置就不需要操作 需要的软件 xshell(用来连接linux服务器) xftp或fileZilla用来给linux服务器上传文件 sqlyog(或者navicat)在服务器上解析.sql脚本 maven(idea自带) 用来打包 安装Docker 官网对系统的要求 OS requirements To install Docker Engine, you need a maintained version of CentOS 7. Archived versions aren’t supported or tested. The centos-extras repository must be enabled. This repository is enabled by default, but if you have disabled it, you need to re-enable it. The overlay2 storage driver is recommended. 要求版本Centos7, 其版本不支持或未测试 经过我测试,的确在安装时会遇到依赖的错误所以干脆将Centos6 换成Centos7 安装和设置仓库 官方教程 sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 这个仓库是官方的,如果太慢的换,换成阿里云镜像: 需要配置文件 可以自行百度 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装最新版的docker sudo yum install docker-ce docker-ce-cli containerd.io 若要安装特定版本 $ yum list docker-ce --showduplicates | sort -r docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stable docker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stable docker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stable docker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 例如要按照 docker-ce.x86_64 18.06.1.ce-3.el7 &lt;VERSION_STRING&gt; docker-ce-18.06.1 sudo yum install docker-ce-&lt;VERSION_STRING> docker-ce-cli-&lt;VERSION_STRING> containerd.io 开启docker sudo systemctl start docker 跑一个docker版的helloworld，类似于java的hello，测试是否安装成功 sudo docker run hello-world 安装mysql 从docker hub上查找mysql镜像 docker search mysql 从docker hub上拉取mysql,我拉取的mysql版本是mysql5.7 docker pull mysql:5.7 docker volume create mysql_data 创建数据挂载点（即存储数据的地方，这样即便mysql容器删除了，数据还是在） docker volume create mysql_data 运行mysql，开放的端口是3306，密码是root， -d是后台运行 docker run --name mysql -p 3306:3306 -v mysql_data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 docker ps 查看容器创建成功 进入mysql 的容器内 docker exec -it 容器的id /bin/bash 进入mysql, 当可以进入时,说明mysql 没问题了, 通过docker restart 镜像名 可以重启镜像 docker restart mysql 使用navicat 远程连接数据库 运行本地的.sql 文件, 将远程数据库中增加数据 将springboot项目打成jar包 注意将applicayion.yml中密码改成你服务器上mysql的密码 打包后在target下会生成一个jar包 编写Dockfile文件 在 /home 目录下创建docker文件夹 mkdir /home/docker 使用xftp上传jar包 编写Dockerfile文件 vim Dockerfile 完整命令, vim的使用方法：点击i开始编写，编写完后点击esc，点击冒号，输入wq保存 FROM java:8ADD emsdemo-0.0.2-SNAPSHOT.jar /emsdemo.jarEXPOSE 8081ENTRYPOINT [\"java\",\"-jar\",\"/emsdemo.jar\"] #注意，docker命令全部大写，这是规定。 # From 关键字表示，jar包依赖的环境。java:8 相当于jdk1.8 FROM java:8 #ADD命令 # emsdemo-0.0.2-SNAPSHOT.jar：这是你上传jar包的名称。 # /emsdemo.jar：这是自定义的名称。但是注意要有之前的/ ADD emsdemo-0.0.2-SNAPSHOT.jar /emsdemo.jar #MAINTAINER 作者名称。可以删除不写。 MAINTAINER Sizaif #EXPOSE 项目暴露的端口号 EXPOSE 8080 #/blog.jar此处的名称要和ADD命令后面的一样。 ENTRYPOINT [\"java\",\"-jar\",\"/emsdemo.jar\"] 在docker文件夹下执行如下命令 docker build -t emsdemo:1.0 . 运行镜像 docker run -it --net=host --name emsdemo -d -p 80:8081 emsdemo:1.0 至此全部完成. 在浏览器访问就可以了","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Springboot","slug":"技术向/Springboot","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Springboot/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.sizaif.com/tags/Springboot/"}],"author":"sizaif"},{"title":"在windows上安装Microsoft SEAL","slug":"在windows上安装Microsoft-SEAL","date":"2021-08-11T14:04:10.000Z","updated":"2021-09-19T10:13:59.000Z","comments":true,"path":"posts/6b27b8ff/","link":"","permalink":"https://www.sizaif.com/posts/6b27b8ff/","excerpt":"","text":"@auther by sizaif 在windows上安装Microsoft SEAL Note！说明 安装的版本为3.6 需要环境 Visual Studio 2019 with C++ CMake Tools for Windows 1. git 项目文件 git clone https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;SEAL.git 2. 以管理员打开VS2019打开SEAL文件夹 打开后，VS会自动运行cmake配置 Visual Studio will detect that this is a CMake-based project and will enable the menu command Project / CMake settings for SEAL. This will open the CMake settings editor that provides a user interface where you can create different configurations and set different CMake options. 3. VS里打开终端powershell 因为VS2019是以管理员打开的，所以打开的终端也是带有管理员权限的 4. 在终端中依次输入 cmake -S . -B build cmake --build build cmake --install build 或者采用 #Generate and build for x64 in Release mode cmake -S . -B build -G &quot;Visual Studio 16 2019&quot; -A x64 cmake --build build --config Release cmake --install build 如果成功，则默认安装的C:/Program Files(x86)/SEAL/目录下 或者直接打开 x64 Native Tools 进入到你的从github上下载的SEAL文件夹位置 依次输入以下命令 cmake -S . -B build -G Ninja cmake --build build cmake --install build 如果不出问题出现下面图片,则安装完成","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"},{"name":"Win","slug":"Win","permalink":"https://www.sizaif.com/tags/Win/"}],"author":"sizaif"},{"title":"线性表(链表)题目算法题目整理(附代码)","slug":"线性表-链表-题目算法题目整理-附代码","date":"2021-08-11T14:01:59.000Z","updated":"2021-09-19T10:14:15.000Z","comments":true,"path":"posts/41ebddd6/","link":"","permalink":"https://www.sizaif.com/posts/41ebddd6/","excerpt":"","text":"@auther by sizaif 说明： 部分题目为王道题目整理，(ps.王道上思路没问题，在实现代码上略有些问题) 因个人代码风格与王道略有不同，部分细节代码也不尽相同 个人整理by sizaif @TOC 链表： //单链表结构 typedef struct link&#123; int data; link *next; &#125;node,*linklist; 1) 输入一组整型元素序列，使用尾插法(头插法)建立一个带有头结点(不带头结点)的单链表。 code /** * 建立带头结点的单链表 * @param L [description] */ void Creat_list_Head(linklist &amp;L) &#123; L = new node(); linklist p,s=L; L->next=NULL; int x; /*while(cin>>x,x>0)// 头插 &#123; p= new node(); p->data =x; p->next=L->next; L->next=p; &#125;*/ while(cin>>x,x>0)//尾插 &#123; p=new node(); p->data=x; s->next=p; s=p; &#125; &#125; void Creat_list_withoutHead(linklist &amp;L)&#123; L = NULL; linklist p,s; int x; /* while(cin>>x,x>0)// 头插 &#123; p= new node(); p->data =x; p->next=L; L=p; &#125; */ while(cin>>x,x>0)&#123; // 尾插 p = new node(); p->data = x; p->next = NULL; if(L==NULL) L = p; // 第一个结点 else&#123; s = L; while(s->next)&#123; // 遍历到最后一个结点 s = s->next; &#125; s->next = p; &#125; &#125; &#125; 2) 在该单链表的第i个元素前插入一个整数。(从0开始) code ++/** * 在 单链表 第x个位置 前插入y * @param L [description] * @param x [description] * @param y [description] * @return [description] */ void Add_before_X(linklist &amp;L,int x,int y) &#123; linklist p,s; p=L->next; int j=0; while(p&amp;&amp;j&lt;x-1) &#123; p=p->next;j++; &#125; if(!p||j>x-1)&#123;cout&lt;&lt;\"error\"&lt;&lt;endl;return;&#125; s=new node(); s->data=y; s->next=p->next; p->next=s; &#125; 3) 删除该单链表中的第i个元素，其值通过参数将其返回(从0开始)。 code ++/** * 删除单链表中第i个元素 的结点 * @param L [description] * @param i [description] */ void Delet_x(linklist &amp;L,int &amp;i) &#123; linklist s,p; p=L->next; int j=0; while(p&amp;&amp;j&lt;i-1) &#123; p=p->next; j++; &#125; i = p->data; s = p->next; p->next=s->next; &#125; 4) 建立两个按值递增有序的带头结点的单链表，将他们合并成一个按值递减有序的单链表。 code ++/** * 思路： 归并， 头插法 */ linklist Union(linklist la,linklist lb)&#123; linklist p,q,r,rear,t; p = la->next,q = lb->next; la->next = NULL; r = la; // r重构la while( p &amp;&amp; q)&#123; if( p->data &lt; q->data)&#123; rear = p->next; p->next = r->next; r->next = p; p = rear; &#125;else if( p->data > q->data)&#123; rear = q->next; q->next = r->next; r->next = q; q = rear; &#125; else &#123; // 当两个值相同时,(按题目要求两个都保留, 另外一个free掉) rear = q->next; t = p ->next; p->next = r->next; r->next = p; q->next = r->next; r->next = q; // free(q); q = rear; p = t; &#125; &#125; while(p)&#123; // 因为是倒叙, 所以必须 逐步遍历头插剩余部分 rear = p->next; p->next = r->next; r->next = p; p = rear; &#125; while(q)&#123; rear = q->next; q->next = r->next; r->next = q; q = rear; &#125; return la; &#125; plus-两个单调递增有序的单链表A B 合并成一个单调递增有序的单链表C code ++/** * 两个单调递增有序的单链表A B 合并成一个单调递增有序的单链表C * @param L [description] * @param B [description] */ void Merage_A_B(linklist &amp;A,linklist &amp;B,linklist &amp;C) &#123; linklist pa,pb,pc; pa = A->next; pb = B->next; pc = new node(); pc ->next =NULL; while(pa&amp;&amp;pb) &#123; if(pa->data &lt;= pb->data)&#123; pc->next = pa; pc = pa; pa = pa->next; &#125;else&#123; pc ->next = pb; pc = pb; pb = pb->next; &#125; &#125; // 尾插 pc ->next = pa? pa:pb; &#125; 5) 试编写算法将带头结点的单链表就地逆置，所谓“就地”是指辅助空间复杂度为O(1)。 (计.期末.10.1) 头插重新建表 指针反转 顺序存储 数组 code ++//法一：头插法从新建表 void reverse(linklist &amp;L)&#123; linklist p,rear; // rear 为p的后继 防止断链 p = L->next; L->next = NULL; // 头结点的Next 置为null while(p)&#123; rear = p->next; // 头插法 p->next = L->next; L->next = p; p = rear; &#125; &#125; //法二：指针反转 void reverse(linklist &amp;L)&#123; LinkList temp,p,q; temp = NULL; p = L->next; q = L->next->next; while(q!=NULL)&#123; temp = q->next; // 暂存q-Next q->next = p; // 指针逆置 p = q; // 往后移 q = temp; &#125; L->next->next=NULL; // 第一个结点变成最后一个结点 L->next = p; // 最后一个结点变成第一个结点 &#125; //法三： 顺序存储 数组 void reverse(int A[],int n)&#123; for(int i = 0 ; i &lt; n/2 ; i++)&#123; temp = A[i]; A[i] = A[n-i-1]; A[n-i-1] = temp; &#125; &#125; 6) 将一个头指针为head且不带头节点的单链表改造为一个含头节点且头指针为head的单循环链表 (计.期末.09.1) code ++//没有单循环-> head->next = head; 改造为带头结点的 void fun(LinkList &amp;head)&#123; LinkList p; p = new LinkNode(); if(head == NULL)&#123; head = p; p->next = p; // 单循环 &#125;else&#123; p->next = head; // 创造头结点 // 单循环列表 Linklist t = head; while(t->next != NULL)&#123; t = t->next; &#125; t->next = p; // 最后一个结点指向头结点 head = p; // 将p 赋给 head 变成head链表 &#125; &#125; 7) 假设有两个按元素值递增次序排列的线性表，均不带头结点以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值递减(非递减)次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表 (计.期末.08.2) !!! code ++linklist merge_without_Head(linklist la,linklist lb)&#123; linklist lc = NULL,lce = NULL; while(la &amp;&amp; lb) &#123; if( la->data &lt;= lb->data)&#123; if(!lc) lc = la; else &#123; lce->next = la; &#125; lce = la; la = la->next; &#125;else&#123; if(!lc) lc = lb; else &#123; lce->next = lb; &#125; lce = lb; lb = lb->next; &#125; &#125; if(lc)&#123; if(la) lce ->next = la; else lce ->next = lb; &#125;else &#123; if(la ) lc = la; else lc = lb; &#125; return lc; &#125; 8) 给定一个带表头结点的单链表A分解为两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变 code ++void div(linklist &amp;A,linklist &amp;B)&#123; linklist p,pc,pb,temp,Lc; p = A->next; Lc = new node(); Lc->next = NULL; pc = Lc; pb = B; int i = 1; while(p)&#123; temp = p->next; // 保存后继防止断链 if(i%2==1)&#123; //尾插 p->next = pc->next; pc->next = p; pc = p; &#125;else &#123; //尾插 p->next = pb->next; pb->next = p; pb = p; &#125; p = temp; i++; &#125; A = LC; &#125; 9) 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点(统计值等于x的数目) int CountX(Lnode * HL, ElemType x) code ++void del(LinkList &amp;L,ElemType x)&#123; LinkList temp; // 做释放用 if(L==NULL) return; // 结束条件 if(L->data == x)&#123; temp = L; L = L ->next; free(t); del(L,x); &#125;else&#123; del(L->next,x); &#125; &#125; // 递归统计 int ct = 0; void count(LinkList &amp;L,ElemType x)&#123; if(L == NULL) return; if(L->data == x) ct++; count(L->next,x); &#125; 10) 在带头结点的单链表L中，删除所有值为x的结点，并释放空间，假设值为x的结点不唯一，试编写算法以实现上述操作。 code ++void del_x(linklist &amp;L,int x)&#123; linklist p,temp,pre; p = L->next,pre = L; // pre 防止断链 while(p)&#123; if(p->data == x)&#123; temp = p; p = p->next; pre ->next = p; free(temp); &#125;else&#123; // 同时后移 pre = p; p = p->next; &#125; &#125; &#125; 11) 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值(头插法建表，遍历) code ++//法一： 一边遍历一边头插法建立新表 linklist create_head(linklist &amp;L)&#123; liklist newL,p,q; newL = new node(); newL->next = NULL; p = L->next; while(p)&#123; q = new node(); q->data = p->data; q->next = newL->next; newL->next = q; &#125; return newL; &#125; void Visit(linklist L) &#123; linklist p; p=L->next; while(p) &#123; printf(\"%d \",p->data); p=p->next; &#125; cout&lt;&lt;endl; &#125; 法二： // 采用递归输出 栈的思想 void R_p(linklist L)&#123; if(L->next != NULL)&#123; R_p(L->next); &#125; cout&lt;&lt;L->data&lt;&lt;\" \"; &#125; 12) 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小值结点时唯一的） code ++void delete_MinX(linklist &amp;L)&#123; linklist pre,p,minp,minpre; pre = L; p = L->next;// pre 指向前驱 minp = p,minpre = pre; while(p)&#123; // 遍历寻找最小值 if(p->data &lt;= minp->data)&#123; minp = p; minpre = pre; &#125; pre = p; p = p ->next; &#125; // 删除minp 结点 minpre->next = minp->next; free(minp); &#125; 13) 有一个带头结点的单链表L，设计一个算法使其元素递增有序 code ++// 空间换时间O(n^2) 考的概率不大 void sort(linklist &amp;L)&#123; linklist p,pre,rear; p = L->next; rear = p->next; // rear 保留p后面的链表保证不断链 p->next = NULL; // 让 L 只有一个结点， 重构 L p = rear; // 遍历剩下的内容链表 while(p)&#123; rear = p->next; pre = L; while(pre->next!= NULL &amp;&amp; pre->next->data &lt; p->data)&#123; // 在新L中找到p->data应该的位置 pre = pre->next; &#125; p->next = pre->next; // 尾插法 把 p 插入到新L 中 pre -> next = p;// 尾插法 把 p 插入到 新L 中 p = rear; // 继续遍历 旧L 剩下的内容 &#125; &#125; 14) 设在一个带表结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值（作为函数参数给出）之间的元素的元素（若存在） 数字之间，字母之间等问题 code ++void delete_between(linklist &amp;L,ElemType x,ElemType y)&#123; linklist p,pre,temp; p = L->next; pre = L; while(p)&#123; if(p->data >= x &amp;&amp; p->data &lt;= y)&#123; // 如果介于之间 // 删除 pre->next = p->next; free(p); p = pre->next; &#125;else&#123; // 否则继续遍历 pre = p; p = p->next; &#125; &#125; &#125; ## 15) **给定两个单链表，编写算法找出两个链表的公共结点。** 掌握解题思想，先走k步，然后一同走， code ++// 公共结点指， 两个链表从某一结点开始， next都指向同一个节点 Y型 // 长的先走k步,然后一同走,第一个相同的结点即为公共结点初始点 linklist Common(linklist A,linklist B)&#123; linklist pa,pb; int lena = 0 ,lenb = 0,k; pa = A->next; pb = B->next; // 求lena lenb while(pa)&#123; lena++;pa=pa->next; &#125; while(pb)&#123; lenb++;pb=pb->next; &#125; // 长链赋给 pa 断链 赋给 pb if(lena>lenb) &#123; k = lena-lenb; pa = A->next; pb = B->next; &#125;else&#123; k = lenb-lena; pa = B->next; pb = A->next; &#125; // 先走k步 while(k--) pa = pa->next; // 同时走，第一个相同的结点即为公共链的起点 while(pa)&#123; if( pa->data == pb->data)&#123; return pa; &#125;else &#123; pa = pa->next; pb = pb->next; &#125; &#125; return NULL; &#125; 16) 给定一个带表头结点的单链表，设head为头指针，结点的结构为（data，next），data为整形元素，next为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间 (注意)：不允许使用数组作为辅助空间） code ++// 每次寻找最小的结点输出 O(n^2) // pre记录的是最小值的前驱，pre->next 既为最小值结点 // p 相等于记录的是最小值结点 // 每次比较的是 p->next->data 与 pre->next->data； 即 最小值后一个结点与最小值结点 void fun(linklist &amp;Head)&#123; while(Head->next!=NULL)&#123; linklist pre,p,temp; pre = Head;p = pre->next; // 寻找最小值结点 while(p->next!=NULL)&#123; // pre->next为最小值结点， p->next为最小值结点后继一个结点 if(p->next->data &lt; pre->next->data )&#123; pre = p; //updata &#125; p = p->next; &#125; cout&lt;&lt;pre->next->data&lt;&lt;endl;//输出最小结点值 // 释放空间，free，并保证不断链 p = pre->next; // pre->next = p->next;//保正不断链 free(p); &#125; free(Head); &#125; 17) 设C={a1,b1,a2,b2…,an,bn}为线性表，采用带头结点的hc单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A={a1,a2,…,an} B={bn,…,b2,b1} code ++// 思想： A存放的是奇数位置，尾插法 ； B存放的是偶数位置，头插法 void fun2(linklist &amp;L)&#123; linklist la,lb,pl,pa,pb,temp; la = new node();lb = new node(); la->next = NULL,lb->next = NULL; pa = la;pb = lb; pl = L->next; int i = 0; while(pl)&#123; i++; temp = pl->next; // 保存后继结点，防止断链 if(i%2==1)&#123; // A采用尾插法 pl->next = NULL; // 很重要,保证尾必为null pa->next = pl; pa = pl; &#125;else&#123; // B采用头插法 pl->next = pb->next; pb->next = pl; &#125; pl = temp; &#125; Visit(la); Visit(lb); &#125; 18) 在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素。例如（7,10,10,21,30,42,42,42,51,70）将变作（7,10,21,30,42,51,70） code ++// 递增有序， 相同的挨着， 一个pre 一个 p 比较p->next是否和pre->next 相同 // 相同删除 p结点 O(N) void delete_same(linklist &amp;L)&#123; linklist pre,p,temp; pre = L;p = pre->next; while(p->next!=NULL)&#123; temp = p->next; // 防止断链 if(p->next->data == pre->next->data)&#123; pre->next = p->next; free(p); &#125;else&#123; pre = p; &#125; p = temp; &#125; &#125; 19) 设A和B是两个单链表（带头结点），其中元素递增有序，设计一个算法从A和B中公共元素产生单链表C，要求不破坏A B 的结点 code ++//有序 C中元素即是A的也是B的 尾插建链表即可 void fun3(linklist &amp;A,linklist &amp;B)&#123; linklist C,pa,pb,pc,temp; C = new node(); C->next = NULL; pc = C; pa = A->next,pb = B->next; while(pa &amp;&amp; pb)&#123; // 小折后移 if( pa->data &lt; pb->data)&#123; pa = pa->next; &#125;else if( pa->data > pb->data)&#123; pb = pb->next; &#125;else &#123; // 相同值 temp = new node(); temp->data = pa->data; pc->next = temp; /* 如果这样写就会出现图2的情况 pc->next = pa; pc = pa; */ pc = temp; // 同时后移 pa = pa->next; pb = pb->next; &#125; &#125; Visit(C); &#125; 20) 已知两个链表A和B分别表示两个集合，其元素递增排列。绘制函数，求A与B的交集，并存放于A链表中。 code ++// 有序， 相同存入，AB同时后移， 不同，小者后移 void fun4(linklist &amp;A,linklist &amp;B)&#123; linklist pa,pb,pre,temp; pa = A->next;pb = B->next; pre = A; // pre 指向A 重构A链表 while(pa&amp;&amp;pb)&#123; // 小者后移 if( pa->data &lt; pb->data)&#123; pa = pa ->next; &#125;else if(pa->data > pb->data)&#123; pb = pb->next; &#125;else&#123; // 相等时存入， temp = new node(); temp->data = pa->data; pre->next = temp; pre = temp; pa = pa->next; pb = pb->next; &#125; &#125; &#125; 21) 头指针分别为la,lb的带头结点的单链表中，结点按元素递增有序排列，将la和lb两个链表合并成按元素递增有序的单链表，要求不另外开辟空间，la作为合并后的单链表的头结点(951.Y19) code ++// 归并 原理与上题一致 linklist Union(linklist la,linklist lb)&#123; linklist p,q,r,s; p = la->next,q = lb->next; r = la; // r重构la while( p &amp;&amp; q)&#123; if( p->data &lt; q->data)&#123; r->next = p; r = p; p = p->next; &#125;else if( p->data > q->data)&#123; r->next = q; r = q; q = q->next; &#125; else &#123; r->next = p; r = p; p = p->next; s = q->next; free(q); q = s; &#125; if(p) r->next = p; else if(q) r->next = q; &#125; return la; &#125; 22) 两个整数序列A=a1,a2,a3,…,am和B=b1,b2,b3,…,bn已经存入两个单链表中，设计一个算法，判断序列B是否是序列A的连续子序列 code ++/* * 模式匹配 链表实现 一般算法 O(n^2) * 带头结点, 当相同时，同时后移，， 当不相同时，B从头开始，A后移一个 * 判断条件： 如果B跑完说明匹配完成，否则不存在 */ int Pattern(linklist A,linklist B)&#123; linklist pa,pb,pre; pa = A->next,pb = B->next; pre = A->next; while(pa&amp;&amp;pb)&#123; // 相同，同时后移 if(pa->data == pb->data)&#123; pa = pa->next; pb = pb->next; &#125;else&#123; // 不相同 A后移 pre = pre->next; pa = pre; // A后移一个结点后从新匹配， pb = B->next; // B从头开始 &#125; &#125; return pb == NULL? 1:0; // 如果pb 跑完说明匹配完成存在 &#125; 23) 设计一个算法用于判断带头结点的循环双链表是否对称 code ++/* * 对称指 设各元素值 a1,a2,...,an, 则有 ai=an-i+1 ， * 即指： a1= an ， a2= an-1 。。。。。。。 * p 从头， q 从尾 当两个相同时，p后移，q前移，一旦不同则break， * 结束条件 p==q |｜p->next = q; */ int flag1(linklist L)&#123; linklist p,q; p = L->next; p = L->prior; int flag = 1; // 初始默认对称 while(p!=q &amp;&amp; p->next != q )&#123; if( p->data == q->data)&#123; p = p->next; q = q->prior; &#125;else &#123; flag = 0; break; &#125; &#125; return flag; &#125; 24) 有两个循环单链表，链表头指针分别为h1和h2，编写一个函数将链表h2链接到链表h1之后，要求链接后的链表仍保持循环链表形式。 code ++/** * */ void fun5(linklist &amp;h1,linklist &amp;h2)&#123; linklist p,q; p = h1,q = h2; while(p->next != h1)&#123; p = p->next; &#125; while(q->next != h2)&#123; q = q->next; &#125; p->next = h2; q->next = h1; &#125; 25) 设有一个带头结点的循环单链表，其结点值均为正整数。设计一个算法，反复找出单链表中结点值最小的结点并输出，然后将该结点从中删除，直到单链表为空位置，再删除表头结点 code ++/** * 同第16方法一致，这里为循环电单链表，判空条件需改变 */ void Del_all(linklist &amp;L)&#123; linklist p,pre,minp,minpre; // 没循环一次L减少一个结点，当L->next为L时，说明全部删完 while(L->next! = L)&#123; p = L->next;pre = L; minp = p, minpre = pre; // 找到最小结点 while(p->next != L)&#123; // 循环单链表 // 找到最小结点 if( p->data &lt; minp->data)&#123; minp = p; minpre = pre; &#125;else&#123; pre = p; p = p->next; &#125; &#125; //free minp cout&lt;&lt;minp->data&lt;&lt;endl; minpre->next = minp->next; // 删除节点保证不断链 free(minp); &#125; free(L); &#125; 26) 已知带头结点单链表，头指针list，不改变链表的前提下设计高效的算法，查找链表中倒数第k个位置上的节点的值(408.Y09) code ++/** * 掌握思想很重要，O(n)内实现 * 两个指针p,q， p先走k步，然后p,q一起走，当p到时，q即为倒数第k个位置 * 有可能会出现 k 大于表长的情况,需要判断 */ int fun6(linklist list,int k)&#123; linklist p,q; p = list->next; q = list->next; int i = 1; while(p)&#123; // p 走k步 if(i &lt;= k) &#123; i++; &#125; else&#123; // p,q 同时走 q = q->next; &#125; p = p->next; &#125; // k > n if( i &lt; k)&#123; return 0; &#125; cout&lt;&lt;q->data&lt;&lt;endl; // 此时q->data即为倒数第k个位置 return 1; &#125; 27) 假定采用带头结点的单链表保存单词,当两个单词有相同的后缀时,可共享相同的后缀存储空间,例如,“ loading”和&quot; being”的存储映像如下图所示(408,Y12) 设str1和str2分别指向两个单词所在单链表的头结点,链表结点结构为 data next请设计一个时间上尽可能高效的算法,找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符主所在结点的位置p)。要求 code ++/** * 求公共后缀, 求strlen(str1),strlen(str2); * 求差k， 大者先走k步， 然后同时走，第一个相等的即为公共后缀起点 */ typedef struct link&#123; char data; link *next; &#125;node,*linklist; linklist Common2(linklist str1,linklist str2)&#123; linklist p,q,s,l; p = str1->next,q = str2->next; int len1 = 0,len2 = 0,k; while(p)&#123; p = p->next,len1++;&#125; // 求str1长度 while(q)&#123; q = q->next,len2++;&#125; // 求str2长度 // 让 s指向短链 ；l指向长链 if(len1 &lt; len2)&#123; k = len2 - len1; s = str1->next; l = str2->next; &#125; else&#123; k = len1 - len2; s = str2->next; l = str1->next; &#125; while(k--)&#123; // 或者 for(int i = 0 ;i &lt; k ;i++) l = l->next; &#125; while(s&amp;&amp;l)&#123; if( s->data == l->data)&#123; return s; // 返回s的起始位置,此时s->data即为第一个相同元素(不带头结点) /* 此时返回的是带头结点的 linklist temp = new node(); temp->next = s; return temp; */ &#125;else&#123; s = s->next; l = l->next; &#125; &#125; return new node(); &#125; 28) 用单链表保存m个整数,结点的结构为data,link,|data|≤n(n为正整数)。现要求设计一个时间复杂度尽可能高效的算法,对于链表中data的绝对值相等的结点,仅保留第一次出现的结点而删除其余绝对值相等的结点。例如,若给定的单链表head如下:(408,Y15) code ++/** * 删除重复结点,无序 * 建立一个map索引,存放data,如果不存在则,链表跳过，否则删除这个结点， * 这里求的是|data| 所以索引用数组即可 * 时间O(m),空间O(n) * */ void fun6(linklist &amp;Head,int n)&#123; linklist p,pre; int vis[n+1]; // 初始化vis 标记为0; memset(vis,0,sizeof(vis)); p = Head->next;pre = Head; while(p)&#123; // 第一次存在，跳过(保留) if(!vis[abs(p->data)])&#123; vis[abs(p->data)] = 1; pre = p; p = p->next; &#125;else&#123; //重复 pre->next = p->next; free(p); //释放 p = pre->next; // 删除p后,保证不断链 &#125; &#125; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"算法","slug":"技术向/算法","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"技术向/C","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://www.sizaif.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"sizaif"},{"title":"循环右移K位问题的思考，几种方法的解决","slug":"循环右移K位问题的思考，几种方法的解决","date":"2021-08-11T14:01:57.000Z","updated":"2021-09-19T10:14:05.000Z","comments":true,"path":"posts/c1919217/","link":"","permalink":"https://www.sizaif.com/posts/c1919217/","excerpt":"","text":"@auther by sizaif 循环右移K位问题 @TOC 试用顺序存储结构设计一个算法，仅用一个辅助结点，实现将线性表中的结点循环右移k位的运算，并分析，算法的时间复杂度． 方法一: mod移位思想 图一： /** * 思路: * 运用mod的思想, 将n复制成2n的数组 如图一所示; 那么循环有移 逃不出2n内 * 右移后的结果为： (i+k) 缩到n内的话 就是 (i+k)%n * 实际上只需要用另外一个数组B[] 来存取 原数组A[] 的内容 即 B[i] = A[(i+n-k)%n]; * 但是 这样的话 空间复杂度就为 O(n), 时间复杂度为 O(n); */ for(int i = 0; i&lt; n ;i++) &#123; b[ i ] = a[ (i + n - k)%n]; &#125; 方法一plus： 会出现如下的情况： 改进-最大公约数GCD /** * 将方法加以改进 * 将其按照 k 步进行分组， 类似于希尔排序的思想， 每间隔k的位置构成一组，那么我们 * 的所谓右移只是在这每一组中组内移动，类似下图 * 那么我们只需要确定我们要循环几次就可以找到答案呢？ * 答案是确定的只需要找到他们的 gcd ， * 然后记录下开始位置，采用 反求x的方法 即 （x+k)%n = t, t,n,k已知 求未知数x * x = (t+n-k)%n; 当 x == 开始位置时停止,进入下一组 * 时间复杂度O(n) , 空间复杂度O(1) */ int Gcd(int a,int b)&#123; return b==0?a:Gcd(b,a%b); // 辗转相除法求GCD &#125; void fun(int a[],int n,int k)&#123; int gcd = Gcd(n,k); int t,temp,j; for(int i = 0 ;i &lt; gcd; i++) &#123; temp = a[i]; // 记录开始位置 t = i; while(1)&#123; j = ( t + n - k )%n; if( j == i) break; // 循环到自己跳出 a[t] = a[j]; t = j; &#125; a[t] = temp; &#125; &#125; ==验证：== 方法二：倒叙移位 /** ``````````````````````分割线`````````````````````````````` * 将空间复杂度降到O(1) * 所以考虑只用一个辅助结点的优化方法 * * 第一种 循环k次， 从后面开始移动， 空间复杂度为O(1) ,但时间复杂度为 O(kn) * */ for(int i = 0; i &lt; k; i++)&#123; int temp = a[n - 1]; for(int j = n-1; j > 0; j --)&#123; a[j] = a[j-1]; &#125; a[0] = temp; &#125; 方法三：递归调用 /** ``````````````````````分割线`````````````````````````````` * 将空间复杂度降到O(1) * 所以考虑只用一个辅助结点的优化方法 * * 第二种 采用递归反转的方式 空间复杂度为O(1) ,时间复杂度为 O(n) * 先递归反转前 （n-k)位 在反转后 k位 最后 全部反转 */ void reverse(int a[],int l,int r)&#123; for(; l &lt; r; l++,r--) &#123; int temp = a[l]; a[l] = a[r]; a[r] = temp; &#125; &#125; int main()&#123; reverse(a,0,n-k-1); reverse(a,n-k,n-1); reverse(a,0,n-1); return 0; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"算法","slug":"技术向/算法","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"技术向/C","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://www.sizaif.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"sizaif"},{"title":"小米青春版路由器解锁root与SSH方法","slug":"小米青春版路由器解锁root与SSH方法","date":"2021-08-11T14:01:56.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/e5a81842/","link":"","permalink":"https://www.sizaif.com/posts/e5a81842/","excerpt":"","text":"@auther by sizaif @TOC 前期准备 小米路由器 x1; 宽带线x1(连接路由器和电脑), 思路 因为小米青春版路由器没有USB插口,只能通过先刷开发版,再通过开发版来开启ROOT和SSH 下载开发版本ROM包 版本(miwifi_r1cl_all_59371_2.1.26.bin) 更高版本已经修复了此方法,所以只能是此版本 下载地址1: 百度W盘: e2p6 登录后台手动升级系统 后台地址: 192.168.1.1 进入后台后,系统升级,手动选择,选择对应的ROM包,等待5-8分钟左右,路由器会自动升级,重启 本地以太网设置手动IP地址为192.168.31.2 进入后台192.168.31.1进行引导 此过程中会设置Wifi名称密码,以及管理员密码, 注意!: 管理员密码很重要,后面会用到 地址栏开启ROOT和ssh 进入后台后,浏览器地址内会出现 http://192.168.31.1/cgi-bin/luci/;stok=09a506ee0b8e14d4acf3004a504eba4d/web/home#router 这样的信息, 我们将URL中 /web/home#router 修改为/api/xqsystem/set_name_password?oldPwd=前面设置的管理员密码&amp;newPwd=新的管理员密码 注意:新密码与旧密码不能一致 回车后: 如果成功则返回{“code”:0}, 如果是其他参数,请检查软件包是否为:59371_2.1.26 测试 电脑连接路由器的情况下,控制台: ssh root@192.168.31.1 第一次登录会提示存储密钥,yes即可","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"路由器","slug":"技术向/路由器","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://www.sizaif.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"author":"sizaif"},{"title":"小米青春版使用OpenWrt实现无线中继功能","slug":"小米青春版使用OpenWrt实现无线中继功能","date":"2021-08-11T14:01:54.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/57997d7/","link":"","permalink":"https://www.sizaif.com/posts/57997d7/","excerpt":"","text":"@auther by sizaif @TOC 简介 因为小米路由器自带的后台无线功能太鸡肋了, 无法实现自定义设置DCHP,默认为DCHP分配IP,但是分配的IP地址和主路由器在同一个字段,当设备多时会造成IP冲突现象.所以将机器刷机成Openwrt后实现需要的功能 小米青春版OpenWrt刷机 一解锁SSH与Root 参考文章链接:小米青春版路由器解锁root与SSH方法 刷入OpenWrt包 使用有线连接电脑和路由器 下载地址: 1: 重命名包名为 1.bin 2: 将下载的文件拷贝到路由器中 /tmp目录下 使用CMD控制台命令: (为了方便,可以把文件放到我的文档里, ip地址应该为192.168.31.1, 如果第一次刷完机) 1: scp 1.bin root@192.168.31.1:/tmp/ 3: 刷机 进入路由器内部/tmp/目录下: ssh root@192.168.31.1 开始刷机 cd /tmp/ mtd -r write 1.bin firmware 等待一会后路由器会重启 刷机完成 浏览器进入路由器后台","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"路由器","slug":"技术向/路由器","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://www.sizaif.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"author":"sizaif"},{"title":"二叉树题目算法题目整理(附代码)","slug":"二叉树题目算法题目整理-附代码","date":"2021-08-11T14:01:48.000Z","updated":"2021-09-19T10:14:26.000Z","comments":true,"path":"posts/cfa0d73d/","link":"","permalink":"https://www.sizaif.com/posts/cfa0d73d/","excerpt":"","text":"@auther by sizaif 说明： 由个人整理，部分题目是王道的题目,已经经常会考的点。 因个人代码风格,已经stack和queue的代码实现不同,代码略有不同之处， 但总体思想是正确的 有错误之处,欢迎指出 by sizaif @TOC 二叉树 code ++/** * 树结构 */ typedef struct Node&#123; char x; struct Node *lson,*rson; &#125;Tree,*BiTree; typedef struct Queue&#123; //自己构造队列 BiTree *x; int front; int rear; void Initqueue() &#123; front=rear=0; x =(BiTree *)malloc(MAX*sizeof(Tree)); &#125; void POP() &#123; front=(front+1)%MAX; &#125; int length() &#123; return (rear-front +MAX)%MAX; &#125; bool emptys() &#123; if(front==rear) return 1; return 0; &#125; void Push_back(BiTree T) &#123; if((rear+1)%MAX==front) return; x[rear]=T; rear=(rear+1)%MAX; &#125; BiTree Getfront() &#123; if(front==rear) return NULL; BiTree T; T = x[front]; return T; &#125; &#125;queues; typedef struct Stack&#123; // 自己构造栈 BiTree *tt; int top; int size; void InitStack() &#123; tt= ( BiTree *)malloc(n*sizeof(Tree)); top=0; size=n; &#125; bool emptys() &#123; if(top==0) return true; return false; &#125; void Push_back(BiTree num) &#123; tt[top++]=num; &#125; void Pop() &#123; if(top==0)return; top--; //num=x[--top]; &#125; BiTree Gettop() &#123; if(top==0) return NULL; return tt[top-1];// top &#125; &#125;stacks; 1) 采用下列方法之一建立二叉树的二叉链表： a) 输入完全二叉树的先序序列，用#代表虚结点（空指针），如ABD###CE##F##，建立二叉树的二叉链表。 code ++/** * 先序建立 * @param T [description] */ void build_frist(BiTree &amp;T) &#123; char ch; scanf(\"%c\",&amp;ch); if(ch=='#') T=NULL; else &#123; T= new Tree ; T->x=ch; build_frist(T->lson); build_frist(T->rson); &#125; &#125; b) 已知二叉树的先序遍历序列和中序遍历序列。 code ++/** * [pre_mid_build 先序+中序建立二叉树] * @param Fi [先序] * @param In [中序] * @param l1 [先序左端下标] * @param h1 [先序右端下标] * @param l2 [中序左端下标] * @param h2 [中序右端下标] * 初始 l1 = l2 = 0 , h1 = h2 = n; */ BiTree pre_mid_build(BiTree Fi[],BiTree In[],int l1,int h1,int l2,int h2) &#123; BiTree T = new Tree; T->data = Fi[l1]; for(int i = l2;In[i]!=Fi[l1] ; i++); int llen = i - l2; int rlen = h2 - i; if(llen) T->lchild = pre_mid_build(Fi,In,l1+1,l1+llen,l2,l2+llen-1); else T->lchild = NULL; if(rlen) T->rchild = pre_mid_build(Fi,In,h1-rlen+1,h1,h2-rlen+1,h2); else T->rchild = NULL; return T; &#125; /** * 已知先序和中序 建立二叉树 * @param T [description] * @param Fi [description] * @param In [description] * @param n [description] */ void build(BiTree &amp;T,char *Fi,char *In,int n) &#123; if(n&lt;1) &#123; T=NULL; return; &#125; int i=0,l1=0,l2=0,p=0,m=0; char lson[120],rson[120]; char str1[120],str2[120]; mem(lson,0); mem(rson,0); T= new Tree; T->x=Fi[0]; while(In[i]!=Fi[0]) i++; l1=i; l2=n-i-1; int temp=i; for(int j=1;j&lt;=temp;j++) lson[j-1]=Fi[j]; for(int j=temp+1;j&lt;n;j++) &#123; rson[j-temp-1]=Fi[j]; str2[j-temp-1]=In[j]; &#125; for(int j=0;j&lt;temp;j++) str1[j]=In[j]; if(!lson[0]) T->lson=NULL; else build(T->lson,lson,str1,l1); if(!rson[0]) T->rson=NULL; else build(T->rson,rson,str2,l2); &#125; void frist_and_mid() &#123; cout&lt;&lt;\"*****************************\"&lt;&lt;endl; BiTree T2; char str1[120],str2[120],str3[120]; printf(\"input of the first :\\n\"); scanf(\"%s\",str1); printf(\"input of the mid :\\n\"); scanf(\"%s\",str2); int len=strlen(str1); build(T2,str1,str2,len); printf(\"构造的二叉树 后序遍历为: \\n\"); query(T2,3); cout&lt;&lt;\"\\n*****************************\"&lt;&lt;endl; &#125; c) 已知二叉树的中序遍历序列和后序遍历序列，建立二叉树的二叉链表。 ++ 2) 写出对用二叉链表存储的二叉树进行先序、中序和后序遍历的递归算法 code ++/** * 三种递归 1先序 2中序与 3后序 * @param T [description] * @param oper [description] */ void query(BiTree T,int oper) &#123; if(T) &#123; if(oper==1) printf(\"%c \",T->x); query(T->lson,oper); if(oper==2) printf(\"%c \",T->x); query(T->rson,oper); if(oper==3) printf(\"%c \",T->x); &#125; &#125; 3) 写出对用二叉链表存储的二叉树进行先序遍历的非递归算法。 code ++/** * 非递归先序 * @param T [description] */ void query_frist(BiTree T) &#123; stacks S; S.InitStack(); S.Push_back(T); while(!S.emptys()) &#123; while(S.Gettop()!=NULL) &#123; printf(\"%c \",S.Gettop()->x); S.Push_back(S.Gettop()->lson); &#125; S.Pop(); if(!S.emptys()) &#123; BiTree Temp; Temp=S.Gettop(); S.Pop(); S.Push_back(Temp->rson); &#125; &#125; &#125; 4) 写出对用二叉链表存储的二叉树中序遍历的非递归算法。 code ++/** * 非递归中序 * @param T [description] */ void query_mid(BiTree T) &#123; stacks S; S.InitStack(); S.Push_back(T); while(!S.emptys()) &#123; while(S.Gettop()!=NULL) &#123; S.Push_back(S.Gettop()->lson); &#125; S.Pop(); if(!S.emptys()) &#123; BiTree Temp; Temp=S.Gettop(); printf(\"%c \",Temp->x); S.Pop(); S.Push_back(Temp->rson); &#125; &#125; &#125; 5) 写出对用二叉链表存储的二叉树后序遍历的非递归算法。 code ++/** * 非递归后序 * @param T [description] */ void query_last(BiTree T) &#123; stacks S; S.InitStack(); S.Push_back(T); while(!S.emptys()) &#123; while(S.Gettop()!=NULL) &#123; S.Push_back(S.Gettop()->lson); &#125; S.Pop(); if(!S.emptys()) &#123; if(S.Gettop()->rson) S.Push_back(S.Gettop()->rson); else &#123; BiTree Temp; Temp=S.Gettop(); printf(\"%c \",Temp->x); S.Pop(); while(S.Gettop()!=NULL&amp;&amp;!S.emptys()&amp;&amp;S.Gettop()->rson==Temp) &#123; printf(\"%c \",S.Gettop()->x); Temp=S.Gettop(); S.Pop(); &#125; if(!S.emptys()) &#123; S.Push_back(S.Gettop()->rson); &#125; &#125; &#125; &#125; &#125; /** * [PostOrder 后序遍历二叉树非递归] * @param T [Bitree] */ void PostOrder(BiTree T) &#123; InitStack(S); BiTree p = T; BiTree r = NULL; while(p || !IsEmpty(S))&#123; if(p) // 走到最左边 &#123; Push(S,p); p = p->lchild; &#125; else &#123; GetTop(S,p); if(p->rchild &amp;&amp; p->rchild != r) // 右子树存在且未被访问 &#123; p = p->rchild; // 转向右 Push(S,p);// 入栈 p = p->lchild; // 转向左 &#125;else&#123; Pop(S,p); visit(p->data); r= p ; p = NULL; &#125; &#125; &#125; &#125; 6) 写出对用二叉链表存储的二叉树进行层次遍历算法。 code ++/** * [Invertlevel 层次遍历,自下而上,自左到右] * @param T [BiTree] * 二叉树自下而上,自左到右 * 正常层次遍历, 出队时入栈 * 最后依次出栈为结果 */ void Invertlevel(BiTree T) &#123; Stack&lt;int> S; Queue&lt;int> Q; BiTree p; if(T) &#123; InitQueue(Q); InitStack(S); EnQueue(Q,T); while(!IsEmpty(Q)) &#123; DeQueue(Q,p); Push(S,p); // 出队,入栈 if(p->lchild) EnQueue(Q,p->lchild); if(p->rchild) EnQueue(Q,p->rchild); &#125; while(!IsEmpty(S)) &#123; Pop(S,p); visit(p->data); // 自下而上,自左到右 &#125; &#125; &#125; 7) 递归实现求二叉树的所有叶子数。 code ++/** * 求二叉树的所有叶子数] * @param T [description] */ void query_leaf(BiTree T)&#123; if(!T) return 0; if(T->lson == NULL &amp;&amp; T->rson == NULL) return 1; return query_leaf(T->lson)+query_leaf(T->rson); &#125; 8) 递归实现求二叉树的所有结点总数。 ++int query_node(BiTree T)// 节点总个数 &#123; if(!T) return NULL; if(T->lson == NULL &amp;&amp; T->rson == NULL) return 1; return query_node(T->lson) + query_node(T->rson) + 1; &#125; 8+) 求二叉树第k层的结点个数 code ++/** * 求二叉树第 k 层的结点个数 * 思想: 如图 * @param T [description] * @param k [第k层] * @return [description] */ int query_levelk(BiTree T,k)&#123; if(!T) return 0; if(k &lt;= 0) return 0; if(k &lt;= 1) return 1; return query_levelk(T->lson,k-1) + query_levelk(T->rsom,k-1); &#125; 9) 判断完全二叉树 code ++/** * 判断完全二叉树 * @param T [description] * @return [description] */ bool judge(Bitree &amp;T) &#123; //1 2 4 8 -1 -1 9 -1 -1 5 10 -1 -1 -1 3 6 -1 -1 7 -1 -1 queue&lt;Bitree>Q; Bitree pre; Q.push(T); while(Q.front() != NULL) &#123; pre = Q.front(); Q.pop(); Q.push(pre->lson); Q.push(pre->rson); &#125; while(!Q.empty()) &#123; pre = Q.front(); Q.pop(); if(NULL != pre) return false; &#125; return true; &#125; 10) 递归实现求 二叉树高度(深度) code ++/** * 二叉树高度 * @param T [description] * @return [description] */ int deep_tree(Bitree &amp;T) &#123; if(!T) return 0; int left = deep_tree(T->lson); int rig = deep_tree(T->rson); return left > rig ? (left+1):(rig+1); &#125; 11) 非递归求二叉树高度(深度)(利用层次遍历) code ++/** * [BtDepth 非递归求二叉树高度] * @param T [BiTree] * 数组模拟队列,level 记录层数, * 每次层次遍历出队列时,与last指针比较,若两者相同,则层数+1; */ void BtDepth(BiTree T) &#123; if(!T) return 0; int front = -1 , rear = -1; int last = 0 , level = 0; BiTree Q[MAXN]; Q[++rear] = T; BiTree p; while(front &lt;= rear) &#123; p = Q[++front]; if(p->lchild) Q[++rear] = p->lchild; if(p->rchild) Q[++rear] = p->rchild; if(front == last)&#123; // 该层最右结点 level++; last = rear; // 更新 &#125; &#125; &#125; 11+) 孩子兄弟表示法求树的深度 code ++/** * [Height_CS 孩子兄弟表示法求树的深度] * @param T [description] * @return [description] */ int Height_CS(CSTree T) &#123; int hc,hs; if(T == NULL) return 0; else &#123; hc = Height_CS(T->fichild); // 第一子树高 hs = Height_CS(T->nextchild); // 兄弟树高 return hc+1 > hs ? hc+1 : hs; &#125; &#125; 12) 判断平衡二叉数是否平衡 code ++/** * [judge_AVL 判断二叉排序树,是否平衡] * @param T [description] * @param balance [description] * @param h [description] * balanc = 1 平衡, 0 不平衡 * 空树 , 仅有根节点, 平衡 */ void judge_AVL(BiTree T,int &amp;balance ,int &amp;h) &#123; int bl = 0, br = 0, hl = 0 , hr = 0; if(T == NULL) // 空树 ,高度为 0 &#123; h = 0; balance = 1; &#125; else if(T->lchild == NULL &amp;&amp; T->rchild == NULL) // 仅有根节点, 高度为1 &#123; h = 1, balance = 1 ; &#125; else &#123; judge_AVL(T->lchild,bl,h1); judge_AVL(T->rchild,br,h2); h = (hl> hr ? hl:hr) +1; if(abs(hl-hr) &lt; 2) // 高度差 小于2 balance = bl &amp;&amp; br; //逻辑与 当左右都平衡时, 平衡 else balance = 0; &#125; &#125; 13) 递归实现求二叉树双分支节点树 code &#x2F;** * [DsonNode 递归实现求二叉树双分支节点树] * @param T [二叉链表] * @return [节点数] *&#x2F; int DsonNode(BiTree T) &#123; if(T&#x3D;&#x3D;NULL) return 0; else if(T-&gt;lchild !&#x3D;NULL &amp;&amp; T-&gt;rchild !&#x3D;NULL ) &#x2F;&#x2F; 左右孩子都有 return DsonNode(T-&gt;lchild) + DsonNode(T-&gt;rchild) +1; else return DsonNode(T-&gt;lchild) + DsonNode(T-&gt;rchild); &#125; 14) 递归实现左右孩子互换 code ++/** * [Swap_child 递归实现左右孩子互换] * @param T [description] * 先换T结点 左子树左右孩子 * 再换右子树, * 最后节点的孩子互换 */ void Swap_child(Bitree T) &#123; if(T) &#123; Swap_child(T->lchild); // 先左子树 Swap_child(T->rchild); // 右子树 Bitree temp = T->lchild; // 左右孩子互换 T->lchild = T->rchild; T->lchild = temp; &#125; &#125; 15) 删除二叉树中每个元素值 为x的结点 code ++/** * [Search 删除二叉树中每个元素值 为x的结点] * 并删去以他为根的子树 * @param T [description] * @param x [description] * 后序遍历二叉树, 层次遍历找到结点的父节点 */ void Search(BiTree T,ElemType x)&#123; BiTree Q[]; if(T) &#123; if(T->data == x) &#123; DeleteXTree(T); exit(0); &#125; InitQueue Q; EnQueue(Q,T); while(!IsEmpty(Q)) &#123; DeQueue(Q,p); if(p->lchild)&#123; // 左非空 if(p->lchild->data == x) // 左子树符合, 删除左子树 &#123; DeleteXTree(p->lchild); p->lchild = NULL; &#125; else // 父节点左子树置为空 EnQueue(Q,p->lchild); //左子女入队列 &#125; if(p->rchild) // 右子树符合, 删除右子树 &#123; if(p->rchild->data == x) &#123; DeleteXTree(p->rchild); p->rchild = NULL; &#125; else EnQueue(Q,p->rchild); // 右子女入队列 &#125; &#125; &#125; &#125; 16) 求先序遍历中第k个结点的值 code ++/** * [PreNode 求先序遍历中第k个结点的值] * @param Bt [description] * @param k [description] * @return [description] */ int count = 1; ElemType PreNode(BiTree T, int k) &#123; if(T == NULL) return '#'; if( count == k) return T->data; count++; ch = PreNode(T->lchild,k); // 左子树返回该值 if(ch != '#') return ch; ch = PreNode(T->rchild,k); // 右子树递归查找 return ch; &#125; 17) 求代权路径长度和 code ++/** * [Wpl_preOreder 求代权路径长度和] * @param T [description] * @param deep [description] * @return [description] * 2014 408 真题 , 王道127页 */ int Wpl(BiTree T) &#123; return Wpl_preOreder(T,0); &#125; int wpl = 0; int Wpl_preOreder(BiTree T,int deep) &#123; if(T->lchild == NULL &amp;&amp; T->rchild == NULL) // 叶节点 返回 wp wpl += deep * T->data; if(T->lchild != NULL) Wpl_preOreder(T->lchild,deep+1); if(T->rchild != NULL) Wpl_preOreder(T->rchild,deep+1); return wpl; &#125; 18) 求非空二叉树的宽度 code ++/** * [BTWidth 求非空二叉树的宽度] * @param T [description] * @return [description] * 层次遍历求所有点的层次,将所有节点和对应层次放在一个队列中 * 扫描队列,求最大层次节点总数 */ typedef struct&#123; BiTree data[MAXN];// 存放指针 int level[MAXN];//层次 int front,rear; &#125;Que; int BTWidth(BiTree T) &#123; BiTree p; Que.front = Que.rear = -1; Que.rear ++; Que.data[Que.rear] = T; // 入队 Que.level[Que.rear] = 1;// 层次为1; int k,Max,n; while(Que.front &lt; Que.rear) &#123; Que.front ++; // 出队 p = Que.data[Que.front]; k = Que.level[Que.front]; if(p->lchlid != NULL) // 左孩子进队列 &#123; Que.rear++; Que.data[rear] = p->lchlid; Que.level[rear] = k + 1; &#125; if(p->rchild!=NULL) // 右孩子进队列 &#123; Que.rear++; Que.data[rear] = p->rchlid; Que.level[rear] = k + 1; &#125; &#125; Max = -1, k = 1; int i = 0; while( i &lt; Que.rear) &#123; n = 0; while(i&lt;Que.rear &amp;&amp; Que.level[i] == k) &#123; // 统计第k曾节点数 n++; i++; &#125; k = Que.level[i]; if( n > Max) Max = n; &#125; return Max; &#125; 19) 判断两颗二叉树是否结构相同 code ++/** * [判断两个二叉树结构是否相等] * @param T1 [description] * @param T2 [description] * @return [description] */ int isEqual(BiTree T1,BiTree T2)&#123; if( !T1 &amp;&amp; !T2) return 1; if( !T1 || !T2) return 0; return isEqual( T1->lson,T2->lson) &amp;&amp; isEqual(T1->rson,T2->rson); &#125; 20) 求两个结点的最低(近)公共祖先结点 code ++/** * [求两个结点的最低公共祖先结点] * @param T [description] * @param A [description] * @param B [description] * @return [description] */ BiTree lowAnc(BiTree T,BiTree A,BiTree B)&#123; if( !T) return NULL; if( T == A || T == B) return T; // 说明在某左子树或右子树中找到目标结点 BiTree left = lowAnc(T->lson,A,B); BiTree right = lowAnc(T->rson,A,B); // 当在左子树和右子树中都找到A,B 说明是最近的公共祖先 if( left != NULL &amp;&amp; right != NULL) return T; //对一个底层向上更新的根结点来说，只在左子树或右子树找到了目标结点，则返回找到的结点。 return !left ? right:left; &#125; 20+) 求任意两结点距离 code ++/** * [求两个结点的最低公共祖先结点] * @param T [description] * @param A [description] * @param B [description] * @return [description] */ BiTree lowAnc(BiTree T,BiTree A,BiTree B)&#123; if( !T) return NULL; if( T == A || T == B) return T; // 说明在某左子树或右子树中找到目标结点 BiTree left = lowAnc(T->lson,A,B); BiTree right = lowAnc(T->rson,A,B); if( left != NULL &amp;&amp; right != NULL) // 当在左子树和右子树中都找到A,B 说明是最近的公共祖先 return T; return !left ? right:left; //对一个底层向上更新的根结点来说，只在左子树或右子树找到了目标结点，则返回找到的结点。 &#125; /** * [求最近公共祖先到目标p的距离] * @param T [description] * @param p [description] * @return [description] */ int CalDistance(BiTree T,BiTree p)&#123; if( !T ) return -1; if( T == p) return 0; // 先在左子树找 int res = CalDistance(T->lson,p); // 如果未找到,在右子树中找 if( res == -1) res = CalDistance(T->rson,p); // 找到, 距离+1 if( res != -1) return res + 1; // 如果带权值, 这里改成+权值 return -1; &#125; /** * [求树中A-B的距离] * @param T [description] * @param A [description] * @param B [description] * @return [description] */ int Dis_A_B(BiTree T,BiTree A,BiTree B)&#123; //找到最低公共祖先结点 BiTree lowanc = lowAnc(T,A,B); // 求最近最近公共祖先结点到两目标结点的距离之和 return CalDistance(lowanc,A) + CalDistance(lowanc,B); &#125; 20++) 找出二叉树中某个结点的所有祖先结点 code ++/** * 找出二叉树中某个结点的所有祖先结点 * @param T [description] * @param A [description] * @return [description] */ int FindAllAnc(BiTree T, BiTree A)&#123; // 未找到 if( !T ) return 0; // 找到目标结点 if( T == A) return 1; // 如果在左子树或右子树中找到输出此祖先结点 if( FindAllAnc(T->lson,A) || FindAllAnc(T->rson,A) ) &#123; // 或者其他操作 cout&lt;&lt;T->data&lt;&lt;endl; return 1; &#125; return 0; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"算法","slug":"技术向/算法","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"技术向/C","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://www.sizaif.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"sizaif"},{"title":"SpringBoot项目打包并发布到linux线上详细记录全过程,详细!","slug":"SpringBoot项目打包并发布到linux线上详细记录全过程-详细","date":"2021-08-11T14:01:46.000Z","updated":"2021-09-19T10:13:00.000Z","comments":true,"path":"posts/48019f05/","link":"","permalink":"https://www.sizaif.com/posts/48019f05/","excerpt":"","text":"@auther by sizaif @TOC 前期准备 一台线上linux服务器.阿里云,腾讯云,华为云或者国外的vps都可以 ssh工具,像xshell,putty sftp传输工具,像filezilla. 传输jar包文件 java jdk linux 安装包, 官网即可下载 使用Maven打包项目 处理静态文件以及端口号 如果引入了外部文件,像upload上传图片的功能, 需要设置目录为linux目录 一般在windows上开发,windows和linux不一样 application.yml配置 MVCconfig 写个java iimplements WebMvcConfigurer // 接入虚拟路径（解决重启服务器才显示图片的问题） // 拦截本地路径 @Value(\"$&#123;web.upload-path&#125;\") private String path; @Override public void addResourceHandlers(ResourceHandlerRegistry registry)&#123; // addResourceHandler: （ 存储图片的虚拟路径，在 static 目录下的 picture 文件夹，用于存储上传图片） // addResourceLocations: （ file: + 存储图片的路径） registry.addResourceHandler(\"/images/**\").addResourceLocations(\"file:\"+path); &#125; 打包 步骤: 忽略掉test测试,防止发布到线上出现各种问题 成功后会在target目录下生成 版本号与pom.xml 中version有关 安装JDK 参考文章: linux安装java1.8 jdk并配置环境变量 像阿里云和腾讯云需要配置安全组, 参考连接:阿里云安全组配置方法 将jar包传输到linux服务器上 java运行jar包 为了方便,写一个start.sh脚本 方便日后更新版本执行 vim start.sh nohup java -jar emsdemo-0.1.8-SNAPSHOT.jar >springboot.log 2>&amp;1 &amp; chmod +x start.sh 运行 并查看运行日志 ./start.sh cat springboot.log 然后在浏览器输入你的ip:端口号就可以访问了 额外:使用域名访问 如果我想通过域名直接访问项目,不想用ip+ 端口号的方式 ==国内的服务器域名绑定需要备案,国外不用== 思路: ==默认域名绑定80端口,所以使用nginx 端口转发功能== 安装nginx 如果不想手动安装,安装宝塔,用宝塔安装和配置 宝塔安装:linux安装宝塔 配置nginx server &#123; listen 80; #server_name phpmyadmin; #index index.html index.htm index.php; #root &#x2F;www&#x2F;server&#x2F;phpmyadmin; #error_page 404 &#x2F;404.html; #include enable-php.conf; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;sizaif.com:8080; &#125; &#125; 然后relod nginx 过一会通过域名就可以访问了 效果","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"},{"name":"Springboot","slug":"技术向/Springboot","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Springboot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.sizaif.com/tags/Springboot/"}],"author":"sizaif"},{"title":"SpringBoot项目图片文件的上传与显示","slug":"SpringBoot项目图片文件的上传与显示","date":"2021-08-11T14:01:44.000Z","updated":"2021-09-19T10:12:51.000Z","comments":true,"path":"posts/38a7ff2/","link":"","permalink":"https://www.sizaif.com/posts/38a7ff2/","excerpt":"","text":"@auther by sizaif 需求分析 在个人信息页面点击图片上传,上传文件到后台后,并修改图片的名称,设置为 唯一的名称,并同步跟新图片名称到数据库中 数据库设计 我的数据库中: Users存放用户名和密码, Member 存放用户详细信息(包括图片) 配置application.yml 设置自定义的文件上传目录: # 自定义文件上传路径 web: # Linux # upload-path: /root/emsdemo/image # Windows 10 upload-path: C:/Users/SIZ/Desktop/bishe/image/ 后台代码 控制代码 code @Value(\"$&#123;web.upload-path&#125;\") private String path; @PostMapping(\"/users/doUpload/&#123;uid&#125;\") public String UploadImage(@PathVariable(\"uid\") Integer id,@RequestParam(\"imgfile\")MultipartFile file,HttpServletRequest httpServletRequest)&#123; /** * header_img_url是从数据库里捞的，要和你本地或者线上的专门放图片的文件夹里的文件去匹配， * 如果一开始我捞了数据库的头像，发现这个已经存在文件夹里了，那我需要换头像的时候， * 就需要找文件夹里有没有和这一模一样的文件，很明显是有的，因为不管换不换头像之前， * 我这个头像一定是保存在数据库字段里面，并且也在文件夹里面，此时我要更换头像了， * 那我肯定要把文件的这个头像文件删掉并把新上传的头像文件加进来，不存历史记录， * 防止越来越多的头像占内存，并且，我要把这条记录插到数据库里面，，相当于更新了头像。 */ // 获取当前用户 Subject currentUser = SecurityUtils.getSubject(); Users curru = (Users) currentUser.getPrincipal(); System.out.println(\"currenttUser.ID--> \" + curru.getId()); /** * 根据User.id 拿到member 全部信息 */ Member member = memberService.QueryOneMemberInfoByID(curru.getId()); /** * 获取数据库中当前用户的照片 * 若存在则删除,替换 */ File sqlfile = new File(member.getImage()); Boolean isExits = sqlfile.exists(); if(isExits)&#123; sqlfile.delete(); &#125; //得到将要上传的文件名 String fileName = file.getOriginalFilename(); //设置文件上传，并且设置了新的唯一名字XXXXX.jpg String newFileName = FileUtils.upload(file, path, fileName); /** * 连接数据库进行进行更新 */ HashMap&lt;String, Object> memberMap = new HashMap&lt;>(); memberMap.put(\"image\",newFileName); memberMap.put(\"id\",id); SystemResult systemResult = memberService.UpdateMemberInfo(memberMap); if(systemResult.getStatus()!=200)&#123; // 失败 System.out.println(systemResult.getMsg()); &#125;else &#123; // 成功 /** * 更新到IndexDto 中 */ Member afterUpdateImageMember = memberService.QueryOneMemberInfoByID(curru.getId()); IndexDto indexDto = new IndexDto(); UsersServiceAppoint.WriteUsersInfoToDto(indexDto,curru,afterUpdateImageMember); Session session = currentUser.getSession(); HttpSession httpSession = httpServletRequest.getSession(); httpSession.setAttribute(\"IndexDto\",indexDto); session.setAttribute(\"IndexDto\",indexDto); System.out.println(\"进行了图片上传功能,并更新到数据库\"); System.out.println(systemResult.getMsg()); &#125; /** * 重定向到--->个人信息页面 */ return \"redirect:/users/toProfilesPage/\"+ id; &#125; &#125; FileUtils代码 code package com.sizaif.emsdemo.utils; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.IOException; import java.util.UUID; public class FileUtils &#123; /** * 唯一识别的UUID * @return */ public static String getUUID()&#123; return UUID.randomUUID().toString().replace(\"-\", \"\"); &#125; /** * 获取文件后缀 * @param fileName * @return */ public static String getSuffix(String fileName)&#123; return fileName.substring(fileName.lastIndexOf(\".\")); &#125; /** * 和随机的UUID生成新的文件名 * @param fileOriginName * @return */ public static String getFileName(String fileOriginName)&#123; return getUUID() + getSuffix(fileOriginName); &#125; /** * 保存文件到本地,并返回新的唯一文件名 * @param file 文件 * @param path 文件存放路径 * @param fileName 文件名字 * @return */ public static String upload(MultipartFile file, String path, String fileName)&#123; String newFileName = getFileName(fileName); // 生成新的文件名 String realPath = path + \"/\" + newFileName; File dest = new File(realPath); //判断文件父目录是否存在 if(!dest.getParentFile().exists())&#123; dest.getParentFile().mkdir(); &#125; try &#123; //保存文件 file.transferTo(dest); return newFileName; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; &#125; MVCConfig设置 code 新建MyMvcConfig.java @Configuration @Component public class MyMvcConfig implements WebMvcConfigurer &#123; // 接入虚拟路径（解决重启服务器才显示图片的问题） // 拦截本地路径 // 前端代码只需要设置成到/images/目录下拿图片, // 便可以自动到自己设置的path目录下拿图片 @Value(\"$&#123;web.upload-path&#125;\") private String path; @Override public void addResourceHandlers(ResourceHandlerRegistry registry)&#123; // addResourceHandler: （ 存储图片的虚拟路径，在 static 目录下的 picture 文件夹，用于存储上传图片） // addResourceLocations: （ file: + 存储图片的路径） registry.addResourceHandler(\"/images/**\").addResourceLocations(\"file:\" +path ); &#125; &#125; 前端代码 上传代码 &lt;form enctype=\"multipart/form-data\" method=\"post\" th:action=\"@&#123;/users/doUpload/&#125; + $&#123;ProfilesInfo.getId()&#125;\"> &lt;input class=\"btn btn-success \" name=\"imgfile\" type=\"file\">&lt;i class=\"fa fa-image m-right-xs\">&lt;/i>修改照片&lt;/input> &lt;input type=\"submit\" class=\"tn btn-success\" value=\"上传\"> &lt;/form> 显示代码 ${ProfilesInfo.getImage()} 拿到的是数据库中图片的名字 &lt;img class=\"img-responsive avatar-view\" th:src=\"@&#123;/images/&#125;+$&#123;ProfilesInfo.getImage()&#125;\" alt=\"Avatar\" title=\"Change the avatar\" onclick=\"F_Open_dialog()\">","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"},{"name":"Springboot","slug":"技术向/Springboot","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Springboot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.sizaif.com/tags/Springboot/"}],"author":"sizaif"},{"title":"SEAL学习第四天-Ckks_basics","slug":"SEAL学习第四天-ckks-basics","date":"2021-08-11T14:01:42.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/51f3b771/","link":"","permalink":"https://www.sizaif.com/posts/51f3b771/","excerpt":"","text":"@auther by sizaif SEAL 学习第四天： ckks_basics @[toc] 简介说明 通常一个好的策略是为CKKS选择参数方案如下: (1) 选择一个60位素数作为coeff_modulus中的第一个素数.这将解密时给出最高的精度; (2) 选择另一个60位素数作为coeff_modulus的最后一个元素，,同时这将被用作特殊的素数，应该与其他质数中最大的一样打； (3) 选择中间素数彼此接近 我们使用CoeffModulus::Create来生成适当大小的素数。请注意我们的coeff_modulus是200位的总和，这低于 poly_modulus_degree: CoeffModulus::MaxBitCount(8192)返回218。 scale 比例增大输入的浮点系数数据 即使在纯文本元素的CKKS方案基本上是多项式的整数系数 x^n 编码的位精度;自然会影响精度结果。 所以设置一个放大比例系数是很有必要的。 有了scale 必然有rescale rescale 通常在乘法后执行 目的: 乘法后： scale = scale + scale = 2*scale 即 $ \\Delta^{2}\\to \\Delta $ 函数调用 参数类型 解释说明 evaluator.rescale_to_next_inplace(Ciphertext) Ciphertext 重新调整scale比例系数接近于初始设置的值，接近但不是等于 double scale = pow(2.0, 40); int 定义一个2^40 的scale 比例系数 Encoding &amp; Decoding 计算 对于多项式 不同的计算顺序消耗的噪声预算以及性能不同 在这个样例中: 求 $F(x) = \\pi * x^{3} + 0.4 * x +1$ Plaintext plain_coeff3, plain_coeff1, plain_coeff0; // 编码 encoder.encode(3.14159265, scale, plain_coeff3);// PI encoder.encode(0.4, scale, plain_coeff1); // 0.4 encoder.encode(1.0, scale, plain_coeff0); // 1 // x^2 evaluator.square(x1_encrypted, x3_encrypted); // x3_encrypted = x1_encrypted * x1_encrypted evaluator.relinearize_inplace(x3_encrypted, relin_keys); evaluator.rescale_to_next_inplace(x3_encrypted); // 重新调整scale 规模 // PI * x evaluator.multiply_plain(x1_encrypted, plain_coeff3, x1_encrypted_coeff3);// x1_encrypted_coeff3 = x1_encrypted * plain_coeff3 evaluator.rescale_to_next_inplace(x1_encrypted_coeff3); // 0.4*x evaluator.multiply_plain_inplace(x1_encrypted, plain_coeff1); evaluator.rescale_to_next_inplace(x1_encrypted); 然后就可以三项之和；然而,有一个严重的问题是: ​ 这三个术语使用的加密参数都是不同是由于模数从缩放转换而来。 ​ 而加密的加法和减法要求输入的level为相同并且加密参数(parms_id)匹配。 ​ 如果有不匹配时，求值器将抛出异常。 我们验证可以发现三者的level是不一样的 在这个样例中 level的变化过程 - Product x^2 has scale 2^80 and is at level 2; - Product PI*x has scale 2^80 and is at level 2; - We rescaled both down to scale 2^80/P_2 and level 1; - Product PI*x^3 has scale (2^80/P_2)^2; - We rescaled it down to scale (2^80/P_2)^2/P_1 and level 0; - Product 0.4*x has scale 2^80; - We rescaled it down to scale 2^80/P_2 and level 1; - The contant term 1 has scale 2^40 and is at level 2. 三者的scale 虽然接近，但也是不一样的 这里有几种方法来解决这个scale问题 既然P_2和P_1非常接近2 ^ 40,我们可以简单欺骗 Microsoft SEAL，把scale 设置成一样的，因为以及非常接近2^40 // 重新设置两者的scale x3_encrypted.scale() = pow(2.0, 40); x1_encrypted.scale() = pow(2.0, 40); 另一种方法就是将1 编码成 2^80/P_2 在做一个 multiply_plain 将level降到与0.4*x 保持一致 解决掉上面的问题后我们还有加密参数不匹配的问题。这是很容易的通过使用modulus switching (no rescaling) 来解决 CKKS支持modulus switching就像BFV格式一样、 cout &lt;&lt; \"Normalize encryption parameters to the lowest level.\" &lt;&lt; endl; parms_id_type last_parms_id = x3_encrypted.parms_id(); evaluator.mod_switch_to_inplace(x1_encrypted, last_parms_id); evaluator.mod_switch_to_inplace(plain_coeff0, last_parms_id); 到现在这三种密文现在都是兼容的，可以进行add运算了 cout &lt;&lt; \"Compute PI*x^3 + 0.4*x + 1.\" &lt;&lt; endl; Ciphertext encrypted_result; evaluator.add(x3_encrypted, x1_encrypted, encrypted_result); evaluator.add_plain_inplace(encrypted_result, plain_coeff0); 结果验证: 输出一个真的，然后将加密的解密解码，做对比验证 code Plaintext plain_result; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode PI*x^3 + 0.4x + 1.\" &lt;&lt; endl; cout &lt;&lt; \" + Expected result:\" &lt;&lt; endl; vector&lt;double> true_result; for (size_t i = 0; i &lt; input.size(); i++) &#123; double x = input[i]; true_result.push_back((3.14159265 * x * x + 0.4) * x + 1); &#125; print_vector(true_result, 3, 7); /* Decrypt, decode, and print the result. */ decryptor.decrypt(encrypted_result, plain_result); vector&lt;double> result; encoder.decode(plain_result, result); cout &lt;&lt; \" + Computed result ...... Correct.\" &lt;&lt; endl; print_vector(result, 3, 7); 源代码 code #include &quot;examples.h&quot; using namespace std; using namespace seal; void example_ckks_basics() &#123; print_example_banner(&quot;Example: CKKS Basics&quot;); &#x2F;* In this example we demonstrate evaluating a polynomial function PI*x^3 + 0.4*x + 1 on encrypted floating-point input data x for a set of 4096 equidistant points in the interval [0, 1]. This example demonstrates many of the main features of the CKKS scheme, but also the challenges in using it. We start by setting up the CKKS scheme. *&#x2F; EncryptionParameters parms(scheme_type::ckks); size_t poly_modulus_degree &#x3D; 8192; &#x2F;&#x2F;long long unsigned int parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 60, 40, 40, 60 &#125;)); &#x2F;* * 我们选择初始比例为2^40 * this leaves us 60-40&#x3D;20 bits of precision before the decimal point, and enough (roughly 10-20 bits) of precision after the decimal point. Since our intermediate primes are 40 bits (in fact, they are very close to 2^40), we can achieve scale stabilization as described above. *&#x2F; double scale &#x3D; pow(2.0, 40); SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; KeyGenerator keygen(context); auto secret_key &#x3D; keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); GaloisKeys galois_keys; keygen.create_galois_keys(galois_keys); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); CKKSEncoder encoder(context); size_t slot_count &#x3D; encoder.slot_count(); cout &lt;&lt; &quot;Number of slots: &quot; &lt;&lt; slot_count &lt;&lt; endl; vector&lt;double&gt; input; input.reserve(slot_count); &#x2F;&#x2F; 申请空间 double curr_point &#x3D; 0; &#x2F;&#x2F;static_cast&lt;double&gt; 将size_t 转成成double 在运算 double step_size &#x3D; 1.0 &#x2F; (static_cast&lt;double&gt;(slot_count) - 1); &#x2F;&#x2F; for (size_t i &#x3D; 0; i &lt; slot_count; i++) &#123; input.push_back(curr_point); curr_point +&#x3D; step_size; &#125; cout &lt;&lt; &quot;Input vector: &quot; &lt;&lt; endl; print_vector(input,3,7); &#x2F;&#x2F; 打印vector 前3 项后3项, 保留小数点后7位 cout &lt;&lt; &quot;Evaluating polynomial PI*x^3 + 0.4x + 1 ...&quot; &lt;&lt; endl; Plaintext plain_coeff3, plain_coeff1, plain_coeff0; &#x2F;&#x2F; 编码 encoder.encode(3.14159265, scale, plain_coeff3); encoder.encode(0.4, scale, plain_coeff1); encoder.encode(1.0, scale, plain_coeff0); Plaintext x_plain; print_line(__LINE__); cout &lt;&lt; &quot;Encode input vectors.&quot; &lt;&lt; endl; encoder.encode(input, scale, x_plain); &#x2F;&#x2F; 加密 Ciphertext x1_encrypted; encryptor.encrypt(x_plain, x1_encrypted); &#x2F;* * 为了计算x^3，我们首先计算x^2并重新线性化。然而，scale已经现在变成了2的80次方。 *&#x2F; &#x2F;&#x2F; x^2 Ciphertext x3_encrypted; print_line(__LINE__); cout &lt;&lt; &quot;Compute x^2 and relinearize:&quot; &lt;&lt; endl; evaluator.square(x1_encrypted, x3_encrypted); &#x2F;&#x2F; x3_encrypted &#x3D; x1_encrypted * x1_encrypted evaluator.relinearize_inplace(x3_encrypted, relin_keys); cout &lt;&lt; &quot; + Scale of x^2 before rescale: &quot; &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;* * 现在重新调节;rescale * 除了modulus switch 方法外，scale 减少的系数等于被转移的质数（40位质数） * 因此, 新的比例尺应该接近2^40。然而，scale !&#x3D; 2^40 :这是因为40位素数只是接近2^40。 * *&#x2F; print_line(__LINE__); cout &lt;&lt; &quot;Rescale x^2.&quot; &lt;&lt; endl; evaluator.rescale_to_next_inplace(x3_encrypted); &#x2F;&#x2F; 重新调整scale 规模 cout &lt;&lt; &quot; + Scale of x^2 after rescale: &quot; &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;* * 现在x3_encrypted与x1_encrypted处于不同的级别 * 这阻止了我们 x3_encrypted*x1_encrypted 来计算x^3 * 因此通过modulus switch 链 将x1_encrypted 切换到与x3_encrypted 同一级别, * 但又需要计算PI* x^3 所以 我们先计算 PI*x 然后调整scale 从2^80 -&gt; 2^40 * 然后在计算 Pi*x * x^2 * *&#x2F; print_line(__LINE__); &#x2F;&#x2F; PI * x cout &lt;&lt; &quot;Compute and rescale PI*x.&quot; &lt;&lt; endl; Ciphertext x1_encrypted_coeff3; evaluator.multiply_plain(x1_encrypted, plain_coeff3, x1_encrypted_coeff3);&#x2F;&#x2F; x1_encrypted_coeff3 &#x3D; x1_encrypted * plain_coeff3 cout &lt;&lt; &quot; + Scale of PI*x before rescale: &quot; &lt;&lt; log2(x1_encrypted_coeff3.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; evaluator.rescale_to_next_inplace(x1_encrypted_coeff3); cout &lt;&lt; &quot; + Scale of PI*x after rescale: &quot; &lt;&lt; log2(x1_encrypted_coeff3.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;&#x2F;(PI*x)*x^2. print_line(__LINE__); cout &lt;&lt; &quot;Compute, relinearize, and rescale (PI*x)*x^2.&quot; &lt;&lt; endl; evaluator.multiply_inplace(x3_encrypted, x1_encrypted_coeff3); evaluator.relinearize_inplace(x3_encrypted, relin_keys); cout &lt;&lt; &quot; + Scale of PI*x^3 before rescale: &quot; &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; evaluator.rescale_to_next_inplace(x3_encrypted); cout &lt;&lt; &quot; + Scale of PI*x^3 after rescale: &quot; &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;&#x2F; 0.4*x print_line(__LINE__); cout &lt;&lt; &quot;Compute and rescale 0.4*x.&quot; &lt;&lt; endl; evaluator.multiply_plain_inplace(x1_encrypted, plain_coeff1); cout &lt;&lt; &quot; + Scale of 0.4*x before rescale: &quot; &lt;&lt; log2(x1_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; evaluator.rescale_to_next_inplace(x1_encrypted); cout &lt;&lt; &quot; + Scale of 0.4*x after rescale: &quot; &lt;&lt; log2(x1_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;* * 现在我们希望计算这三项的和。然而,有一个严重的问题是: 这三个术语使用的加密参数都是不同是由于模数从缩放转换而来。 加密的加法和减法要求输入的刻度为相同， 并且加密参数(parms_id)匹配。如果有不匹配时，求值器将抛出异常。 *&#x2F; cout &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; &quot;Parameters used by all three terms are different.&quot; &lt;&lt; endl; cout &lt;&lt; &quot; + Modulus chain index for x3_encrypted: &quot; &lt;&lt; context.get_context_data(x3_encrypted.parms_id())-&gt;chain_index() &lt;&lt; endl; cout &lt;&lt; &quot; + Modulus chain index for x1_encrypted: &quot; &lt;&lt; context.get_context_data(x1_encrypted.parms_id())-&gt;chain_index() &lt;&lt; endl; cout &lt;&lt; &quot; + Modulus chain index for plain_coeff0: &quot; &lt;&lt; context.get_context_data(plain_coeff0.parms_id())-&gt;chain_index() &lt;&lt; endl; cout &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; &quot;The exact scales of all three terms are different:&quot; &lt;&lt; endl; ios old_fmt(nullptr); old_fmt.copyfmt(cout); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cout &lt;&lt; &quot; + Exact scale in PI*x^3: &quot; &lt;&lt; x3_encrypted.scale() &lt;&lt; endl; cout &lt;&lt; &quot; + Exact scale in 0.4*x: &quot; &lt;&lt; x1_encrypted.scale() &lt;&lt; endl; cout &lt;&lt; &quot; + Exact scale in 1: &quot; &lt;&lt; plain_coeff0.scale() &lt;&lt; endl; cout &lt;&lt; endl; cout.copyfmt(old_fmt); print_line(__LINE__); cout &lt;&lt; &quot;Normalize scales to 2^40.&quot; &lt;&lt; endl; x3_encrypted.scale() &#x3D; pow(2.0, 40); x1_encrypted.scale() &#x3D; pow(2.0, 40); &#x2F;* * 我们还有加密参数不匹配的问题。这是很容易的通过使用modulus switching (no rescaling) 来解决 *&#x2F; print_line(__LINE__); cout &lt;&lt; &quot;Normalize encryption parameters to the lowest level.&quot; &lt;&lt; endl; parms_id_type last_parms_id &#x3D; x3_encrypted.parms_id(); evaluator.mod_switch_to_inplace(x1_encrypted, last_parms_id); evaluator.mod_switch_to_inplace(plain_coeff0, last_parms_id); &#x2F;* 到现在这三种密文现在都是兼容的，可以进行add运算了 *&#x2F; print_line(__LINE__); cout &lt;&lt; &quot;Compute PI*x^3 + 0.4*x + 1.&quot; &lt;&lt; endl; Ciphertext encrypted_result; evaluator.add(x3_encrypted, x1_encrypted, encrypted_result); evaluator.add_plain_inplace(encrypted_result, plain_coeff0); Plaintext plain_result; print_line(__LINE__); cout &lt;&lt; &quot;Decrypt and decode PI*x^3 + 0.4x + 1.&quot; &lt;&lt; endl; cout &lt;&lt; &quot; + Expected result:&quot; &lt;&lt; endl; vector&lt;double&gt; true_result; for (size_t i &#x3D; 0; i &lt; input.size(); i++) &#123; double x &#x3D; input[i]; true_result.push_back((3.14159265 * x * x + 0.4) * x + 1); &#125; print_vector(true_result, 3, 7); &#x2F;* Decrypt, decode, and print the result. *&#x2F; decryptor.decrypt(encrypted_result, plain_result); vector&lt;double&gt; result; encoder.decode(plain_result, result); cout &lt;&lt; &quot; + Computed result ...... Correct.&quot; &lt;&lt; endl; print_vector(result, 3, 7); return; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"SEAL学习第五天-Rotaion","slug":"SEAL学习第五天-rotaion","date":"2021-08-11T14:01:40.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/1aba18cf/","link":"","permalink":"https://www.sizaif.com/posts/1aba18cf/","excerpt":"","text":"@auther by sizaif SEAL 学习第五天：rotaion @[toc] BFV /* * 旋转还需要另一种类型的特殊键 Galois keys */ GaloisKeys galois_keys; keygen.create_galois_keys(galois_keys); 两种基本操作 函数调用 参数 解释说明 evaluator.rotate_rows_inplace(encrypted_matrix, 3, galois_keys); Ciphertext，steps，GaloisKeys 将矩阵向左(steps 为正)循环移动3步 evaluator.rotate_columns_inplace(encrypted_matrix, galois_keys); Ciphertext，GaloisKeys 将矩阵行旋转 ==旋转不消耗任何噪音预算== 旋转列 steps 为正 向左移动 steps 为负 向右移动 print_line(__LINE__); cout &lt;&lt; \"Rotate rows 3 steps left.\" &lt;&lt; endl; evaluator.rotate_rows_inplace(encrypted_matrix, 3, galois_keys); Plaintext plain_result; cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); 旋转行 print_line(__LINE__); cout &lt;&lt; \"Rotate columns.\" &lt;&lt; endl; evaluator.rotate_columns_inplace(encrypted_matrix, galois_keys); cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); CKKS 函数调用 参数 解释说明 evaluator.rotate_vector(encrypted, 2, galois_keys, rotated); Ciphertext，steps，GaloisKeys，Ciphertext 将encrypted左(steps为正)循环移动后，输出到rotated code Ciphertext rotated; print_line(__LINE__); cout &lt;&lt; \"Rotate 2 steps left.\" &lt;&lt; endl; evaluator.rotate_vector(encrypted, 2, galois_keys, rotated); cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(rotated, plain); vector&lt;double> result; ckks_encoder.decode(plain, result); print_vector(result, 3, 7); print_line(__LINE__); cout &lt;&lt; \"Rotate 2 steps right.\" &lt;&lt; endl; evaluator.rotate_vector(encrypted, -2, galois_keys, rotated); cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(rotated, plain); ckks_encoder.decode(plain, result); print_vector(result, 3, 7); 源代码 code #include \"examples.h\" using namespace std; using namespace seal; void example_rotation_bfv() &#123; print_example_banner(\"Example: Rotation / Rotation in BFV\"); EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; KeyGenerator keygen(context); SecretKey secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_key; keygen.create_relin_keys(relin_key); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); BatchEncoder batch_encoder(context); size_t slot_count = batch_encoder.slot_count(); size_t row_size = slot_count / 2; cout &lt;&lt; \"Plaintext matrix row size: \" &lt;&lt; row_size &lt;&lt; endl; vector&lt;uint64_t> pod_matrix(slot_count, 0ULL); pod_matrix[0] = 0ULL; pod_matrix[1] = 1ULL; pod_matrix[2] = 2ULL; pod_matrix[3] = 3ULL; pod_matrix[row_size] = 4ULL; pod_matrix[row_size + 1] = 5ULL; pod_matrix[row_size + 2] = 6ULL; pod_matrix[row_size + 3] = 7ULL; cout &lt;&lt; \"Input plaintext matrix:\" &lt;&lt; endl; print_matrix(pod_matrix, row_size); Plaintext plain_matrix; print_line(__LINE__); cout &lt;&lt; \"Encode and encrypt.\" &lt;&lt; endl; batch_encoder.encode(pod_matrix, plain_matrix); Ciphertext encrypted_matrix; encryptor.encrypt(plain_matrix, encrypted_matrix); cout &lt;&lt; \" + Noise budget in fresh encryption: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; endl; /* * 旋转还需要另一种类型的特殊键 Galois keys */ GaloisKeys galois_keys; keygen.create_galois_keys(galois_keys); /* 现在将矩阵行向左循环移动3步, 解密、解码和打印 */ print_line(__LINE__); cout &lt;&lt; \"Rotate rows 3 steps left.\" &lt;&lt; endl; evaluator.rotate_rows_inplace(encrypted_matrix, 3, galois_keys); Plaintext plain_result; cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); /* 我们也可以旋转列, i.e., 交换行. */ print_line(__LINE__); cout &lt;&lt; \"Rotate columns.\" &lt;&lt; endl; evaluator.rotate_columns_inplace(encrypted_matrix, galois_keys); cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); /* 最后，我们将这些行向右旋转4步, decrypt, decode, and print. */ print_line(__LINE__); cout &lt;&lt; \"Rotate rows 4 steps right.\" &lt;&lt; endl; evaluator.rotate_rows_inplace(encrypted_matrix, -4, galois_keys); cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); &#125; void example_rotation_ckks() &#123; print_example_banner(\"Example: Rotation / Rotation in CKKS\"); /* Rotations in the CKKS scheme work very similarly to rotations in BFV. */ EncryptionParameters parms(scheme_type::ckks); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 40, 40, 40, 40, 40 &#125;)); SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; KeyGenerator keygen(context); SecretKey secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); GaloisKeys galois_keys; keygen.create_galois_keys(galois_keys); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); CKKSEncoder ckks_encoder(context); size_t slot_count = ckks_encoder.slot_count(); cout &lt;&lt; \"Number of slots: \" &lt;&lt; slot_count &lt;&lt; endl; vector&lt;double> input; input.reserve(slot_count); double curr_point = 0; double step_size = 1.0 / (static_cast&lt;double>(slot_count) - 1); for (size_t i = 0; i &lt; slot_count; i++, curr_point += step_size) &#123; input.push_back(curr_point); &#125; cout &lt;&lt; \"Input vector:\" &lt;&lt; endl; print_vector(input, 3, 7); auto scale = pow(2.0, 50); print_line(__LINE__); cout &lt;&lt; \"Encode and encrypt.\" &lt;&lt; endl; Plaintext plain; ckks_encoder.encode(input, scale, plain); Ciphertext encrypted; encryptor.encrypt(plain, encrypted); Ciphertext rotated; print_line(__LINE__); cout &lt;&lt; \"Rotate 2 steps left.\" &lt;&lt; endl; evaluator.rotate_vector(encrypted, 2, galois_keys, rotated); cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(rotated, plain); vector&lt;double> result; ckks_encoder.decode(plain, result); print_vector(result, 3, 7); print_line(__LINE__); cout &lt;&lt; \"Rotate 2 steps right.\" &lt;&lt; endl; evaluator.rotate_vector(encrypted, -2, galois_keys, rotated); cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(rotated, plain); ckks_encoder.decode(plain, result); print_vector(result, 3, 7); &#125; void example_rotation() &#123; print_example_banner(\"Example: Rotation\"); /* Run all rotation examples. */ example_rotation_bfv(); example_rotation_ckks(); &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"SEAL学习第二天-Encoder处理","slug":"SEAL学习第二天-encoder处理","date":"2021-08-11T14:01:38.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/286653df/","link":"","permalink":"https://www.sizaif.com/posts/286653df/","excerpt":"","text":"@auther by sizaif SEAL 学习第二天 encoders @[toc] ​ BatchEncoder [BatchEncoder] (For BFV scheme only) 在“1 _bfv_basics。我们展示了如何使用BFV方案执行一个非常简单的计算。计算以明文模为参数，仅利用一个BFV明文多项式的系数。这种方法有两个值得注意的问题: (1)实际应用中一般采用整数或实数算法，而不是模运算; (2)我们只使用了明文多项式的一个系数。这是非常浪费的，因为明文多项式很大，而且在任何情况下都将全部加密。 对于(1) 若增大plain_modulus ，虽然可行，但同时增加了 噪声预算的消耗(当噪声预算消耗到0时，计算结果是不正确的，所以我们要随时关注噪声预算)， 将数据编码为明文(plaintext) 进行encoder 允许更多的计算而没有数据类型溢出，还可以允许使用完整的明文多项式。 调用 参数 解释说明 BatchEncoder batch_encoder(context); SEALContext 声明一个批处理类 batch_encoder.encode(pod_matrix, plain_matrix); VectorPlaintext 将一个vector批量编码成成明文Plaintext batch_encoder.decode(plain_matrix, pod_result); Plaintext,Vector 将一个明文Plaintext处理解码成vector /* 设N为poly_modulus_degree，T为plain_modulus。批处理允许BFV明文多项式被视为2×(N/2)矩阵，每个元素都是一个模T整数。在矩阵视图中，加密操作在加密矩阵上逐个执行element-wise，允许用户在完全向量化计算中获得几个数量级的速度提升。因此，除了最简单的计算之外，批处理应该是首选的方法。使用BFV时，如果使用得当，实现的性能将超过使用IntegerEncoder完成的任何工作。 */ EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); 要启用批处理，我们需要将plain_modulus设置为一个素数，等于1模2* poly_modulus_degrees。Microsoft SEAL提供了一个助手 找到这样一个质数的方法。在这个例子中，我们创建了一个20位素数支持批处理。 通过CoeffModulus::BFVDefault(poly_modulus_degree) 产出一个素数 parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); SEALContext context(parms);// 声明完context后类，后就可以开始使用了 // 检测是否成功启用 auto qualifiers = context.first_context_data()->qualifiers(); cout &lt;&lt; \"Batching enabled: \" &lt;&lt; boolalpha &lt;&lt; qualifiers.using_batching &lt;&lt; endl; 批处理‘slots’的总数等于poly_modulus_degree, N，这些’slots’被组织成2×(N/2)矩阵，可以被加密和计算。每个slot含一个整数 MOD plain_modulus。 2×(N/2) size_t slot_count = batch_encoder.slot_count(); size_t row_size = slot_count / 2; cout &lt;&lt; \"Plaintext matrix slot_count size: \" &lt;&lt; slot_count &lt;&lt; endl; cout &lt;&lt; \"Plaintext matrix row size: \" &lt;&lt; row_size &lt;&lt; endl; /* * 声明一个vector，长度为slot_count， 默为 0 * 形式为： 2*(slot_count/2) 的二维矩阵 * [0...............row_size] * [row_size......slot_count] */ vector&lt;uint64_t> pod_matrix(slot_count, 0ULL); //赋值 pod_matrix[0] = 0ULL; pod_matrix[1] = 1ULL; pod_matrix[2] = 2ULL; pod_matrix[3] = 3ULL; pod_matrix[row_size] = 4ULL; pod_matrix[row_size + 1] = 5ULL; pod_matrix[row_size + 2] = 6ULL; pod_matrix[row_size + 3] = 7ULL; cout &lt;&lt; \"Input plaintext matrix:\" &lt;&lt; endl; /* * 这个print_matrix不会打印矩阵的每一列,只打印每一行的前5个和最后5个 * [ 0, 1, 2, 3, 0, 0, ..., 0 ] * [ 4, 5, 6, 7, 0, 0, ..., 0 ] */ print_matrix(pod_matrix, row_size); encode 从给定的矩阵创建一个明文,&quot;批量处理&quot;一个给定的矩阵 Mod (plaintext modulus) 然后将结果存储到 plaintext类，输入的vecotr的大小 &lt;= 多项式模的次数(poly_modulus_degree) batch_encoder.encode(pod_matrix, plain_matrix); 简单样例验证 生成矩阵A和矩阵B 矩阵A形式: [ 0, 1, 2, 3, 0, 0, ..., 0 ] [ 4, 5, 6, 7, 0, 0, ..., 0 ] 矩阵B形式： [ 1, 2, 1, 2, 1, 2, ..., 2 ] [ 1, 2, 1, 2, 1, 2, ..., 2 ] 求 (A+B)^2 并验证结果 code vector&lt;uint64_t> pod_matrix(slot_count, 0ULL); // pod_matrix[0] = 0ULL; pod_matrix[1] = 1ULL; pod_matrix[2] = 2ULL; pod_matrix[3] = 3ULL; pod_matrix[row_size] = 4ULL; pod_matrix[row_size + 1] = 5ULL; pod_matrix[row_size + 2] = 6ULL; pod_matrix[row_size + 3] = 7ULL; /* 首先，我们使用BatchEncoder将矩阵编码成一个明文多项式。 */ Plaintext plain_matrix; print_line(__LINE__); cout &lt;&lt; \"Encode plaintext matrix:\" &lt;&lt; endl; /* 从给定的矩阵创建一个明文,\"批量处理\"一个给定的矩阵 Mod (plaintext modulus) 然后将结果存储到 plaintext类，输入的vecotr的大小 &lt;= 多项式模的次数(poly_modulus_degree) */ batch_encoder.encode(pod_matrix, plain_matrix); /* 接下来，我们加密已编码的明文。 */ Ciphertext encrypted_matrix; print_line(__LINE__); cout &lt;&lt; \"Encrypt plain_matrix to encrypted_matrix.\" &lt;&lt; endl; encryptor.encrypt(plain_matrix, encrypted_matrix); cout &lt;&lt; \" + Noise budget in encrypted_matrix: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 对密文的操作导致在所有8192(poly_modulus_degree)个slot(矩阵元素)中同时执行同态操作。为了说明这一点，我们构造了另一个明文矩阵： [ 1, 2, 1, 2, 1, 2, ..., 2 ] [ 1, 2, 1, 2, 1, 2, ..., 2 ] 然后把它编码成明文。 */ vector&lt;uint64_t> pod_matrix2; for (size_t i = 0; i &lt; slot_count; i++) &#123; pod_matrix2.push_back((i &amp; size_t(0x1)) + 1); &#125; Plaintext plain_matrix2; batch_encoder.encode(pod_matrix2, plain_matrix2); cout &lt;&lt; endl; cout &lt;&lt; \"Second input plaintext matrix:\" &lt;&lt; endl; print_matrix(pod_matrix2, row_size); /* 现在我们将第二个(明文)矩阵添加到加密矩阵中，并求sum^2。 */ print_line(__LINE__); cout &lt;&lt; \"Sum, square, and relinearize.\" &lt;&lt; endl; evaluator.add_plain_inplace(encrypted_matrix, plain_matrix2); // encrypted_matrix = ncrypted_matrix + plain_matrix2 evaluator.square_inplace(encrypted_matrix);// encrypted_matrix = encrypted_matrix * encrypted_matrix; evaluator.relinearize_inplace(encrypted_matrix, relin_keys); // 序列化 /* 查看剩余噪音预算 */ cout &lt;&lt; \" + Noise budget in result: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; /* 我们将加密的 数据进行解密并解码并验证结果 */ Plaintext plain_result; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode result.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_result); print_matrix(pod_result, row_size); // 验证结果 总结： 当所需的加密计算高度可并行化时，批处理允许我们有效地使用全明文多项式。但是，它并没有解决这个文件开头提到的另一个问题:每个槽只包含一个整数模的明文模量，除非明文模量非常大，否则我们可以很快遇到数据类型溢出，并在需要整数计算时会得到意外的结果。注意，溢出并不能以加密的形式检测到。CKKS方案(以及CKKSEncoder)解决了数据类型溢出问题，但代价是只产生近似的结果。 CKKSEncoder [CKKSEncoder] (For CKKS scheme only) 实数或复数形式 (1) CKKS不使用plain_modulus加密参数; (2) 当使用CKKS方案时,选择coeff_modulus是非常重要的 声明方式 同bfv一致， EncryptionParameters parms(scheme_type::ckks);// 使用ckks size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 40, 40, 40, 40, 40 &#125;));// 产生5个40位的素数的数组 CKKS 中 slot数目 = poly_modulus_degree / 2 每个slot编码为一个实数或复数。 而在BFV中 slot = poly_modulus_degree 并且被处理成 一个2X(N/2)的矩阵 size_t slot_count &#x3D; encoder.slot_count(); 要创建CKKS纯文本，我们需要一个特殊的编码器: BatchEncoder不适用于CKKS CKKSEncoder 的方式是将实数或复数的向量编码为Plaintext objects 然后对object就可以加密了 函数调用 参数类型 解释说明 CKKSEncoder encoder(context); SEALContext 声明一个CKKS编码器 encoder.encode(input, scale, plain); Vector,scale,Plaintext 将vector 按照scale定义的编码精度的尺度参数 编码成 Plaintext encoder.decode(plain, output); Plaintext，Vector 将明文Plaintext解密成Vector 编码与解码 Plaintext plain; double scale = pow(2.0, 30); print_line(__LINE__); cout &lt;&lt; \"Encode input vector. and the size of scale: \"&lt;&lt; scale &lt;&lt; endl; encoder.encode(input, scale, plain); // 将vector 按照scale定义的编码精度的尺度参数 编码成 Plaintext /* 我们可以立即解码以检查编码的正确性。 */ vector&lt;double> output; cout &lt;&lt; \" + Decode input vector ...... Correct.\" &lt;&lt; endl; encoder.decode(plain, output); // 解码 print_vector(output); 做个简单样例验证， 将输入的vector加密后 求平方 并 序列化后 解码验证结果 code /* The vector is encrypted the same was as in BFV. 简单样例: 将输入的 vector 加密后 求平方 并 序列化 */ Ciphertext encrypted; print_line(__LINE__); cout &lt;&lt; \"Encrypt input vector, square, and relinearize.\" &lt;&lt; endl; encryptor.encrypt(plain, encrypted); // 加密 Plaintext -> Ciphertext // 计算 evaluator.square_inplace(encrypted); // encrypted = encrypted * encrypted evaluator.relinearize_inplace(encrypted, relin_keys); // 序列化 cout &lt;&lt; \" + Scale in squared input: \" &lt;&lt; encrypted.scale() &lt;&lt; \" (\" &lt;&lt; log2(encrypted.scale()) &lt;&lt; \" bits)\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode.\" &lt;&lt; endl; decryptor.decrypt(encrypted, plain); // 解密 encoder.decode(plain, output); // 解码 cout &lt;&lt; \" + Result vector ...... Correct.\" &lt;&lt; endl; print_vector(output); // 结果 验证结果正确 全部源代码 code #include \"examples.h\" using namespace std; using namespace seal; void example_batch_encoder() &#123; print_example_banner(\"Example: Encoders / Batch Encoder\"); /* [BatchEncoder] (For BFV scheme only) Let N 表示 poly_modulus_degree ; T 表示 plain_modulus. Batching allows the BFV plaintext polynomials to be viewed as 2-by-(N/2) matrices, with each element an integer modulo T. 在矩阵视图中，加密操作法案在加密的矩阵上, allowing the user to obtain speeds-ups of several orders of magnitude in fully vectorizable computations. Thus, in all but the simplest computations, batching should be the preferred method to use with BFV, and when used properly will result in implementations outperforming anything done without batching. */ EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); //PlainModulus::Batching(poly_modulus_degree, 20) 产生20位的素数 SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; // 检测是否成功启用 auto qualifiers = context.first_context_data()->qualifiers(); cout &lt;&lt; \"Batching enabled: \" &lt;&lt; boolalpha &lt;&lt; qualifiers.using_batching &lt;&lt; endl; KeyGenerator keygen(context); SecretKey secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); BatchEncoder batch_encoder(context); size_t slot_count = batch_encoder.slot_count(); size_t row_size = slot_count / 2; cout &lt;&lt; \"Plaintext matrix slot_count size: \" &lt;&lt; slot_count &lt;&lt; endl; cout &lt;&lt; \"Plaintext matrix row size: \" &lt;&lt; row_size &lt;&lt; endl; /* * 声明一个vector，长度为slot_count， 默为 0 * 形式为： 2*(slot_count/2) 的二维矩阵 * [0...............row_size] * [row_size......slot_count] */ vector&lt;uint64_t> pod_matrix(slot_count, 0ULL); // pod_matrix[0] = 0ULL; pod_matrix[1] = 1ULL; pod_matrix[2] = 2ULL; pod_matrix[3] = 3ULL; pod_matrix[row_size] = 4ULL; pod_matrix[row_size + 1] = 5ULL; pod_matrix[row_size + 2] = 6ULL; pod_matrix[row_size + 3] = 7ULL; cout &lt;&lt; \"Input plaintext matrix:\" &lt;&lt; endl; /* * 这个print_matrix不会打印矩阵的每一列,只打印每一行的前5个和最后5个 * [ 0, 1, 2, 3, 0, 0, ..., 0 ] * [ 4, 5, 6, 7, 0, 0, ..., 0 ] */ print_matrix(pod_matrix, row_size); /* 首先，我们使用BatchEncoder将矩阵编码成一个明文多项式。 */ Plaintext plain_matrix; print_line(__LINE__); cout &lt;&lt; \"Encode plaintext matrix:\" &lt;&lt; endl; /* 从给定的矩阵创建一个明文,\"批量处理\"一个给定的矩阵 Mod (plaintext modulus) 然后将结果存储到 plaintext类，输入的vecotr的大小 &lt;= 多项式模的次数(poly_modulus_degree) */ batch_encoder.encode(pod_matrix, plain_matrix); /* 我们可以立即解码以验证编码的正确性. 但注意，还未进行加密或解密 */ vector&lt;uint64_t> pod_result; cout &lt;&lt; \" + Decode plaintext matrix ...... Correct.\" &lt;&lt; endl; batch_encoder.decode(plain_matrix, pod_result); print_matrix(pod_result, row_size); /* 接下来，我们加密已编码的明文。 */ Ciphertext encrypted_matrix; print_line(__LINE__); cout &lt;&lt; \"Encrypt plain_matrix to encrypted_matrix.\" &lt;&lt; endl; encryptor.encrypt(plain_matrix, encrypted_matrix); cout &lt;&lt; \" + Noise budget in encrypted_matrix: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 对密文的操作导致在所有8192(poly_modulus_degree)个slot(矩阵元素)中同时执行同态操作。为了说明这一点，我们构造了另一个明文矩阵： [ 1, 2, 1, 2, 1, 2, ..., 2 ] [ 1, 2, 1, 2, 1, 2, ..., 2 ] 然后把它编码成明文。 */ vector&lt;uint64_t> pod_matrix2; for (size_t i = 0; i &lt; slot_count; i++) &#123; pod_matrix2.push_back((i &amp; size_t(0x1)) + 1); &#125; Plaintext plain_matrix2; batch_encoder.encode(pod_matrix2, plain_matrix2); cout &lt;&lt; endl; cout &lt;&lt; \"Second input plaintext matrix:\" &lt;&lt; endl; print_matrix(pod_matrix2, row_size); /* 现在我们将第二个(明文)矩阵添加到加密矩阵中，并求sum^2。 */ print_line(__LINE__); cout &lt;&lt; \"Sum, square, and relinearize.\" &lt;&lt; endl; evaluator.add_plain_inplace(encrypted_matrix, plain_matrix2); // encrypted_matrix = ncrypted_matrix + plain_matrix2 evaluator.square_inplace(encrypted_matrix);// encrypted_matrix = encrypted_matrix * encrypted_matrix; evaluator.relinearize_inplace(encrypted_matrix, relin_keys); // 序列化 /* 查看剩余噪音预算 */ cout &lt;&lt; \" + Noise budget in result: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; /* 我们将加密的 数据进行解密并解码并验证结果 */ Plaintext plain_result; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode result.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_result); cout &lt;&lt; \" + Result plaintext matrix ...... Correct.\" &lt;&lt; endl; print_matrix(pod_result, row_size); /* 当所需的加密计算高度可并行化时，批处理允许我们有效地使用全明文多项式。 但是，它并没有解决这个文件开头提到的另一个问题: 每个槽只包含一个整数模的明文模量，除非明文模量非常大， 否则我们可以很快遇到数据类型溢出，并在需要整数计算时会得到意外的结果。 注意，溢出并不能以加密的形式检测到。CKKS方案(以及CKKSEncoder)解决了数据类型溢出问题， 但代价是只产生近似的结果。 */ &#125; void example_ckks_encoder() &#123; print_example_banner(\"Example: Encoders / CKKS Encoder\"); EncryptionParameters parms(scheme_type::ckks);// 使用ckks size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 40, 40, 40, 40, 40 &#125;));// 产生5个40位的素数的数组 // 同BFV一致，声明 SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; // 密钥产生的方式和 bfv 是一样的 KeyGenerator keygen(context); auto secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); // 加密器，解密器，计算器 Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); /* * 要创建CKKS纯文本，我们需要一个特殊的编码器: BatchEncoder不适用于CKKS CKKSEncoder 的方式是将实数或复数的向量编码为Plaintext objects 然后对object就可以加密了 看起来很像BatchEncoder为BFV方案所做的，但理论上它的背后是完全不同的。 */ CKKSEncoder encoder(context); /* * CKKS 中 slot数目 = poly_modulus_degree / 2 每个slot编码为一个实数或复数。 * 而在BFV中 slot = poly_modulus_degree 并且被处理成 一个2X(N/2)的矩阵 */ size_t slot_count = encoder.slot_count(); cout &lt;&lt; \"Number of slots: \" &lt;&lt; slot_count &lt;&lt; endl; vector&lt;double> input&#123; 0.0, 1.1, 2.2, 3.3 &#125;; cout &lt;&lt; \"Input vector: \" &lt;&lt; endl; print_vector(input); /* * 现在我们用CKKSEncoder进行编码。输入的浮点系数将通过参数“scale”放大 * 这是必要的，因为即使是在纯文本元素的CKKS方案,基本上是多项式整数系数。 * 在CKKS中，消息是存 MOD coeff_modulus,(而在BFV中是 存储 MOD plain_modulus) * 因此，缩放后的消息不能太接近总大小coeff_modulus。 * */ Plaintext plain; double scale = pow(2.0, 30); print_line(__LINE__); cout &lt;&lt; \"Encode input vector. and the size of scale: \"&lt;&lt; scale &lt;&lt; endl; encoder.encode(input, scale, plain); // 将vector 按照scale定义的编码精度的尺度参数 编码成 Plaintext /* 我们可以立即解码以检查编码的正确性。 */ vector&lt;double> output; cout &lt;&lt; \" + Decode input vector ...... Correct.\" &lt;&lt; endl; encoder.decode(plain, output); // 解码 print_vector(output); /* The vector is encrypted the same was as in BFV. 简单样例: 将输入的 vector 加密后 求平方 并 序列化 */ Ciphertext encrypted; print_line(__LINE__); cout &lt;&lt; \"Encrypt input vector, square, and relinearize.\" &lt;&lt; endl; encryptor.encrypt(plain, encrypted); // 加密 Plaintext -> Ciphertext // 计算 evaluator.square_inplace(encrypted); // encrypted = encrypted * encrypted evaluator.relinearize_inplace(encrypted, relin_keys); // 序列化 cout &lt;&lt; \" + Scale in squared input: \" &lt;&lt; encrypted.scale() &lt;&lt; \" (\" &lt;&lt; log2(encrypted.scale()) &lt;&lt; \" bits)\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode.\" &lt;&lt; endl; decryptor.decrypt(encrypted, plain); // 解密 encoder.decode(plain, output); // 解码 cout &lt;&lt; \" + Result vector ...... Correct.\" &lt;&lt; endl; print_vector(output); // 结果 /* * CKKS方案允许减少加密计算之间的规模。这是CKKS非常强大和关键的基本特性灵活。 * 我们将在' 3_levels中详细讨论它。cpp'和稍后“4 _ckks_basics.cpp”。 */ &#125; void example_encoders() &#123; print_example_banner(\"Example: Encoders\"); /* Run all encoder examples. */ //example_batch_encoder(); example_ckks_encoder(); &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"SEAL学习第三天-Levels","slug":"SEAL学习第三天-levels","date":"2021-08-11T14:01:36.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/51e56618/","link":"","permalink":"https://www.sizaif.com/posts/51e56618/","excerpt":"","text":"@auther by sizaif SEAL 学习第三天：levels @[toc] 简介 今天学习描述在BFV和CKKS和在Microsoft SEAL中表示它们的相关对象 在Microsoft SEAL中，一组加密参数(不包括随机数生成器)由参数的256位散列唯一标识。这个散列称为’ parms_id’，可以在任何时候方便地访问和打印。一旦任何参数发生变化，散列就会发生变化。 当从给定的EncryptionParameters实例创建SEALContext时，微软SEAL会自动创建一个所谓的“模数切换链”，它是从原始集合衍生出来的其他加密参数链。模量交换链中的参数除系数模量沿链向下逐渐减小外，其余参数均与原参数相同。更准确地说，链中的每个参数集都试图从前一个集合中移除最后一个系数模素数;这会一直持续到参数集不再有效为止。(例如:plain_modulus大于剩余的coeff_modulus)。很容易遍历整个链并访问所有参数集。此外，链中设置的每个参数都有一个“链索引”，指示其在链中的位置，因此最后一组参数的索引为0。我们说，一组加密参数，或者一个携带这些加密参数的对象，在链中的级别高于另一组参数，如果它的链索引较大，也就是说，它在链中较早。 链中的每一组参数都涉及到执行的唯一预计算。当创建SEALContext并存储在SEALContext::ContextData中时对象。这个链基本上是SEALContext::ContextData的链表对象，并且可以在任何时候通过SEALContext轻松访问。每一个节点可以通过其特定加密参数的parms_id来标识(poly_modulus_degree保持不变，coeff_modulus变化)。 EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree &#x3D; 8192; parms.set_poly_modulus_degree(poly_modulus_degree); 在这个例子中，我们使用了一个自定义的coeff_modulus， c由5个质数组成的50, 30, 30, 50, 50 位素数. CoeffModulus::MaxBitCount(poly_modulus_degree) returns 218 (greater than 50+30+30+50+50=210). 由于模量切换链，5个素数的顺序是重要的。最后一个质数有特殊的含义，我们称之为“特殊质数”。 因此,第一个参数设置在模切换链只有一个涉及到特殊的prime 创建所有密钥对象，如SecretKey在这个最高的层次。所有数据对象，如密文，只能在较低的水平。 这个特殊质数应该与在coeff_modulus中的其他素数的最大质数一样大 在SEAL中有一个重要的level的概念，根据示例代码里的注释，可以理解为SEAL根据默认的参数创建了一个modulus switching chain ，在同一个链上的加密实例除了coefficient modulus 其他都相同。下面示例代码给的一个解释： special prime +---------+ | v coeff_modulus: &#123; 50, 30, 30, 50, 50 &#125; +---+ Level 4 (all keys; `key level') | | coeff_modulus: &#123; 50, 30, 30, 50 &#125; +---+ Level 3 (highest `data level') | | coeff_modulus: &#123; 50, 30, 30 &#125; +---+ Level 2 | | coeff_modulus: &#123; 50, 30 &#125; +---+ Level 1 | | coeff_modulus: &#123; 50 &#125; +---+ Level 0 (lowest level) 有方便的访问方法 SEALContext::ContextData SEALContext::key_context_data(): access to key level ContextData SEALContext::first_context_data(): access to highest data level ContextData SEALContext::last_context_data(): access to lowest level ContextData 这是通过set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 50, 30, 30, 50, 50 &#125;)) 方法设置的 打印信息查看 验证keys级别。 KeyGenerator keygen(context); auto secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); print_line(__LINE__); cout &lt;&lt; \"Print the parameter IDs of generated elements.\" &lt;&lt; endl; cout &lt;&lt; \" + public_key: \" &lt;&lt; public_key.parms_id() &lt;&lt; endl; cout &lt;&lt; \" + secret_key: \" &lt;&lt; secret_key.parms_id() &lt;&lt; endl; cout &lt;&lt; \" + relin_keys: \" &lt;&lt; relin_keys.parms_id() &lt;&lt; endl; 验证密文Ciphertext级别 Plaintext plain(\"1x^3 + 2x^2 + 3x^1 + 4\"); Ciphertext encrypted; encryptor.encrypt(plain, encrypted); cout &lt;&lt; \" + plain: \" &lt;&lt; plain.parms_id() &lt;&lt; \" (not set in BFV)\" &lt;&lt; endl; cout &lt;&lt; \" + encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl &lt;&lt; endl; “Modulus switching” “Modulus switching”是一种降低密文参数的技术在链中 Evaluator::mod_switch_to_next总是切换到 下一级链，而Evaluator::mod_switch_to切换到在对应于给定parms_id的链上设置的参数。然而,它 是不可能在链条向上切换的。 验证: code print_line(__LINE__); cout &lt;&lt; \"Perform modulus switching on encrypted and print.\" &lt;&lt; endl; context_data = context.first_context_data(); cout &lt;&lt; \"---->\"; while (context_data->next_context_data()) &#123; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id of encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl; cout &lt;&lt; \" Noise budget at this level: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; evaluator.mod_switch_to_next_inplace(encrypted); context_data = context_data->next_context_data(); &#125; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id of encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl; cout &lt;&lt; \" Noise budget at this level: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; cout &lt;&lt; \" End of chain reached\" &lt;&lt; endl &lt;&lt; endl; 源代码 code #include \"examples.h\" #include \"seal/seal.h\" using namespace std; using namespace seal; void example_levels() &#123; print_example_banner(\"Example: Levels\"); EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); /* 在这个例子中，我们使用了一个自定义的coeff_modulus， c由5个质数组成的50, 30, 30, 50, 50 位素数. CoeffModulus::MaxBitCount(poly_modulus_degree) returns 218 (greater than 50+30+30+50+50=210). 由于模量切换链，5个素数的顺序是重要的。最后一个质数有特殊的含义，我们称之为“特殊质数”。 因此,第一个参数设置在模切换链只有一个涉及到特殊的prime 创建所有密钥对象，如SecretKey在这个最高的层次。所有数据对象，如密文，只能在较低的水平。 这个特殊质数应该与在coeff_modulus中的其他素数的最大质数一样大 special prime +---------+ | v coeff_modulus: &#123; 50, 30, 30, 50, 50 &#125; +---+ Level 4 (all keys; `key level') | | coeff_modulus: &#123; 50, 30, 30, 50 &#125; +---+ Level 3 (highest `data level') | | coeff_modulus: &#123; 50, 30, 30 &#125; +---+ Level 2 | | coeff_modulus: &#123; 50, 30 &#125; +---+ Level 1 | | coeff_modulus: &#123; 50 &#125; +---+ Level 0 (lowest level) */ parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 50, 30, 30, 50, 50 &#125;)); /* 在这个例子中，plain_modulus没有发挥太大的作用;我们选择一些合理的价值 */ parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; /* * 有方便的访问方法 SEALContext::ContextData SEALContext::key_context_data(): access to key level ContextData SEALContext::first_context_data(): access to highest data level ContextData SEALContext::last_context_data(): access to lowest level ContextData */ //遍历该链并打印每组参数的parms_id。 //首先打印关键级别参数信息 print_line(__LINE__); cout &lt;&lt; \"Print the modulus switching chain.\" &lt;&lt; endl; auto context_data = context.key_context_data(); cout &lt;&lt; \"----> Level (chain index): \" &lt;&lt; context_data->chain_index(); cout &lt;&lt; \" ...... key_context_data()\" &lt;&lt; endl; cout &lt;&lt; \" parms_id: \" &lt;&lt; context_data->parms_id() &lt;&lt; endl; cout &lt;&lt; \" coeff_modulus primes: \"; cout &lt;&lt; hex; for (const auto&amp; prime : context_data->parms().coeff_modulus()) &#123; cout &lt;&lt; prime.value() &lt;&lt; \" \"; &#125; cout &lt;&lt; dec &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; //接下来迭代其余的 context_data = context.first_context_data(); while (context_data) &#123; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index(); if (context_data->parms_id() == context.first_parms_id()) &#123; cout &lt;&lt; \" ...... first_context_data()\" &lt;&lt; endl; &#125; else if (context_data->parms_id() == context.last_parms_id()) &#123; cout &lt;&lt; \" ...... last_context_data()\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; endl; &#125; cout &lt;&lt; \" parms_id: \" &lt;&lt; context_data->parms_id() &lt;&lt; endl; cout &lt;&lt; \" coeff_modulus primes: \"; cout &lt;&lt; hex; // 16进制输出 for (const auto&amp; prime : context_data->parms().coeff_modulus()) &#123; cout &lt;&lt; prime.value() &lt;&lt; \" \"; &#125; cout &lt;&lt; dec &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; /* Step forward in the chain. */ context_data = context_data->next_context_data(); &#125; cout &lt;&lt; \" End of chain reached\" &lt;&lt; endl &lt;&lt; endl; //我们创建一些keys并检查它们是否确实出现在最高层。 KeyGenerator keygen(context); auto secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); print_line(__LINE__); cout &lt;&lt; \"Print the parameter IDs of generated elements.\" &lt;&lt; endl; cout &lt;&lt; \" + public_key: \" &lt;&lt; public_key.parms_id() &lt;&lt; endl; cout &lt;&lt; \" + secret_key: \" &lt;&lt; secret_key.parms_id() &lt;&lt; endl; cout &lt;&lt; \" + relin_keys: \" &lt;&lt; relin_keys.parms_id() &lt;&lt; endl; Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); /* * 在BFV方案中，明文不携带parms_id，而密文携带parms_id。 请注意新加密的密文如何在最高数据级别。 */ Plaintext plain(\"1x^3 + 2x^2 + 3x^1 + 4\"); Ciphertext encrypted; encryptor.encrypt(plain, encrypted); cout &lt;&lt; \" + plain: \" &lt;&lt; plain.parms_id() &lt;&lt; \" (not set in BFV)\" &lt;&lt; endl; cout &lt;&lt; \" + encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl &lt;&lt; endl; /* * “Modulus switching”是一种降低密文参数的技术在链中 Evaluator::mod_switch_to_next总是切换到 下一级链，而Evaluator::mod_switch_to切换到在对应于给定parms_id的链上设置的参数。然而,它 是不可能在链条向上切换的。 */ print_line(__LINE__); cout &lt;&lt; \"Perform modulus switching on encrypted and print.\" &lt;&lt; endl; context_data = context.first_context_data(); cout &lt;&lt; \"---->\"; while (context_data->next_context_data()) &#123; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id of encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl; cout &lt;&lt; \" Noise budget at this level: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; evaluator.mod_switch_to_next_inplace(encrypted); context_data = context_data->next_context_data(); &#125; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id of encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl; cout &lt;&lt; \" Noise budget at this level: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; cout &lt;&lt; \" End of chain reached\" &lt;&lt; endl &lt;&lt; endl; /* 在这一点上，很难看到这样做有任何好处:我们损失了巨大噪音预算(即计算能力)没有任何回报。 解密仍能工作。 然而，有一个隐藏的好处:密文的大小取决于系数模数中素数数的线性关系。 因此,如果有不需要或不打算对给定的对象执行任何进一步的计算密文， 我们不妨把它切换到最小的(最后的)集合参数，然后将其发送回密钥持有者解密。 此外，噪音损失预算实际上根本不是一个问题 */ print_line(__LINE__); cout &lt;&lt; \"Decrypt still works after modulus switching.\" &lt;&lt; endl; decryptor.decrypt(encrypted, plain); cout &lt;&lt; \" + Decryption of encrypted: \" &lt;&lt; plain.to_string(); cout &lt;&lt; \" ...... Correct.\" &lt;&lt; endl &lt;&lt; endl; /* * 因此,如果有不需要或不打算对给定的对象执行任何进一步的计算密文， * 我们不妨把它切换到最小的(最后的)集合参数，然后将其发送回密钥持有者解密。 * 此外，噪音损失预算实际上根本不是一个问题 * 首先，我们重新创建原始密文并执行一些计算。 * */ cout &lt;&lt; \"Computation is more efficient with modulus switching.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Compute the 8th power.\" &lt;&lt; endl; encryptor.encrypt(plain, encrypted); cout &lt;&lt; \" + Noise budget fresh: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; evaluator.square_inplace(encrypted); evaluator.relinearize_inplace(encrypted, relin_keys); cout &lt;&lt; \" + Noise budget of the 2nd power: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; evaluator.square_inplace(encrypted); evaluator.relinearize_inplace(encrypted, relin_keys); cout &lt;&lt; \" + Noise budget of the 4th power: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; /* 在这种情况下 modulus switching 对噪声预算完全没有影响。 */ evaluator.mod_switch_to_next_inplace(encrypted); cout &lt;&lt; \" + Noise budget after modulus switching: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 这意味着降低一些系数是没有任何害处的在做了足够的计算之后。 * 在某些情况下，人们可能稍微早一点切换到一个较低的级别，实际上牺牲了一些过程中的噪音预算 * 以用更小的参数来获得计算性能 * 我们从打印出来的数据中可以看到，当噪音预算降到25位左右时，下一个modulus switch应该理想地完成。 */ evaluator.square_inplace(encrypted); evaluator.relinearize_inplace(encrypted, relin_keys); cout &lt;&lt; \" + Noise budget of the 8th power: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; evaluator.mod_switch_to_next_inplace(encrypted); cout &lt;&lt; \" + Noise budget after modulus switching: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 此时，密文仍能正确解密，体积很小，而且计算效率也尽可能高。 * 注意，解密器可以用来解密在modulus switching链中任意层次一个密文 */ decryptor.decrypt(encrypted, plain); cout &lt;&lt; \" + Decryption of the 8th power (hexadecimal) ...... Correct.\" &lt;&lt; endl; cout &lt;&lt; \" \" &lt;&lt; plain.to_string() &lt;&lt; endl &lt;&lt; endl; /* * 在BFV中不需要modulus switching * 在某些情况下，用户可能会不想创建modulus switching链， * 只实现最高的两个level（key level and highest data level) * 这可以通过将bool值' false'传递给SEALContext的构造函数来实现。 */ context = SEALContext(parms, false); /* * 我们可以检查确实只创建了模数交换链最高的两层 */ cout &lt;&lt; \"Optionally disable modulus switching chain expansion.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Print the modulus switching chain.\" &lt;&lt; endl; cout &lt;&lt; \"---->\"; for (context_data = context.key_context_data(); context_data; context_data = context_data->next_context_data()) &#123; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id: \" &lt;&lt; context_data->parms_id() &lt;&lt; endl; cout &lt;&lt; \" coeff_modulus primes: \"; cout &lt;&lt; hex; for (const auto&amp; prime : context_data->parms().coeff_modulus()) &#123; cout &lt;&lt; prime.value() &lt;&lt; \" \"; &#125; cout &lt;&lt; dec &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; &#125; cout &lt;&lt; \" End of chain reached\" &lt;&lt; endl &lt;&lt; endl; return; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"SEAL学习第一天-Bfv_basics使用用法","slug":"SEAL学习第一天-bfv-basics使用用法","date":"2021-08-11T14:01:34.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/9959b7cc/","link":"","permalink":"https://www.sizaif.com/posts/9959b7cc/","excerpt":"","text":"@auther by sizaif SEAL学习第一天： bfv_basics使用用法 @TOC bfv_basics 一 parms类 创建一个HE方案类 parms类需要的3个参数 poly_modulus_degree (degree of polynomial modulus 多项式模的次数); coeff_modulus ([ciphertext] coefficient modulus 系数模); plain_modulus (plaintext modulus; only for the BFV scheme). MOD X, 将结果MOD到X内 用法 参数 解释说明 EncryptionParameters parms(); scheme_type::bfv 创建一个HE以BFV方案类 size_t poly_modulus_degree = 4096; integear [size_t poly_modulus_degree](###size_t poly_modulus_degree) parms.set_poly_modulus_degree(); poly_modulus_degree parms.set_coeff_modulus()； CoeffModulus::BFVDefault(poly_modulus_degree) poly_modulus_degree parms.set_plain_modulus(1024); integear MOD context.parameter_error_message() 输出报错信息 SEALContext context(parms); 创建SEALContext类 EncryptionParameters parms(scheme_type::bfv); The BFV scheme cannot perform arbitrary computations on encrypted data. Instead, each ciphertext has a specific quantity called the `invariant noise budget' -- or `noise budget' for short -- measured in bits. The noise budget in a freshly encrypted ciphertext (initial noise budget) is determined by the encryption parameters. Homomorphic operations consume the noise budget at a rate also determined by the encryption parameters. In BFV the two basic operations allowed on encrypted data are additions and multiplications, of which additions can generally be thought of as being nearly free in terms of noise budget consumption compared to multiplications. Since noise budget consumption compounds in sequential multiplications, the most significant factor in choosing appropriate encryption parameters is the multiplicative depth of the arithmetic circuit that the user wants to evaluate on encrypted data. Once the noise budget of a ciphertext reaches zero it becomes too corrupted to be decrypted. Thus, it is essential to choose the parameters to be large enough to support the desired computation; otherwise the result is impossible to make sense of even with the secret key. 基本运算: 加法 和乘法 In BFV the two basic operations allowed on encrypted data are additions and multiplications 基本运算: 加法 和乘法 size_t poly_modulus_degree = 4096; size_t poly_modulus_degree 多项式模”的次数,2的倍数;1024, 2048, 4096, 8192, 16384, 32768, parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); coeff_modulus code [ciphertext] `coefficient modulus’ (coeff_modulus) [密文]‘系数模量’ (coeff_modulus)Microsoft SEAL comes with helper functions for selecting the coeff_modulus.For new users the easiest way is to simply use简单调用:CoeffModulus::BFVDefault(poly_modulus_degree),返回vector类型which returns std::vector consisting of a generally good choicefor the given poly_modulus_degree.模长度对应素数长度±---------------------------------------------------+| poly_modulus_degree | max coeff_modulus bit-length |±--------------------±-----------------------------+| 1024 | 27 || 2048 | 54 || 4096 | 109 || 8192 | 218 || 16384 | 438 || 32768 | 881 |±--------------------±-----------------------------+ parms.set_plain_modulus(1024); MOD ~ log2(coeff_modulus/plain_modulus) (bits) 噪声预算计算方式: and the noise budget consumption in a homomorphic multiplication is of the form log2(plain_modulus) + (other terms). 明文模量是BFV格式特有的，使用CKKS格式时不能设置明文模量。 既然所有参数都设置好了，我们就可以构建一个SEALContext了 对象。类的有效性和属性是一个重类 我们刚刚设置的参数。 演示code EncryptionParameters parms(scheme_type::bfv); //声明HE 使用的模式 // 设置 3 个参数 size_t poly_modulus_degree = 4096; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(1024); // 明文 MOD数 (2的倍数, 素数最好) //创建一个context SEALContext context(parms); //当使用参数创建SEALContext时，Microsoft SEAL将首先创建验证这些参数。这里选择的参数是有效的。 cout &lt;&lt; \"Parameter validation (success): \" &lt;&lt; context.parameter_error_message() &lt;&lt; endl; 二 KeyGenerator类 公钥加密方案有一个用于加密数据的单独的公钥，和一个用于解密数据的单独的秘密密钥。 我们需要KeyGenerator类的一个实例。构造密钥生成器会自动生成一个密钥。然后，我们可以使用 KeyGenerator::create_public_key为它创建尽可能多的公钥。 用法 参数 解释说明 KeyGenerator keygen(context); SEALContext 创建一个钥匙生成器 SecretKey secret_key = keygen.secret_key(); 创造一个私钥 PublicKey public_key; 声明一个公钥 keygen.create_public_key(public_key); 创造一个公钥 Encryptor encryptor(); SEALContext，PublicKey 构造Encryptor的一个实例 Evaluator evaluator(); SEALContext 对密文的计算使用Evaluator类执行 Decryptor decryptor(); SEALContext，SecretKey 构造Decryptor类的一个实例 Note that KeyGenerator::create_public_key has another overload that takes no parameters and returns a Serializable&lt;PublicKey&gt; object. We will discuss this in &#96;6_serialization.cpp&#39;. 为了能够加密，我们需要构造Encryptor的一个实例,注意，加密器只需要公钥， ​ Encryptor encryptor(contest,public_key); 对密文的计算使用Evaluator类执行,Evaluator不会由持有密钥的同一方构造。 ​ Evaluator evaluator(context); 当然，我们希望对结果进行解密，以验证一切工作正常，因此还需要构造Decryptor类的一个实例。注意，解密器需要密钥。 ​ Decryptor decryptor(context, secret_key); 演示code code Ciphertext x_encrypted; // 密文 encryptor.encrypt(x_plain, x_encrypted); // 将明文 x_plain 加密输出到密文x_encrypted上 Plaintext x_decrypted; decryptor.decrypt(x_encrypted, x_decrypted); // 解密 将加密密文,输出覆盖到明文上 cout &lt;&lt; \"Compute x_sq_plus_one (x^2+1).\" &lt;&lt; endl; Ciphertext x_sq_plus_one; evaluator.square(x_encrypted, x_sq_plus_one); // 计算平方, 结果输出到 x_sq_plus_one 中 Plaintext plain_one(\"1\"); // 明文 1 /** 加密的乘法导致输出密文的大小增加。 更准确地说，如果输入密文的大小为M和N，则输出 同态乘法后的密文大小为M+N-1。 **/ 线性化 Relinearization `Relinearization’ is an operation that reduces the size of a ciphertext after multiplication back to the initial size, 2. Thus, relinearizing one or both input ciphertexts before the next multiplication can have a huge positive impact on both noise growth and performance, even though relinearization has a significant computational cost itself. It is only possible to relinearize size 3 ciphertexts down to size 2, so often the user would want to relinearize after each multiplication to keep the ciphertext sizes at 2. Relinearization requires special `relinearization keys’, which can be thought of as a kind of public key. Relinearization keys can easily be created with the KeyGenerator. “重新线性化”是一种减少密文大小的操作。 乘法返回初始大小2。因此，重新线性化一个或两个 下一个乘法之前的输入密文可以具有很大的正数 即使重新线性化已对噪声增长和性能产生影响 巨大的计算成本本身。 只能重新线性化 大小为3的密文，大小减小为2，因此用户经常需要重新线性化 每次乘法后，将密文大小保持为2。 重新线性化需要特殊的“重新线性化键”，可以认为 作为一种公钥。 重新线性化键可以轻松创建 KeyGenerator。 线性化用法 用法 参数 解释说明 RelinKeys relin_keys; 声明线性化类 keygen.create_relin_keys(relin_keys); (RelinKeys) 创建一个线性密钥 evaluator.relinearize_inplace(x_squared, relin_keys); (Ciphertext，RelinKeys) 将计算结果重新线性化大小到2以内 演示Code code print_line(__LINE__); cout &lt;&lt; \"Compute and relinearize x_squared (x^2),\" &lt;&lt; endl; cout &lt;&lt; string(13, ' ') &lt;&lt; \"then compute x_sq_plus_one (x^2+1)\" &lt;&lt; endl; Ciphertext x_squared; evaluator.square(x_encrypted, x_squared); cout &lt;&lt; \" + size of x_squared: \" &lt;&lt; x_squared.size() &lt;&lt; endl; evaluator.relinearize_inplace(x_squared, relin_keys);// 重新线性化大小到2以内 cout &lt;&lt; \" + size of x_squared (after relinearization): \" &lt;&lt; x_squared.size() &lt;&lt; endl; evaluator.add_plain(x_squared, plain_one, x_sq_plus_one); // x_sq_plus_one = x_squared + plain_one; cout &lt;&lt; \" + noise budget in x_sq_plus_one: \" &lt;&lt; decryptor.invariant_noise_budget(x_sq_plus_one) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + decryption of x_sq_plus_one: \"; decryptor.decrypt(x_sq_plus_one, decrypted_result); ss2.clear(); ss2 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss2 >> d2; cout &lt;&lt; \"Hex: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer: \"&lt;&lt;d2&lt;&lt;\" ...... Correct. (x^2 + 1 ) \" &lt;&lt; endl; 源代码 code #include \"seal/seal.h\" #include \"examples.h\" #include &lt;iostream> using namespace std; using namespace seal; int main() &#123; print_example_banner(\"Example: BFV Basics\"); EncryptionParameters parms(scheme_type::bfv); //声明HE 使用的模式 // 设置 3 个参数 size_t poly_modulus_degree = 4096; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(1024); // 明文 MOD数 (2的倍数, 素数最好) //创建一个context SEALContext context(parms); print_line(__LINE__); cout &lt;&lt; \"Set encryption parameters and print\" &lt;&lt; endl; print_parameters(context); cout &lt;&lt; \"Hello World!\"&lt;&lt;endl; cout &lt;&lt; \"Parameter validation (success): \" &lt;&lt; context.parameter_error_message() &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"~~~~~~ A naive way to calculate 4(x^2+1)(x+1)^2. ~~~~~~\" &lt;&lt; endl; KeyGenerator keygen(context); // 密钥类 SecretKey secret_key = keygen.secret_key(); // 创建私钥 PublicKey public_key; keygen.create_public_key(public_key); // 创建公钥 Encryptor encryptor(context, public_key);// 加密类,只需要公钥即可; Evaluator evaluator(context); // 评估计算类 Decryptor decryptor(context, secret_key); // 解密类 /** 4x^4 + 8x^3 + 8x^2 + 8x + 4 **/ print_line(__LINE__); int x = 6; Plaintext x_plain(to_string(x)); //x_plain.to_string() 转换成16进制输出 cout &lt;&lt; \"Express x = \" + to_string(x) + \" as a plaintext polynomial 0x\" + x_plain.to_string() + \".\" &lt;&lt; endl; print_line(__LINE__); Ciphertext x_encrypted;// 密文类 cout &lt;&lt; \"Encrypt x_plain to x_encrypted.\" &lt;&lt; endl; encryptor.encrypt(x_plain, x_encrypted); cout &lt;&lt; \" + size of freshly encrypted x: \" &lt;&lt; x_encrypted.size() &lt;&lt; endl; /* There is plenty of noise budget left in this freshly encrypted ciphertext. 噪声预算，当噪音预算降低到0的时候，计算结果不正确 */ cout &lt;&lt; \" + noise budget in freshly encrypted x: \" &lt;&lt; decryptor.invariant_noise_budget(x_encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; Plaintext x_decrypted; cout &lt;&lt; \" + decryption of x_encrypted: \"; decryptor.decrypt(x_encrypted, x_decrypted); cout &lt;&lt; \"0x\" &lt;&lt; x_decrypted.to_string() &lt;&lt; \" ...... Correct.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Compute x_sq_plus_one (x^2+1).\" &lt;&lt; endl; Ciphertext x_sq_plus_one; evaluator.square(x_encrypted, x_sq_plus_one); // 计算平方, 结果输出到 x_sq_plus_one 中 Plaintext plain_one(\"1\"); // 明文 1 evaluator.add_plain_inplace(x_sq_plus_one, plain_one); // x_sq_plus_one = x_sq_plus_one + plain_one /** 加密的乘法导致输出密文的大小增加。 更准确地说，如果输入密文的大小为M和N，则输出 同态乘法后的密文大小为M+N-1。 **/ cout &lt;&lt; \" + size of x_sq_plus_one: \" &lt;&lt; x_sq_plus_one.size() &lt;&lt; endl; cout &lt;&lt; \" + noise budget in x_sq_plus_one: \" &lt;&lt; decryptor.invariant_noise_budget(x_sq_plus_one) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 计算4个多项式样例 * 4x^4 + 8x^3 + 8x^2 + 8x + 4 * 4x^4 + 8x^3 + 8x^2 + 8x + 4 = 4(x + 1)^2 * (x^2 + 1) 转换成 4(x + 1)^2 * (x^2 + 1) 降低多项式系数 */ stringstream ss2;//字符串流 ,做字符转换用 int d2; // 密文计算(x^2+1) 的解密结果为: Plaintext decrypted_result; cout &lt;&lt; \" + decryption of x_sq_plus_one : \"; decryptor.decrypt(x_sq_plus_one, decrypted_result); ss2.clear(); ss2 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); // 十六进制输出到ss2， ss2 >> d2; // ss2 输出十进制到 d2 cout &lt;&lt; \"HEX: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer: \" &lt;&lt; d2 &lt;&lt; \" .... Correct. \" &lt;&lt; endl; /* 接着密文计算 (x + 1)^2. */ print_line(__LINE__); cout &lt;&lt; \"Compute x_plus_one_sq ((x+1)^2).\" &lt;&lt; endl; Ciphertext x_plus_one_sq; evaluator.add_plain(x_encrypted, plain_one, x_plus_one_sq); //密文 x_plus_one_sq = x_encrypted + plain_one (x+1) evaluator.square_inplace(x_plus_one_sq); // x_plus_one_sq = x_plus_one_sq * x_plus_one_sq; cout &lt;&lt; \" + size of x_plus_one_sq: \" &lt;&lt; x_plus_one_sq.size() &lt;&lt; endl; cout &lt;&lt; \" + noise budget in x_plus_one_sq: \" &lt;&lt; decryptor.invariant_noise_budget(x_plus_one_sq) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + decryption of x_plus_one_sq: \"; decryptor.decrypt(x_plus_one_sq, decrypted_result); ss2.clear(); ss2 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); // 十六进制输出到ss2， ss2 >> d2; // ss2 输出十进制到 d2 cout&lt;&lt;\"Hex: Ox\"&lt;&lt;decrypted_result.to_string()&lt;&lt;\" Integer: \"&lt;&lt;d2&lt;&lt;\" .... Correct. \" &lt;&lt; endl; /* 最终计算 (x^2 + 1) * (x + 1)^2 * 4. */ print_line(__LINE__); cout &lt;&lt; \"Compute encrypted_result (4(x^2+1)(x+1)^2).\" &lt;&lt; endl; Ciphertext encrypted_result; Plaintext plain_four(\"4\"); evaluator.multiply_plain_inplace(x_sq_plus_one, plain_four); // x_sq_plus_one = x_sq_plus_one * 4; evaluator.multiply(x_sq_plus_one, x_plus_one_sq, encrypted_result); // 密文encrypted_result = x_sq_plus_one * x_plus_one_sq ; cout &lt;&lt; \" + size of encrypted_result: \" &lt;&lt; encrypted_result.size() &lt;&lt; endl; cout &lt;&lt; \" + noise budget in encrypted_result: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_result) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"NOTE: Decryption can be incorrect if noise budget is zero.\" &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"~~~~~~ A better way to calculate 4(x^2+1)(x+1)^2. ~~~~~~\" &lt;&lt; endl; decryptor.decrypt(encrypted_result, decrypted_result); stringstream ss3; ss3.clear(); ss3 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss3 >> d2; // ss2 输出十进制到 d2 cout &lt;&lt; d2 &lt;&lt; \" \" &lt;&lt; decrypted_result.to_string() &lt;&lt; endl; // 得到的结果不正确 /* * 利用Relinearization 线性化 对运算进行优化 */ print_line(__LINE__); cout &lt;&lt; \"Generate relinearization keys.\" &lt;&lt; endl; RelinKeys relin_keys; // 做线性化类 keygen.create_relin_keys(relin_keys); // 创建线性化密钥 /* We now repeat the computation relinearizing after each multiplication. 我们在每次乘法之后重复重新线性化的计算。 */ print_line(__LINE__); cout &lt;&lt; \"Compute and relinearize x_squared (x^2),\" &lt;&lt; endl; cout &lt;&lt; string(13, ' ') &lt;&lt; \"then compute x_sq_plus_one (x^2+1)\" &lt;&lt; endl; Ciphertext x_squared; evaluator.square(x_encrypted, x_squared); cout &lt;&lt; \" + size of x_squared: \" &lt;&lt; x_squared.size() &lt;&lt; endl; evaluator.relinearize_inplace(x_squared, relin_keys);// 重新线性化大小到2以内 cout &lt;&lt; \" + size of x_squared (after relinearization): \" &lt;&lt; x_squared.size() &lt;&lt; endl; evaluator.add_plain(x_squared, plain_one, x_sq_plus_one); // x_sq_plus_one = x_squared + plain_one; cout &lt;&lt; \" + noise budget in x_sq_plus_one: \" &lt;&lt; decryptor.invariant_noise_budget(x_sq_plus_one) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + decryption of x_sq_plus_one: \"; decryptor.decrypt(x_sq_plus_one, decrypted_result); ss2.clear(); ss2 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss2 >> d2; cout &lt;&lt; \"Hex: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer: \"&lt;&lt;d2&lt;&lt;\" ...... Correct. (x^2 + 1 ) \" &lt;&lt; endl; print_line(__LINE__); Ciphertext x_plus_one; cout &lt;&lt; \"Compute x_plus_one (x+1),\" &lt;&lt; endl; cout &lt;&lt; string(13, ' ') &lt;&lt; \"then compute and relinearize x_plus_one_sq ((x+1)^2).\" &lt;&lt; endl; evaluator.add_plain(x_encrypted, plain_one, x_plus_one);// x_plus_one = x_encrypted + plain_one; evaluator.square(x_plus_one, x_plus_one_sq);// x_plus_one_sq = x_plus_one * x_plus_one; cout &lt;&lt; \" + size of x_plus_one_sq: \" &lt;&lt; x_plus_one_sq.size() &lt;&lt; endl; evaluator.relinearize_inplace(x_plus_one_sq, relin_keys); // 大小线性优化到2内 cout &lt;&lt; \" + noise budget in x_plus_one_sq: \" &lt;&lt; decryptor.invariant_noise_budget(x_plus_one_sq) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + decryption of x_plus_one_sq: \"; ss3.clear(); decryptor.decrypt(x_plus_one_sq, decrypted_result); ss3&lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss3 >> d2; cout &lt;&lt; \"Hex: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer: \"&lt;&lt;d2&lt;&lt;\" ...... Correct.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Compute and relinearize encrypted_result (4(x^2+1)(x+1)^2).\" &lt;&lt; endl; evaluator.multiply_plain_inplace(x_sq_plus_one, plain_four); // x_sq_plus_one = x_sq_plus_one * plain_four evaluator.multiply(x_sq_plus_one, x_plus_one_sq, encrypted_result);// encrypted_result = x_sq_plus_one * x_plus_one_sq cout &lt;&lt; \" + size of encrypted_result: \" &lt;&lt; encrypted_result.size() &lt;&lt; endl; evaluator.relinearize_inplace(encrypted_result, relin_keys); // 线性优化 cout &lt;&lt; \" + size of encrypted_result (after relinearization): \" &lt;&lt; encrypted_result.size() &lt;&lt; endl; cout &lt;&lt; \" + noise budget in encrypted_result: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_result) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"NOTE: Notice the increase in remaining noise budget.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Decrypt encrypted_result (4(x^2+1)(x+1)^2).\" &lt;&lt; endl; ss3.clear(); decryptor.decrypt(encrypted_result, decrypted_result); ss3 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss3 >> d2; cout &lt;&lt; \" + decryption of 4(x^2+1)(x+1)^2 ,after Mod = Hex: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer:\" &lt;&lt; d2 &lt;&lt; \" ...... Correct.(4(x^2+1)(x+1)^2)\" &lt;&lt; endl; /* * 对于 x=6, 4(x^2+1)(x+1)^2 = 7252. 因为 plaintext modulus MOD被设置为 1024, * 所以结果%1024.故 7252 % 1024 == 84, 或者16进制： 0x54 */ print_line(__LINE__); cout &lt;&lt; \"An example of invalid parameters\" &lt;&lt; endl; parms.set_poly_modulus_degree(2048); context = SEALContext(parms); print_parameters(context); cout &lt;&lt; \"Parameter validation (failed): \" &lt;&lt; context.parameter_error_message() &lt;&lt; endl &lt;&lt; endl; return 0; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"Java反射技术拿取和设置Object实体类中的属性","slug":"Java反射技术拿取和设置Object实体类中的属性","date":"2021-08-11T14:01:20.000Z","updated":"2021-09-19T10:13:55.000Z","comments":true,"path":"posts/c57ba29d/","link":"","permalink":"https://www.sizaif.com/posts/c57ba29d/","excerpt":"","text":"[TOC] @auther by sizaif 说明 在实际项目开发中使用PageHelper插件拿到的数据封装在 PageInfo中,而某些操作需要拿到里面的值和设置一些值,由于Object的缘故,无法直接get和set,所有使用java反射来get和set for (Object contestVO : pageInfo.getList()) &#123; .....XXXXX..... &#125; 拿属性的值 /** * 根据属性名获取属性值 * * @param 要拿取的属性的名称 * @param 实体类 * @return */ private static String getFieldValueByFieldName(String fieldName, Object object) &#123; try &#123; Field field = object.getClass().getDeclaredField(fieldName); //设置对象的访问权限，保证对private的属性的访问 field.setAccessible(true); return (String)field.get(object); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; 设置 /** * 根据属性名设置属性值 * * @param 要设置的属性名称 * @param 实体类 * @param 对于要设置的属性类型 * @return */ private static void setFieldValueByFieldName(String fieldName, Object object, 对于要设置的属性类型 value) &#123; try &#123; // 获取obj类的字节文件对象 Class aClass = object.getClass(); // 获取该类的成员变量 Field field = aClass.getDeclaredField(fieldName); // 取消语言访问检查 field.setAccessible(true); // 给变量赋值 field.set(object, value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"}],"author":"sizaif"},{"title":"解决 Win10 Hyper-v 保留端口占用问题","slug":"解决-win10-hyper-v-保留端口占用问题","date":"2021-08-11T01:31:53.000Z","updated":"2021-09-19T10:14:21.000Z","comments":true,"path":"posts/f8215b18/","link":"","permalink":"https://www.sizaif.com/posts/f8215b18/","excerpt":"","text":"解决 win10 hyper-v 保留端口占用问题 [TOC] 查找问题 首先，检查端口占用 # powershell netstat -ano | findstr \":8080\" 没有结果，意味着并不是有程序占用了端口。 猜测可能是更新了win10 2004，导致win10防火墙配置有变更，又检查了一番win10防火墙，发现并没有拦截或者端口禁用的配置。此时，我才想起好像先前开启了hyper-v，最后搜索了一番，找到了出现问题的地方： code # powershell # 查看系统默认端口占用访问 netsh int ipv4 show dynamicport tcp 协议 tcp 动态端口范围 --------------------------------- 启动端口 : 1024 端口数 : 13977 # 查看hyper-v启动后的保留端口范围 netsh interface ipv4 show excludedportrange protocol=tcp 协议 tcp 端口排除范围 开始端口 结束端口 ---------- -------- 1026 1125 1226 1325 1326 1425 1426 1525 1526 1625 2180 2279 ... # 通过这个可以查看被占用的项目端口是否在这个范围内 解决办法 由于直接进行第二步配置，会遇到程序占用(hyper-v占用)，所以需要先关闭hyper-v， 可以win+s 快捷键搜索 “windows功能” ，关闭hyper-v，或者使用下列命令，然后重启 # powershell / cmd dism.exe /Online /Disable-Feature:Microsoft-Hyper-V 配置ipv4动态端口 / 或者配置需要的端口不被占用 # powershell / cmd 管理员权限 # start 起始端口 num 表示可用端口数 按自己的需求来 netsh int ipv4 set dynamicport tcp start=30000 num=16383 # 排除ipv4动态端口占用 startport 起始端口 numberofports 端口数 netsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1 重启hyper-v 命令或配置窗口(参考1 dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"}],"tags":[{"name":"Win","slug":"Win","permalink":"https://www.sizaif.com/tags/Win/"},{"name":"Hyper-v","slug":"Hyper-v","permalink":"https://www.sizaif.com/tags/Hyper-v/"}],"author":"sizaif"},{"title":"VS2019平台引入C++版tensorflow遇到的一些问题及解决方法","slug":"VS2019平台引入C-版tensorflow遇到的一些问题及解决方法","date":"2021-08-11T01:23:38.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/54fe9f8f/","link":"","permalink":"https://www.sizaif.com/posts/54fe9f8f/","excerpt":"","text":"VS2019平台引入C++版tensorflow遇到的一些问题及解决方法 [TOC] 安装tensorflow 我采用的是已编译好的tensorflow 下载tensorflow https://github.com/fo40225/tensorflow-windows-wheel 注意: 这里面只有tensorflow1.71.10的版本有编译好的cpp库，其他的版本只有编译好的安装tf的python库的whl文件，所以强烈推荐大家用1.71.10的tensorflow。 例如我需要tensorflow1.10的、cpu支持AVX2指令集的版本，就下载tensorflow-windows-wheel/1.10.0/cpp/libtensorflow-cpu-windows-x86_64-1.10.0-avx2.7z 例如我需要tensorflow1.10的、cpu支持SSE2指令集、且gpu支持CUDA9.2和CUDNN7.2的版本，就下载tensorflow-windows-wheel/1.10.0/cpp/libtensorflow-gpu-windows-x86_64-1.10.0-sse2cuda92cudnn72.7z 然后把其中的include路径包含进去，把lib文件添加到工程中，再在执行exe时把dll文件复制进去就好了 ———————————————— 版权声明：本文为CSDN博主「_沥川往事」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/yuejisuo1948/article/details/84197534 引入tensorflow 在cmakelist.txt中写入； include_directories(&lt;Your Path&gt;&#x2F;tensorflow&#x2F;include) link_directories(&lt;Your Path&gt;&#x2F;tensorflow&#x2F;lib) target_link_libraries(&lt;Your exe name&gt; tensorflow) 遇到的问题: 1. “(”:“::”右边的非法标记应输入标记符 原因处在vc和c++模板库上.min和max与&lt;windows.h&gt;中传统的min/max宏定义有冲突 在属性-&gt;C/C+±&gt;预处理器-&gt; 预处理定义中 添加NOMINMAX 解决方法: 2.找不到tensorflow.dll 解决方法: ==将已编译好的tensorflow的bin目录下 tensorflow.dll 复制到 debug目录下和*.exe一起== 如图: 3.找不到cublas64_92.dll 没安装cuda的缘故 我对应的是安装9.2的版本 参考安装CUDA文章 https://blog.csdn.net/qq_46126258/article/details/112739305?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=94a15f6a-35fe-4639-90bf-20c5530f2251&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control 安装完后再运行提示 找不到 cudnn64_7.dll 没有安装对应的cudnn版本 去nvidia官网安装 https://developer.nvidia.com/rdp/cudnn-archive 选择对应的Cuda版本 ， 这里选择的就是 下载后 将对应的文件复制到 CUDA 的安装目录： a) Copy &lt;installpath>\\cuda\\bin\\cudnn64_7.dll to C:\\Program Files \\NVIDIA GPU Computing Toolkit\\CUDA\\v9.2\\bin. b) Copy &lt;installpath>\\cuda\\ include\\cudnn.h to C:\\Program Files \\NVIDIA GPU Computing Toolkit\\CUDA\\v9.2\\include. c) Copy &lt;installpath>\\cuda\\lib\\x64\\cudnn.lib to C:\\Program Files \\NVIDIA GPU Computing Toolkit\\CUDA\\v9.2\\lib\\x64","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"VS2019","slug":"技术向/VS2019","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/VS2019/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"VS2019","slug":"VS2019","permalink":"https://www.sizaif.com/tags/VS2019/"}],"author":"sizaif"},{"title":"Ubuntu 20.04LTS 编译Tensorflow C++","slug":"ubuntu-20-04LTS-编译tensorflow-C","date":"2021-08-11T01:23:22.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/71bba0f8/","link":"","permalink":"https://www.sizaif.com/posts/71bba0f8/","excerpt":"","text":"ubuntu 20.04LTS 编译tensorflow C++ NOTE! 因为ubuntu在虚拟机里,我是用的笔记本的显卡比较落后,安装NVIDIA驱动失败,故未使用 GPU功能,仅使用了CPU模式; 编译得到libtensorflow_cc.so和libtensorflow_framework.so 是C++ 所需要的 [TOC] tensorflow 和Bazel 以及python 对应的版本 Linux CPU CPU VersionPython versionCompilerBuild toolstensorflow-2.4.03.6-3.8GCC 7.3.1Bazel 3.1.0tensorflow-2.3.03.5-3.8GCC 7.3.1Bazel 3.1.0tensorflow-2.2.03.5-3.8GCC 7.3.1Bazel 2.0.0tensorflow-2.1.02.7, 3.5-3.7GCC 7.3.1Bazel 0.27.1tensorflow-2.0.02.7, 3.3-3.7GCC 7.3.1Bazel 0.26.1tensorflow-1.15.02.7, 3.3-3.7GCC 7.3.1Bazel 0.26.1tensorflow-1.14.02.7, 3.3-3.7GCC 4.8Bazel 0.24.1tensorflow-1.13.12.7, 3.3-3.7GCC 4.8Bazel 0.19.2tensorflow-1.12.02.7, 3.3-3.6GCC 4.8Bazel 0.15.0tensorflow-1.11.02.7, 3.3-3.6GCC 4.8Bazel 0.15.0tensorflow-1.10.02.7, 3.3-3.6GCC 4.8Bazel 0.15.0tensorflow-1.9.02.7, 3.3-3.6GCC 4.8Bazel 0.11.0tensorflow-1.8.02.7, 3.3-3.6GCC 4.8Bazel 0.10.0tensorflow-1.7.02.7, 3.3-3.6GCC 4.8Bazel 0.10.0tensorflow-1.6.02.7, 3.3-3.6GCC 4.8Bazel 0.9.0tensorflow-1.5.02.7, 3.3-3.6GCC 4.8Bazel 0.8.0tensorflow-1.4.02.7, 3.3-3.6GCC 4.8Bazel 0.5.4tensorflow-1.3.02.7, 3.3-3.6GCC 4.8Bazel 0.4.5tensorflow-1.2.02.7, 3.3-3.6GCC 4.8Bazel 0.4.5tensorflow-1.1.02.7, 3.3-3.6GCC 4.8Bazel 0.4.2tensorflow-1.0.02.7, 3.3-3.6GCC 4.8Bazel 0.4.2 GPU GPU VersionPython versionCompilerBuild toolscuDNNCUDAtensorflow-2.4.03.6-3.8GCC 7.3.1Bazel 3.1.08.011.0tensorflow-2.3.03.5-3.8GCC 7.3.1Bazel 3.1.07.610.1tensorflow-2.2.03.5-3.8GCC 7.3.1Bazel 2.0.07.610.1tensorflow-2.1.02.7, 3.5-3.7GCC 7.3.1Bazel 0.27.17.610.1tensorflow-2.0.02.7, 3.3-3.7GCC 7.3.1Bazel 0.26.17.410.0tensorflow_gpu-1.15.02.7, 3.3-3.7GCC 7.3.1Bazel 0.26.17.410.0tensorflow_gpu-1.14.02.7, 3.3-3.7GCC 4.8Bazel 0.24.17.410.0tensorflow_gpu-1.13.12.7, 3.3-3.7GCC 4.8Bazel 0.19.27.410.0tensorflow_gpu-1.12.02.7, 3.3-3.6GCC 4.8Bazel 0.15.079tensorflow_gpu-1.11.02.7, 3.3-3.6GCC 4.8Bazel 0.15.079tensorflow_gpu-1.10.02.7, 3.3-3.6GCC 4.8Bazel 0.15.079tensorflow_gpu-1.9.02.7, 3.3-3.6GCC 4.8Bazel 0.11.079tensorflow_gpu-1.8.02.7, 3.3-3.6GCC 4.8Bazel 0.10.079tensorflow_gpu-1.7.02.7, 3.3-3.6GCC 4.8Bazel 0.9.079tensorflow_gpu-1.6.02.7, 3.3-3.6GCC 4.8Bazel 0.9.079tensorflow_gpu-1.5.02.7, 3.3-3.6GCC 4.8Bazel 0.8.079tensorflow_gpu-1.4.02.7, 3.3-3.6GCC 4.8Bazel 0.5.468tensorflow_gpu-1.3.02.7, 3.3-3.6GCC 4.8Bazel 0.4.568tensorflow_gpu-1.2.02.7, 3.3-3.6GCC 4.8Bazel 0.4.55.18tensorflow_gpu-1.1.02.7, 3.3-3.6GCC 4.8Bazel 0.4.25.18tensorflow_gpu-1.0.02.7, 3.3-3.6GCC 4.8Bazel 0.4.25.18 具体步骤 一 首先安装python3 环境, 如果你没有安装的话 sudo apt install python3-dev python3-pip 安装TensorFlow 2 .whl包需要一个pip版本&gt;19.0 二 安装 Bazel 这里我才用的是安装程序文件来进行的. 安装程序可以从Bazel’s下载 https://github.com/bazelbuild/bazel/releases 选择上面你要编译的对应的bazel版本 安装程序包含Bazel二进制文件，并将其提取到**$HOME/bin**文件夹中。为了让Bazel工作，必须手动安装一些附加库。 如果没有以下环境. 需要进行安装 sudo apt install g++ unzip zip 如果想用Bazel 构建JAVA代码, 使用JDK # Ubuntu 16.04 (LTS) uses OpenJDK 8 by default: sudo apt-get install openjdk-8-jdk # Ubuntu 18.04 (LTS) uses OpenJDK 11 by default: sudo apt-get install openjdk-11-jdk 下载之后, 运行 chmod +x bazel-&lt;version>-installer-linux-x86_64.sh ./bazel-&lt;version>-installer-linux-x86_64.sh --user The --user flag installs Bazel to the $HOME/bin directory on your system and sets the .bazelrc path to $HOME/.bazelrc. Use the --help command to see additional installation options. 当使用–user 来安装时, Bazel 会被安装到 $HOME/bin 路径下, 添加环境语句到环境**/.bashrc**或者**/.zshrc**变量里 可以使用VIM vim ~/.bashrc 添加以下语句 export PATH=\"$PATH:$HOME/bin\" 然后实质生效 source ~/.bashrc 三下载tensorflow源码 git clone https://github.com/tensorflow/tensorflow.git cd tensorflow 选择要安装的版本 git checkout branch_name # r2.2, r2.3, r2.4 etc. 构建环境 ./configure configure 会话展示 这里要说明的是如果有CUDA，那么Do you wish to build Tensorflow with CUDA?一定要选Y，然后其它的我基本都是N code ./configure You have bazel 3.0.0 installed. Please specify the location of python. [Default is /usr/bin/python3]: Found possible Python library paths: /usr/lib/python3/dist-packages /usr/local/lib/python3.6/dist-packages Please input the desired Python library path to use. Default is [/usr/lib/python3/dist-packages] Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: No OpenCL SYCL support will be enabled for TensorFlow. Do you wish to build TensorFlow with ROCm support? [y/N]: No ROCm support will be enabled for TensorFlow. Do you wish to build TensorFlow with CUDA support? [y/N]: Y CUDA support will be enabled for TensorFlow. Do you wish to build TensorFlow with TensorRT support? [y/N]: No TensorRT support will be enabled for TensorFlow. Found CUDA 10.1 in: /usr/local/cuda-10.1/targets/x86_64-linux/lib /usr/local/cuda-10.1/targets/x86_64-linux/include Found cuDNN 7 in: /usr/lib/x86_64-linux-gnu /usr/include Please specify a list of comma-separated CUDA compute capabilities you want to build with. You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus Each capability can be specified as \"x.y\" or \"compute_xy\" to include both virtual and binary GPU code, or as \"sm_xy\" to only include the binary code. Please note that each additional compute capability significantly increases your build time and binary size, and that TensorFlow only supports compute capabilities >= 3.5 [Default is: 3.5,7.0]: 6.1 Do you want to use clang as CUDA compiler? [y/N]: nvcc will be used as CUDA compiler. Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]: Please specify optimization flags to use during compilation when bazel option \"--config=opt\" is specified [Default is -march=native -Wno-sign-compare]: Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: Not configuring the WORKSPACE for Android builds. Preconfigured Bazel build configs. You can use any of the below by adding \"--config=&lt;>\" to your build command. See .bazelrc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=ngraph # Build with Intel nGraph support. --config=numa # Build with NUMA support. --config=dynamic_kernels # (Experimental) Build kernels into separate shared objects. --config=v2 # Build TensorFlow 2.x instead of 1.x. Preconfigured Bazel build configs to DISABLE default on features: --config=noaws # Disable AWS S3 filesystem support. --config=nogcp # Disable GCP support. --config=nohdfs # Disable HDFS support. --config=nonccl # Disable NVIDIA NCCL support. Configuration finished 编译 配置好之后就进行编译：若采用CUDA 则如下 bazel build --config=opt --config=cuda //tensorflow:libtensorflow_cc.so ​ 这里如果不用cuda的话(前面配置的时候在CUDA那一项那里输入N)，就输入： bazel build --config=opt //tensorflow:libtensorflow_cc.so 可能会遇到的问题: /usr/bin/env: ‘python‘: No such file or directory 如果以及安装了python3的版本,可能是因为显示的是python3.X 但用的的名称为python 所以可以建立一个软连接 whereis python3# 如果安装的话,默认在/usr/bin/目录下sudo ln -s /usr/bin/python3 /usr/bin/python 接下来就是漫长的等待, 因为我没有用CUDA( NVIDIA的驱动没有安装上,所以用不了GPU加速) 耗时3+小时 最终会在 当前目录下生成一个 bazel-bin 目录下 tensorflow 里 找到这两个文件","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"}],"author":"sizaif"},{"title":"Tensorflow-C++ & OpenCV & OpenBlas & Eigen3 & Protobuf 环境Docker镜像","slug":"tensorflow-C-OpenCV-OpenBlas-eigen3-protobuf-环境docker镜像","date":"2021-08-11T01:23:06.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/1c98e054/","link":"","permalink":"https://www.sizaif.com/posts/1c98e054/","excerpt":"","text":"tensorflow-C++ &amp; OpenCV &amp; OpenBlas &amp; eigen3 &amp; protobuf 环境docker镜像 [toc] 版本 tensorflow 2.4.1 protobuf 3.9.2 opencv 4.5.2 openblas 0.3.13 eigen3 3.3.9 使用方法: code # 下载镜像 docker pull sizaif2000/siz:1.0 # 运行后 在 /home/tf_test/ 下有 tensorflow 测试 -------- docker run -p 本机映射端口:镜像映射端口 -d --name 启动镜像名称 -e 镜像启动参数 镜像名称:镜像版本号 参数释义： -p 本机端口和容器启动端口映射 -d 后台运行 --name 容器名称 -e 镜像启动参数 ------------------------ tf_test . |-- CMakeLists.txt |-- README.md `-- src `-- main.cpp 1 directory, 3 files ------------------------ cd tf_test cmake. make ./main # if ok, then you can see like this: This is tensorflow test XXXX-XX-XX 03:55:33.709188: I tensorflow/core/platform/cpu_feature_guard.cc:142] This TensorFlow binary is optimized with oneAPI D eep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations: SSE3 SSE4.1 SSE4.2 AVX AVX2 FMA To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags. OK Session successfully created.","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"OpenCV","slug":"机器学习/OpenCV","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/OpenCV/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.sizaif.com/tags/OpenCV/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"}],"author":"sizaif"},{"title":"Tensorflow V2.4 C++ 编译测试遇到的问题以及相关解决方法","slug":"tensorflow-V2-4-C-编译测试遇到的问题以及相关解决方法","date":"2021-08-11T01:22:48.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/fabe9f4f/","link":"","permalink":"https://www.sizaif.com/posts/fabe9f4f/","excerpt":"","text":"tensorflow V2.4 C++ 编译测试遇到的问题以及相关解决方法 [TOC] fatal error: absl/strings/string_view.h: No such file or directory 解决方法: 将 https://github.com/abseil/abseil-cpp 项目中 git下来, 将 absl 目录下所有文件 复制到 tensorflow/ 目录下 /usr/local/include/tf/tensorflow 为 tensorflow 的 头文件位置 git clone https://github.com/abseil/abseil-cpp sudo cp -r ./abseil-cpp/absl /usr/local/include/tf/tensorflow atal error: tensorflow/core/protobuf/error_codes.pb.h: No such file or directory 解决方法 先查看 tensorflow 头文件 目录下 /usr/local/include/tf/tensorflow/core/protobuf/ 下有无此文件, 若无,则有可能在 bazel-bin/tensorflow/core/protobuf 目录下 # 当前在tensorflow 源码目录下 sudo cp -r ./bazel-bin/tensorflow/ /usr/local/indlue/tf/tensorflow","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"}],"author":"sizaif"},{"title":"Tensorflow 与Protobuf版本对应问题","slug":"tensorflow-与protobuf版本对应问题","date":"2021-08-11T01:22:32.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/a689049b/","link":"","permalink":"https://www.sizaif.com/posts/a689049b/","excerpt":"","text":"tensorflow 与protobuf版本对应问题 [TOC] 问题描述 我在前面的文章编译了tensorflow 2.4.1版本, 然后随之又根据protobuf github教程安装了3.15版本的protobuf 当我在编译代码引入tensorflow 时 提示如下错误: 当我运行如下命令; 得到protoc的位置,和版本信息 siz@ubuntu:~$ which protoc /usr/local/bin/protoc siz@ubuntu:~$ protoc --version libprotoc 3.15.8 查阅博客得到如下信息: (参考链接: https://blog.csdn.net/datase/article/details/82347834) 我想我遇到的应该是第二个问题: 所以我去了tensorflow github 查看了 workspace.bzl 信息: 对应的 protobuf的版本为3.9.2; 尝试解决 卸载 protobuf ==Note! 因为之前第一次安装protobuf 采用的是覆盖安装,所以将Ubuntu自带的protobuf覆盖掉了, 所以我选择直接卸载掉最新的,重新安装,没有采用兼容安装的方式== 删除方式, 进入到下载的protobuf 路径里, 采用 make uninstall 方式 code siz@ubuntu:~/soft$ cd protobuf-3.15.8/ siz@ubuntu:~/soft/protobuf-3.15.8$ sudo make uninstall [sudo] password for siz: Making uninstall in . make[1]: Entering directory '/home/siz/soft/protobuf-3.15.8' ( cd '/usr/local/lib/pkgconfig' &amp;&amp; rm -f protobuf.pc protobuf-lite.pc ) make[1]: Leaving directory '/home/siz/soft/protobuf-3.15.8' Making uninstall in src make[1]: Entering directory '/home/siz/soft/protobuf-3.15.8/src' ( cd '/usr/local/bin' &amp;&amp; rm -f protoc ) /bin/bash ../libtool --mode=uninstall rm -f '/usr/local/lib/libprotobuf-lite.la' libtool: uninstall: rm -f /usr/local/lib/libprotobuf-lite.la /usr/local/lib/libprotobuf-lite.a /bin/bash ../libtool --mode=uninstall rm -f '/usr/local/lib/libprotobuf.la' libtool: uninstall: rm -f /usr/local/lib/libprotobuf.la /usr/local/lib/libprotobuf.a /bin/bash ../libtool --mode=uninstall rm -f '/usr/local/lib/libprotoc.la' libtool: uninstall: rm -f /usr/local/lib/libprotoc.la /usr/local/lib/libprotoc.a ( cd '/usr/local/include' &amp;&amp; rm -f google/protobuf/descriptor.proto google/protobuf/any.proto google/protobuf/api.proto google/protobuf/duration.proto google/protobuf/empty.proto google/protobuf/field_mask.proto google/protobuf/source_context.proto google/protobuf/struct.proto google/protobuf/timestamp.proto google/protobuf/type.proto google/protobuf/wrappers.proto google/protobuf/compiler/plugin.proto ) ( cd '/usr/local/include' &amp;&amp; rm -f google/protobuf/stubs/callback.h google/protobuf/stubs/bytestream.h google/protobuf/stubs/casts.h google/protobuf/stubs/common.h google/protobuf/stubs/hash.h google/protobuf/stubs/logging.h google/protobuf/stubs/macros.h google/protobuf/stubs/map_util.h google/protobuf/stubs/mutex.h google/protobuf/stubs/once.h google/protobuf/stubs/platform_macros.h google/protobuf/stubs/port.h google/protobuf/stubs/status.h google/protobuf/stubs/stl_util.h google/protobuf/stubs/stringpiece.h google/protobuf/stubs/strutil.h google/protobuf/stubs/template_util.h google/protobuf/any.pb.h google/protobuf/api.pb.h google/protobuf/any.h google/protobuf/arena.h google/protobuf/arena_impl.h google/protobuf/arenastring.h google/protobuf/descriptor_database.h google/protobuf/descriptor.h google/protobuf/descriptor.pb.h google/protobuf/duration.pb.h google/protobuf/dynamic_message.h google/protobuf/empty.pb.h google/protobuf/extension_set.h google/protobuf/extension_set_inl.h google/protobuf/field_mask.pb.h google/protobuf/generated_enum_reflection.h google/protobuf/generated_enum_util.h google/protobuf/generated_message_reflection.h google/protobuf/generated_message_table_driven.h google/protobuf/generated_message_util.h google/protobuf/has_bits.h google/protobuf/implicit_weak_message.h google/protobuf/io/io_win32.h google/protobuf/map_entry.h google/protobuf/map_entry_lite.h google/protobuf/map_field.h google/protobuf/map_field_inl.h google/protobuf/map_field_lite.h google/protobuf/map.h google/protobuf/map_type_handler.h google/protobuf/message.h google/protobuf/message_lite.h google/protobuf/metadata.h google/protobuf/metadata_lite.h google/protobuf/parse_context.h google/protobuf/port.h google/protobuf/port_def.inc google/protobuf/port_undef.inc google/protobuf/reflection.h google/protobuf/reflection_ops.h google/protobuf/repeated_field.h google/protobuf/service.h google/protobuf/source_context.pb.h google/protobuf/struct.pb.h google/protobuf/text_format.h google/protobuf/timestamp.pb.h google/protobuf/type.pb.h google/protobuf/unknown_field_set.h google/protobuf/wire_format.h google/protobuf/wire_format_lite.h google/protobuf/wrappers.pb.h google/protobuf/io/coded_stream.h google/protobuf/io/gzip_stream.h google/protobuf/io/printer.h google/protobuf/io/strtod.h google/protobuf/io/tokenizer.h google/protobuf/io/zero_copy_stream.h google/protobuf/io/zero_copy_stream_impl.h google/protobuf/io/zero_copy_stream_impl_lite.h google/protobuf/compiler/code_generator.h google/protobuf/compiler/command_line_interface.h google/protobuf/compiler/importer.h google/protobuf/compiler/parser.h google/protobuf/compiler/plugin.h google/protobuf/compiler/plugin.pb.h google/protobuf/compiler/cpp/cpp_generator.h google/protobuf/compiler/csharp/csharp_generator.h google/protobuf/compiler/csharp/csharp_names.h google/protobuf/compiler/java/java_generator.h google/protobuf/compiler/java/java_names.h google/protobuf/compiler/js/js_generator.h google/protobuf/compiler/js/well_known_types_embed.h google/protobuf/compiler/objectivec/objectivec_generator.h google/protobuf/compiler/objectivec/objectivec_helpers.h google/protobuf/compiler/php/php_generator.h google/protobuf/compiler/python/python_generator.h google/protobuf/compiler/ruby/ruby_generator.h google/protobuf/util/type_resolver.h google/protobuf/util/delimited_message_util.h google/protobuf/util/field_comparator.h google/protobuf/util/field_mask_util.h google/protobuf/util/json_util.h google/protobuf/util/time_util.h google/protobuf/util/type_resolver_util.h google/protobuf/util/message_differencer.h ) make[1]: Leaving directory '/home/siz/soft/protobuf-3.15.8/src' siz@ubuntu:~/soft/protobuf-3.15.8$ which protoc siz@ubuntu:~/soft/protobuf-3.15.8$ 重新安装protobuf protobuf github release 地址: https://github.com/protocolbuffers/protobuf/releases 下载对应的3.92版本: 并解压 cd protobuf-XXX/ ./autogen.sh ./configure make make check sudo make install sudo ldconfig # refresh shared library cache. 查看版本 protoc --version 至此安装完成","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.sizaif.com/tags/OpenCV/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"}],"author":"sizaif"},{"title":"OpenSSL 使用手册","slug":"OpenSSL-使用手册","date":"2021-08-10T06:34:10.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/e82eda1b/","link":"","permalink":"https://www.sizaif.com/posts/e82eda1b/","excerpt":"","text":"OpenSSL 命令行解析 😄 @Auther: sizaif 📆 2021-05-09 16:32:02 [TOC] 参考文档 服务端: https://www.openssl.org/docs/man1.0.2/man1/openssl-s_server.html 客户端:https://www.openssl.org/docs/man1.0.2/man1/s_client.html OpenSSL命令分为以下3个部分。 标准命令Standard commands 1.asn1parse: asn1parse用于解释用ANS.1语法书写的语句(ASN一般用于定义语法的构成) 演示命令操作顺序：4 -&gt; 5 -&gt; 3 -&gt; 2-&gt; 6 -&gt; 7 -&gt;8 2.ca: ca用于CA的管理. 用法： openssl ca [-options]。 code 2.1) -selfsign 使用对证书请求进行签名的密钥对来签发证书。即\"自签名\"，这种情况发生在生成证书的客户端、签发证书的CA都是同一台机器(也是我们大多数实验中的情况)，我们可以使用同一个密钥对来进行\"自签名\" 2.2) -in file 需要进行处理的PEM格式的证书 2.3) -out file 处理结束后输出的证书文件 2.4) -cert file 用于签发的根CA证书 2.5) -days arg 指定签发的证书的有效时间 2.6) -keyfile arg CA的私钥证书文件 2.7) -keyform arg CA的根私钥证书文件格式: 2.7.1) PEM 2.7.2) ENGINE 2.8) -key arg CA的根私钥证书文件的解密密码(如果加密了的话) 2.9) -config file 配置文件 3. X.509证书签发请求(CSR)管理 用法： openssl req [options] outfile code 3.1) -inform arg 输入文件格式 3.1.1) DER 3.1.2) PEM 3.2) -outform arg 输出文件格式 3.2.1) DER 3.2.2) PEM 3.3) -in arg 待处理文件 3.4) -out arg 待输出文件 3.5) -passin 用于签名待生成的请求证书的私钥文件的解密密码 3.6) -key file 用于签名待生成的请求证书的私钥文件 3.7) -keyform arg 3.7.1) DER 3.7.2) NET 3.7.3) PEM 3.8) -new 新的请求 3.9) -x509 输出一个X509格式的证书 3.10) -days X509证书的有效时间 3.11) -newkey rsa:bits 生成一个bits长度的RSA私钥文件，用于签发 3.12) -[digest] HASH算法 3.12.1) md5 3.12.2) sha1 3.12.3) md2 3.12.4) mdc2 3.12.5) md4 3.13) -config file 指定openssl配置文件 3.14) -text: text显示格式 4. genrsa: 生成RSA参数 用法： code openssl genrsa [args] [numbits] 4.1) 对生成的私钥文件是否要使用加密算法进行对称加密: 4.1.1) -des: CBC模式的DES加密 4.1.2) -des3: CBC模式的3DES加密 4.1.3) -aes128: CBC模式的AES128加密 4.1.4) -aes192: CBC模式的AES192加密 4.1.5) -aes256: CBC模式的AES256加密 4.2) -passout arg: arg为对称加密(des、3des、aes)的密码(使用这个参数就省去了console交互提示输入密码的环节) 4.3) -out file: 输出证书私钥文件 [numbits]: 密钥长度 example: 生成一个1024位的RSA私钥，并用3DES加密(密码为123456)，保存为server.key文件 openssl genrsa -out server.key -passout pass:123456 -des3 1024 5. RSA数据管理 用法： openssl rsa [options] outfile code 5.1) -inform arg 输入密钥文件格式: 5.1.1) DER(ASN1) 5.1.2) NET 5.1.3) PEM(base64编码格式) 5.2) -outform arg 输出密钥文件格式 5.2.1) DER 5.2.2) NET 5.2.3) PEM 5.3) -in arg 待处理密钥文件 5.4) -passin arg 输入这个加密密钥文件的解密密钥(如果在生成这个密钥文件的时候，选择了加密算法了的话) 5.5) -out arg 待输出密钥文件 5.6) -passout arg 如果希望输出的密钥文件继续使用加密算法的话则指定密码 5.7) -des: CBC模式的DES加密 5.8) -des3: CBC模式的3DES加密 5.9) -aes128: CBC模式的AES128加密 5.10) -aes192: CBC模式的AES192加密 5.11) -aes256: CBC模式的AES256加密 5.12) -text: 以text形式打印密钥key数据 5.13) -noout: 不打印密钥key数据 5.14) -pubin: 检查待处理文件是否为公钥文件 5.15) -pubout: 输出公钥文件 6. x509 openssl x509是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作 用法： openssl x509 [args] code 6.1) -inform arg 待处理X509证书文件格式 6.1.1) DER 6.1.2) NET 6.1.3) PEM 6.2) -outform arg 待输出X509证书文件格式 6.2.1) DER 6.2.2) NET 6.2.3) PEM 6.3) -in arg 待处理X509证书文件 6.4) -out arg 待输出X509证书文件 6.5) -req 表明输入文件是一个\"请求签发证书文件(CSR)\"，等待进行签发 6.6) -days arg 表明将要签发的证书的有效时间 6.7) -CA arg 指定用于签发请求证书的根CA证书 6.8) -CAform arg 根CA证书格式(默认是PEM) 6.9) -CAkey arg 指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有 6.10) -CAkeyform arg 指定根CA私钥证书文件格式(默认为PEM格式) 6.11) -CAserial arg 指定序列号文件(serial number file) 6.12) -CAcreateserial 如果序列号文件(serial number file)没有指定，则自动创建它 7 dhparam openssl dhparam用于生成和管理dh文件。dh(Diffie-Hellman)是著名的密钥交换协议，或称为密钥协商协议，它可以保证通信双方安全地交换密钥。但注意，它不是加密算法，所以不提供加密功能，仅仅只是保护密钥交换的过程。在openvpn中就使用了该交换协议 code openssl dhparam [-in filename] [-out filename] [-dsaparam] [-noout] [-text] [-rand file(s)] [numbits] 选项说明： -in filename：从filename文件中读取密钥交换协议参数。 -out filename：输出密钥交换协议参数到filename文件。 -dsaparam：指定此选项将使用dsa交换协议替代dh交换协议。虽然生成速度更快，但更不安全。 -noout：禁止输出任何信息。 -text：以文本格式输出dh协议。 -rand：指定随机数种子文件。 numbits：指定生成的长度。 使用 客户端 openssl s_client -key ./experiments/keystore/client.key -cert ./experiments/keystore/client.crt -CAfile ./experiments/keystore/demoCA/cacert.pem 服务端 openssl s_server -key ./experiments/keystore/server.key -cert ./experiments/keystore/server.crt -CAfile ./experiments/keystore/demoCA/cacert.pem -accept 4433 -HTTP","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"}],"author":"sizaif"},{"title":"OpenCV Tensorflow C++API   Protobuf Eigen3 编译过程","slug":"OpenCV-Tensorflow-C-API-Protobuf-eigen3-编译过程","date":"2021-08-10T06:22:04.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/56ff1cb1/","link":"","permalink":"https://www.sizaif.com/posts/56ff1cb1/","excerpt":"","text":"OpenCV Tensorflow C++API Protobuf eigen3 编译过程 @auther by sizaif 2021-08-10 14:22:25 [TOC] OpenCV 首先安装OpenCV的依赖文件，在终端运行下面命令： code sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev # if errorE: unable to locate libjasper-dev sudo add-apt-repository \"deb http://security.ubuntu.com/ubuntu xenial-security main\" # or vim sources.list add \"deb http://security.ubuntu.com/ubuntu xenial-security main\" and update vim /etc/apt/sources.list sudo apt update sudo apt install libjasper1 libjasper-dev Install compiler and build tools To compile OpenCV you will need a C++ compiler. Usually it is G++/GCC or Clang/LLVM: Install GCC… sudo apt install -y g++ … or Clang: sudo apt install -y clang OpenCV uses CMake build configuration tool: sudo apt install -y cmake CMake can generate scripts for different build systems, e.g. make,ninja: Install Make… sudo apt install -y make … or Ninja: sudo apt install -y ninja-build Install tool for getting and unpacking sources: wget and unzip … sudo apt install -y wget unzip … or git : sudo apt install -y git Download sources There are two methods of getting OpenCV sources: Download snapshot of repository using web browser or any download tool (~80-90Mb) and unpack it… wget -O opencv.zip https://github.com/opencv/opencv/archive/master.zipunzip opencv.zipmv opencv-master opencv … or clone repository to local machine using git to get full change history (&gt;470Mb): git clone https://github.com/opencv/opencv.gitgit -C opencv checkout master Note Snapshots of other branches, releases or commits can be found on the GitHub and the official download page. Configure and build Create build directory: mkdir -p build &amp;&amp; cd build Configure - generate build scripts for the preferred build system: For make… #自定义路径安装OpenCV 到 /usr/local/opencv 中cmake -D CMAKE_INSTALL_PREFIX=/usr/local/opencv ../opencv … or for ninja : cmake -GNinja ../opencv Build - run actual compilation process: Using make … make -j4 … or ninja : ninja Note Configure process can download some files from the internet to satisfy library dependencies, connection failures can cause some of modules or functionalities to be turned off or behave differently. Refer to the OpenCV installation overview and OpenCV configuration options reference tutorials for details and full configuration options reference. If you experience problems with the build process, try to clean or recreate the build directory. Changes in the configuration like disabling a dependency, modifying build scripts or switching sources to another branch are not handled very well and can result in broken workspace. Make can run multiple compilation processes in parallel, -j&lt;NUM&gt; option means “run jobs simultaneously”. Ninja will automatically detect number of available processor cores and does not need -j option. Check build results After successful build you will find libraries in the build/lib directory and executables (test, samples, apps) in the build/bin directory: ls binls lib CMake package files will be located in the build root: ls OpenCVConfig*.cmakels OpenCVModules.cmake Install Warning The installation process only copies files to predefined locations and does minor patching. Installing using this method does not integrate opencv into the system package registry and thus, for example, opencv can not be uninstalled automatically. We do not recommend system-wide installation to regular users due to possible conflicts with system packages. By default OpenCV will be installed to the /usr/local directory, all files will be copied to following locations: /usr/local/bin - executable files /usr/local/lib - libraries (.so) /usr/local/cmake/opencv4 - cmake package /usr/local/include/opencv4 - headers /usr/local/share/opencv4 - other files (e.g. trained cascades in XML format) Since /usr/local is owned by the root user, the installation should be performed with elevated privileges (sudo): sudo make install or sudo ninja install Installation root directory can be changed with CMAKE_INSTALL_PREFIX configuration parameter, e.g. -DCMAKE_INSTALL_PREFIX=$HOME/.local to install to current user’s local directory. Installation layout can be changed with OPENCV_*_INSTALL_PATH parameters. See OpenCV configuration options reference for details. Generated on Tue Apr 20 2021 02:31:39 for OpenCV by 1.8.13 Tensorflow bazel code # Bazel needs a C++ compiler and unzip / zip in order to work: sudo apt install g++ unzip zip # Run the installer chmod +x bazel-&lt;version>-installer-linux-x86_64.sh ./bazel-&lt;version>-installer-linux-x86_64.sh --user # Set up your environment vim ~/.bashrc export PATH=\"$PATH:$HOME/bin\" source ~/.bashrc tensorflow-v2.4.0 code # 安装以下构建工具以配置开发环境。 sudo apt install python3-dev python3-pip pip install numpy # 安装 Bazel git clone https://github.com/tensorflow/tensorflow.git cd tensorflow git checkout branch_name # r2.2, r2.3, etc. ./configure # CUDA GPU bazel build --config=opt --config=cuda //tensorflow:libtensorflow_cc.so # CPU bazel build --config=opt //tensorflow:libtensorflow_cc.so # 编译完成后, 将头文件 ( bazel-bin/tensorflow 和 下 **.so 复制到 /usr/local/include/tf/tensorflow 和 /usr/local/lib mkdir /usr/local/include/tf cp -r bazel-bin/tensorflow/* /usr/local/include/tf/tensorflow/ sudo cp -r bazel-bin/tensorflow/*.so /usr/local/lib/ 测试 CMakeLists.txt CMakeLists.txt cmake_minimum_required(VERSION 2.8) # project Name &amp; Version project(STOtest) # find_package find_package(OpenCV REQUIRED) # set location # Openblas set(OpenBlas_DIR /usr/local/OpenBlas) # eigen set(Eigen_DIR /usr/local/include/eigen3) # tensorflow set(Tensorflow_INCLUDES /usr/local/include/tf/ /usr/local/include/tf/tensorflow/ /usr/local/include/tf/tensorflow/third-party) set(Tensorflow_LIBS /usr/local/lib/libtensorflow_cc.so /usr/local/lib/libtensorflow_framework.so) # protobuf set(Protobuf_INCLUDES /usr/local/include/google) set(Protobuf_LIBS /usr/local/bin/protoc) message(STATUS: \"OpenBlas_DIR= $&#123;OpenBlas_DIR&#125;\") message(STATUS \"OpenCV library status:\") message(STATUS \" config=: $&#123;OpenCV_DIR&#125;\") message(STATUS \" version=: $&#123;OpenCV_VERSION&#125;\") message(STATUS \" libraries=: $&#123;OpenCV_LIBS&#125;\") message(STATUS \" include path=: $&#123;OpenCV_INCLUDE_DIRS&#125;\") # include include_directories( $&#123;Tensorflow_INCLUDES&#125; $&#123;Eigen_DIR&#125; $&#123;OpenBlas_DIR&#125; $&#123;Protobuf_INCLUDES&#125; ) # src cpp aux_source_directory(./src DIR_SRCS) add_executable( main .$&#123;DIR_SRCS&#125;) # target target_link_libraries(main PRIVATE $&#123;OpenCV_LIBS&#125; $&#123;Tensorflow_LIBS&#125; $&#123;Protobuf_LIBS&#125;) code &#x2F;&#x2F;#include &quot;opencv2&#x2F;highgui.hpp&quot; &#x2F;&#x2F;#include &quot;opencv2&#x2F;imgproc.hpp&quot; #include &lt;tensorflow&#x2F;core&#x2F;platform&#x2F;env.h&gt; #include &lt;tensorflow&#x2F;core&#x2F;public&#x2F;session.h&gt; #include &lt;iostream&gt; &#x2F;&#x2F;susing namespace cv; using namespace std; using namespace tensorflow; int main( ) &#123; cout &lt;&lt; &quot;hello tensorflow&quot; &lt;&lt;endl; Session* session; Status status &#x3D; NewSession(SessionOptions(), &amp;session); if (!status.ok()) &#123; cout &lt;&lt; status.ToString() &lt;&lt; endl; cout &lt;&lt;&quot;Session not ok&quot; &lt;&lt; endl; return 1; &#125; cout &lt;&lt; &quot;Session successfully created.&quot;&lt;&lt;endl; return 0; &#125; Protobuf 1）上Github下载protocbuf源码包 https://github.com/protocolbuffers/protobuf/releases/tag/vX.X.X 2）安装依赖包 sudo apt-get install autoconf automake libtool curl make g++ unzip 3）进入源码目录，执行./autogen.sh生成configure文件 4）依次执行 code ./configure make make check sudo make install sudo ldconfig # refresh shared library cache. # 验证版本 siz@ubuntu:~$ protoc --version libprotoc 3.9.2 siz@ubuntu:~$ whereis protoc protoc: /usr/local/bin/protoc Eigen3 简单命令安装 sudo apt-get install libeigen3-dev 源码编译安装 code http://eigen.tuxfamily.org/index.php?title=Main_Page git clone https://gitlab.com/libeigen/eigen.git mkdir build cd build cmake .. sudo make instal # 安装成功后,头文件路径在 /usr/local/include/eigen3/ # CMakeLists.txt 中添加 eigen3 头文件 include_directories( \"/usr/include/eigen3\" ) OpenBlas code git clone https://github.com/xianyi/OpenBLAS.git cd OpenBLAS make make PREFIX=/usr/local/Openblas install","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"OpenCV","slug":"机器学习/OpenCV","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/OpenCV/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.sizaif.com/tags/OpenCV/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"}],"author":"sizaif"},{"title":"GnuTLS 使用手册","slug":"GnuTLS-使用手册","date":"2021-08-10T06:20:43.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/89554caf/","link":"","permalink":"https://www.sizaif.com/posts/89554caf/","excerpt":"","text":"GnuTLS 使用手册 😄 @by sizaif 📆 2021-05-17 16:23:57 [TOC] 命令行解析 gnutls-serv https://gnutls.org/manual/html_node/gnutls_002dserv-Invocation.html GnuTLS server gnutls-serv - GnuTLS server Usage: gnutls-serv [ -&lt;flag> [&lt;val>] | --&lt;name>[&#123;=| &#125;&lt;val>] ]... -d, --debug=num Enable debugging - it must be in the range: 0 to 9999 --sni-hostname=str Server's hostname for server name extension --sni-hostname-fatal Send fatal alert on sni-hostname mismatch --alpn=str Specify ALPN protocol to be enabled by the server - may appear multiple times --alpn-fatal Send fatal alert on non-matching ALPN name --noticket Don't accept session tickets --earlydata Accept early data --maxearlydata=num The maximum early data size to accept - it must be in the range: greater than or equal to 1 --nocookie Don't require cookie on DTLS sessions -g, --generate Generate Diffie-Hellman parameters -q, --quiet Suppress some messages --nodb Do not use a resumption database --http Act as an HTTP server --echo Act as an Echo server --crlf Do not replace CRLF by LF in Echo server mode -u, --udp Use DTLS (datagram TLS) over UDP --mtu=num Set MTU for datagram TLS - it must be in the range: 0 to 17000 --srtp-profiles=str Offer SRTP profiles -a, --disable-client-cert Do not request a client certificate - prohibits the option 'require-client-cert' -r, --require-client-cert Require a client certificate --verify-client-cert If a client certificate is sent then verify it. -b, --heartbeat Activate heartbeat support --x509fmtder Use DER format for certificates to read from --priority=str Priorities string --dhparams=file DH params file to use - file must pre-exist --x509cafile=str Certificate file or PKCS #11 URL to use --x509crlfile=file CRL file to use - file must pre-exist --x509keyfile=str X.509 key file or PKCS #11 URL to use - may appear multiple times --x509certfile=str X.509 Certificate file or PKCS #11 URL to use - may appear multiple times --rawpkkeyfile=str Private key file (PKCS #8 or PKCS #12) or PKCS #11 URL to use - may appear multiple times --rawpkfile=str Raw public-key file to use - requires the option 'rawpkkeyfile' - may appear multiple times --srppasswd=file SRP password file to use - file must pre-exist --srppasswdconf=file SRP password configuration file to use - file must pre-exist --pskpasswd=file PSK password file to use - file must pre-exist --pskhint=str PSK identity hint to use --ocsp-response=str The OCSP response to send to client - may appear multiple times --ignore-ocsp-response-errors Ignore any errors when setting the OCSP response -p, --port=num The port to connect to -l, --list Print a list of the supported algorithms and modes --provider=file Specify the PKCS #11 provider library - file must pre-exist --keymatexport=str Label used for exporting keying material --keymatexportsize=num Size of the exported keying material --recordsize=num The maximum record size to advertise - it must be in the range: 0 to 16384 --httpdata=file The data used as HTTP response - file must pre-exist -v, --version[=arg] output version information and exit -h, --help display extended usage information and exit -!, --more-help extended usage information passed thru pager Options are specified by doubled hyphens and their name or by a single hyphen and the flag character. Server program that listens to incoming TLS connections. 使用 服务端 Note that the server listens to port 5556 by default. 例子 gnutls-serv --http --x509keyfile experiments/keystore/rsa2048_key.pem --x509certfile experiments/keystore/rsa2048_cert.pem --x509cafile experiments/keystore/rsa2048_cert.pem --pskpasswd experiments/keystore/keys.psk --priority NORMAL:+PSK:+SRP --mtu 1500 -p 30002\"","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GnuTLS","slug":"GnuTLS","permalink":"https://www.sizaif.com/tags/GnuTLS/"}],"author":"sizaif"},{"title":"Fuckopenssl 1.0.1l","slug":"fuckopenssl-1-0-1l","date":"2021-08-10T06:19:18.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/2dc41376/","link":"","permalink":"https://www.sizaif.com/posts/2dc41376/","excerpt":"","text":"fuckopenssl 1.0.1l [TOC] 2021-08-10 14:19:38 @Auther by : sizaif 安装 openssl 1.0.1l 不整幺蛾子, 就默认安装位置 code wget https://www.openssl.org/source/openssl-1.0.1l.tar.gz tar xzf openssl-1.0.1l.tar.gz cd openssl-1.0.1l ./config enable-ssl2 enable-weak-ciphers make &amp;&amp; make install # 默认安装位置在 /usr/local/ssl 更改版本信息 code # 将旧版本的openssl进行备份 # 如果已经是root 了 就不用sudo sudo mv /usr/bin/openssl /usr/bin/openssl.old # 将新版本的openssl进行软链接 sudo ln -s /usr/local/ssl/bin/openssl /usr/bin/openssl #进入etc目录 cd /etc/ #下一步一定要切换到root用户 # 如果已经是root 用户, 直接执行 echo \"/usr/local/lib\" >> ld.so.conf su #将openssl的安装路径加入配置中 echo \"/usr/local/lib\" >> ld.so.conf # 重新加载配置 ldconfig 结果如图: 图片 编译drown git clone https://github.com/Tim---/drown SSL_PREFIX=/usr/local/ssl make 结果如图: 图片 ./decrypt host:port certfile c # ./decrypt 127.0.0.1:7899 certfile c # Passive attack Passive attack # 因为已经将 openssl1.0.1l 配置到系统环境, 所以可以直接使用openssl 命令 # openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days # 结果如下: ######################################################################################### root@iZj6cg4e6vhdv5s3hpkoffZ:~/supengfei/drown/fuck# openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 123 Generating a 2048 bit RSA private key ...........................+++ ....+++ writing new private key to 'key.pem' Enter PEM pass phrase: # 这里输入的是fuckopenssl Verifying - Enter PEM pass phrase: ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [AU]:zh State or Province Name (full name) [Some-State]:beijing Locality Name (eg, city) []:beijing Organization Name (eg, company) [Internet Widgits Pty Ltd]:IBM Organizational Unit Name (eg, section) []:123 Common Name (e.g. server FQDN or YOUR name) []:root Email Address []:123456@123.com ######################################################################################### openssl s_server -cert cert.pem -key key.pem -accept 4433 -www # ######################################################################################### root@iZj6cg4e6vhdv5s3hpkoffZ:~/supengfei/drown/fuck# openssl s_server -cert cert.pem -key key.pem -accept 4433 -www Enter pass phrase for key.pem: # 这里输入的是上面的fuckopenssl Using default temp DH parameters Using default temp ECDH parameters ACCEPT ######################################################################################### # 打开新窗口 # 安装 tshark apt-get install tshark # tshark -i lo -w handshakes.cap tcp port 4433 code # 打开新窗口 # openssl 已经配置到系统环境, 所以直接使用openssl 命令 for i in $(seq 1000) ; do (echo 'GET / HTTP/1.1\\r\\n'; sleep 0.1) | openssl s_client -connect 127.0.0.1:4433 -cipher kRSA; done # 展示 ######################################################################################### New, TLSv1/SSLv3, Cipher is AES256-GCM-SHA384 SSL-Session: Protocol : TLSv1.2 Cipher : AES256-GCM-SHA384 Session-ID: 49EB9A81AD65AE80476F9F72CF4472D17CFB4E33539DAAE5734B5BD2EFD878F3 Session-ID-ctx: 01000000 Master-Key: CCCF32EBBEC91A411D63589FBFAD0B2CE8290797D2749BAF3FFD5C05A4CAB79CFE2E0DAC2939155721DF65218B9757EE Key-Arg : None PSK identity: None PSK identity hint: None SRP username: None Start Time: 1620033794 Timeout : 300 (sec) Verify return code: 0 (ok) --- 128 items in the session cache 0 client connects (SSL_connect()) 0 client renegotiates (SSL_connect()) 0 client connects that finished 1000 server accepts (SSL_accept()) 0 server renegotiates (SSL_accept()) 1000 server accepts that finished 0 session cache hits 0 session cache misses 0 session cache timeouts 0 callback cache hits 872 cache full overflows (128 allowed) --- no client certificate available &lt;/BODY>&lt;/HTML> read:errno=0 ######################################################################################### # get the encrypted pre-master secrets for each session with tshark -r handshakes.cap -d tcp.port==4433,ssl -T fields -e ssl.handshake.epms -Y ssl.handshake.epms | tr -d : 结果如下: 图片 code # To decrypt these handshakes, we need an OpenSSL server accepting SSLv2 connections : openssl s_server -cert cert.pem -key key.pem -accept 4434 -www -ssl2 ######################################################################################### root@iZj6cg4e6vhdv5s3hpkoffZ:~/supengfei/drown/fuck# openssl s_server -cert cert.pem -key key.pem -accept 4434 -www -ssl2 Enter pass phrase for key.pem: # 这里输入的是 上面的pem: fuckfuckfuck Using default temp DH parameters Using default temp ECDH parameters ACCEPT ######################################################################################### # We can now decrypt the encrypted pre-master secret #在drown/fuck/目录下执行 ######################################################################################### # root@iZj6cg4e6vhdv5s3hpkoffZ:~# ll supengfei/drown/fuck/ # total 8024 # drwxr-xr-x 2 root root 4096 May 3 17:33 ./ # drwxr-xr-x 4 root root 4096 May 3 17:28 ../ # -rw-r--r-- 1 root root 1375 May 3 17:14 cert.pem # -rw------- 1 root root 8196592 May 3 17:23 handshakes.cap # -rw-r--r-- 1 root root 1834 May 3 17:14 key.pem # -rw-r--r-- 1 root root 0 May 3 17:33 pms.tx # -rw-r--r-- 1 root root 0 May 3 17:28 pms.txt # root@iZj6cg4e6vhdv5s3hpkoffZ:~# ######################################################################################### #这个位置是cert.perm handshakes.cap 的位置 # ../decrypt 是drown目录下编译后会生成一个decrypt可执行文件位置 tshark -r handshakes.cap -d tcp.port==4433,ssl -T fields -e ssl.handshake.epms -Y ssl.handshake.epms | tr -d : | ../decrypt localhost:4434 cert.pem > pms.txt 结果展示 图片 code RSA 830cdf70dc488c8b 0303b45e46017e9dfefd22a26b7c64648fb2d00fcf8627cb0070132e370ab57a1b595e2544b1668caf3618942c2a0e34 RSA a62c4d1a5c4322e2 0303e37a220b3300e6c0d139d55a1c44c2429f11b0613d746db390beb16ad8bb0203f7494d3e7385a294e4f8a18fa5ae RSA 7215d21d1c22dfb8 0303434023187d88c73a921af635d7861ed60d66ebc4053e487ea85ab6d6b76dd373844063e8da156505dc8466310395 RSA 1976fb27fbccbd36 0303c9c320f9cc92567bc488c502ffacbbef28241348e30df4b2d55fdd7f8680fb201b5f75e02b9bd1db4e8e2c2fdf84 RSA 3b56f9c80a754f77 0303e8abf59f4132b1634f2b4e04bf4362c7f6dae5077dc9b6bb0c48efe0c7be47a256267688c7e28e70a28c830e6af6 RSA 1686f037050931a5 03036cb5a1851a174a9f43f97be770bd22411da688197bef08154d7f91f687dc6e0090d35ce147862e8bcc5c7218398c RSA 6ce5d3fd06970d25 0303e4da20c0d6dd5e03bf97d0ee4d802cab150810df524359ab990df0a01f2d51fe6c69ebfdae99ff1b1c9042367966 RSA 0e447f6c36cadd1c 030313b76ce57518d001229385f6b3ca376821692f72401a32e8b2b9a1322f523b9dc3c4808e7975e6e96c3883c3b8c4 RSA 830280803c06b66a 0303c80069cbb7517d723d8476ff22077e7b33b10c67872093bc7793e01a501d56c2ea2f9d16266b32bd933d8d957f2b RSA 4ee250f545d2f1ae 0303096a212344c48bfaa3153f1d1196c81beb918d61e9497033b9bd4fb118dc474187fb0965de2eff0448c072ee46e0 RSA 7b5fddbfbc5e2586 0303c7714d54a817514c086f8d4004547fb6191cbc5cd36ec7816b4ab81295278b5ba13054014413cd3abf75faa05d60 RSA 6053a37a45c64592 03035126dad66420ee530e50be0cfdb6aca5cb3e6897c3a2c1cb56c39704112efd36069e450814ccd70b629dc23e26b4 RSA a04a28e475029688 03036657caed02639f6b450a0c7293f4abf3ad188652bd443f2d27e6ffe53f859d1d91441aa0fcc646648557ecb910f8 RSA 1d37821396fecd87 030375a2214a9b475fe93ddd424a71536a0642a07d0d093abdcc84a0e1b89d3f052719e44d1816f2698d24b67ef7cc26 RSA 62a5f513fc94585b 0303a873790bf018f5d6c4e1ac4d87487a34e58471762a2dffd6d92e122ec284b7dc2206569118e0a6ebfb4c2960457d RSA 8de0c774b04a20d2 0303e8748fbea20c72709a8dc436fc631521cbd068c6beddfacd4fb224ef03da92e76af9bbf3b740908efd699a797973 RSA a7575ef2b95aeeeb 03033f49c4e3b9642fddcda12c05601d69113adf7bebc4c0cb963ff898373a50a0494564c97a9e0ac3e18e1f709b68a9","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"}],"author":"sizaif"},{"title":"安装Openssl GNUTLS WolfSSL 手册","slug":"安装Openssl-GNUTLS-WolfSSL-手册","date":"2021-08-10T06:11:40.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/b924c044/","link":"","permalink":"https://www.sizaif.com/posts/b924c044/","excerpt":"","text":"安装Openssl GNUTLS WolfSSL 手册 😄 @Auther sizaif 📆2021-05-18 09:19:35 [TOC] OpenSSL 项目地址:https://www.openssl.org/ 安装依赖库 # 安装ssl 依赖库 sudo apt update sudo apt-get install libssl-dev make 下载源码并进入文件 https://www.openssl.org/source/old/1.1.1/ # 下载OpenSSL对应版本源码 https://www.openssl.org/source/old/1.1.1/openssl-1.1.1j.tar.gz # 进入文件后 cd openssl-XXX/ 编译安装 编译安装有两种方式, 一种是编译后,不进行安装,即不把编译后的文件安装到系统环境下, 输入openssl version版本不变 另一种是编译后进行安装,更换到系统环境下 第一种,仅编译, 使用时通过/openssl-xxx/apps/openssl 使用这个版本的openssl 这样的优势是,可以快速测试多个openssl的版本,而不用重复更新安装 code # 配置环境 prefix 是安装目录，openssldir是配置文件目录 # # Configure --prefix=/YOUR PATH ./Configure # or ./config # ./config --prefix=/YOUR PATH # 编译安装 #因为这里我们不需要安装,只需要拿到编译的结果去运行 # 所以 不需要make install make 第二种,编译安装, 使用时直接使用openssl 命令来使用新安装的版本 code # 编译 需要等好长时间, 不如趁这个功夫取喝个茶,上个洗手间 make # 编译完成后, 进行安装 , 等待时间也不短, 不如去刷个小视频 # make install # 将旧版本的openssl进行备份 sudo mv /usr/bin/openssl /usr/bin/openssl.old # 将新版本的openssl进行软链接 sudo ln -s /usr/local/bin/openssl /usr/bin/openssl #进入etc目录 cd /etc/ #下一步一定要切换到root用户 su #将openssl的安装路径加入配置中 echo \"/usr/local/lib\" >> ld.so.conf # 重新加载配置 ldconfig # 测试 版本 得到如下结果 openssl version >OpenSSL 1.1.1b 26 Feb 2019 # 测试 ll /usr/local/include/ ll /usr/local/lib/ # 如下结果 #如果需要更换版本的话,修改软链接的名称即可，参照： #将旧版本进行备份 sudo mv /usr/include/openssl /usr/include/openssl.old #将新版本进行软链接 sudo ln -s /usr/local/include/openssl /usr/include/openssl GnuTLS 项目地址: https://www.gnutls.org/index.html 安装依赖库 编译需要 libnettle 和gmplib Debian/Ubuntu: Debian/Ubuntu apt-get install -y dash git-core autoconf libtool gettext autopoint apt-get install -y automake autogen nettle-dev libp11-kit-dev libtspi-dev libunistring-dev apt-get install -y guile-2.0-dev libtasn1-6-dev libidn2-0-dev gawk gperf apt-get install -y libunbound-dev dns-root-data bison help2man gtk-doc-tools apt-get install -y texinfo texlive texlive-generic-recommended texlive-extra-utils apt-get install pkg-config 编译安装 解释如下 The GnuTLS Guile bindings are available for the Guile 3.0 and 2.2 series, as well as the legacy 2.0 and even 1.8 series. By default they are installed under the GnuTLS installation directory, typically /usr/local/share/guile/site/). Normally Guile will not find the module there without help. You may experience something like this: >$ guile >… >scheme@(guile-user)> (use-modules (gnutls)) >ERROR: no code for module (gnutls) There are two ways to solve this. The first is to make sure that when building GnuTLS, the Guile bindings will be installed in the same place where Guile looks. You may do this by using the --with-guile-site-dir parameter as follows: >$ ./configure --with-guile-site-dir=no 命令如下 # --with-guile-site-dir=no 构建GnuTLS时，Guile绑定将安装在与Guile相同的位置, 解释如上 # 因为只需要测试GnuTls 所以使用如下的命令 # 视实际情况决定 ./configure --with-guile-site-dir=no --with-included-libtasn1 --with-included-unistring --without-p11-kit --disable-guile --disable-doc ./configure结果 ./configure结果 configure: summary of build options: version: 3.6.7 shared 53:2:23 Host/Target system: x86_64-pc-linux-gnu Build system: x86_64-pc-linux-gnu Install prefix: /usr/local Compiler: gcc Valgrind: no CFlags: -g -O2 Library types: Shared=yes, Static=no Local libopts: yes Local libtasn1: yes Local unistring: yes Use nettle-mini: no Documentation: no (manpages: no) configure: External hardware support: /dev/crypto: no Hardware accel: x86-64 Padlock accel: yes Random gen. variant: getrandom PKCS#11 support: no TPM support: no configure: Optional features: (note that included applications might not compile properly if features are disabled) SSL3.0 support: no SSL2.0 client hello: yes Allow SHA1 sign: no DTLS-SRTP support: yes ALPN support: yes OCSP support: yes SRP support: yes PSK support: yes DHE support: yes ECDHE support: yes GOST support: yes Anon auth support: yes Heartbeat support: yes IDNA support: no Non-SuiteB curves: no FIPS140 mode: no configure: Optional libraries: Guile wrappers: no C++ library: yes DANE library: no OpenSSL compat: no configure: System files: Trust store pkcs11: Trust store dir: Trust store file: /etc/ssl/certs/ca-certificates.crt Blacklist file: CRL file: Priority file: /etc/gnutls/default-priorities DNSSEC root key file: /etc/unbound/root.key configure: WARNING: *** *** The DNSSEC root key file in /etc/unbound/root.key was not found. *** This file is needed for the verification of DNSSEC responses. *** Use the command: unbound-anchor -a \"/etc/unbound/root.key\" *** to generate or update it. *** 安装 同Openssl 一样, 有两种方式, 仅 make 和 make &amp;&amp; make install code # 编译 make # 编译后 在 src 目录下 可以得到 gnutls-cli gnutls-cli-debug gnutls-serv 可执行文件 # 验证版本 $root@380xxx:/xxx/gnutls-3.6.7# ./src/gnutls-serv -v gnutls-serv 3.6.7 Copyright (C) 2000-2019 Free Software Foundation, and others, all rights reserved. This is free software. It is licensed for use, modification and redistribution under the terms of the GNU General Public License, version 3 or later &lt;http://gnu.org/licenses/gpl.html> Please send bug reports to: &lt;bugs@gnutls.org> ######################################################################################## # 如果 安装的话 执行 make install make install # 会在 /usr/local/include/gnutls 生成头文件 # /usr/local/bin/ 下 生成 gnutls-cli gnutls-cli-debug gnutls-serv 可执行文件 # 验证版本 $root@380xxx:/xxx/gnutls-3.6.7# /usr/local/bin/gnutls-serv -v gnutls-serv 3.6.7 Copyright (C) 2000-2019 Free Software Foundation, and others, all rights reserved. This is free software. It is licensed for use, modification and redistribution under the terms of the GNU General Public License, version 3 or later &lt;http://gnu.org/licenses/gpl.html> Please send bug reports to: &lt;bugs@gnutls.org> WolfSSL https://github.com/wolfSSL/wolfssl https://www.wolfssl.com/ 下载源码 https://www.wolfssl.com/download/# 手动下载 编译安装 ./configure#./configure --help ./configure --enable-psk --enable-pwdbased --enable-rsa --enable-sha --enable-debug --disable-dh --disable-ecc C_EXTRA_FLAGS=-DWOLFSSL_STATIC_PSK 结果 code Configuration summary for wolfssl version 4.7.0 * Installation prefix: /usr/local * System type: pc-linux-gnu * Host CPU: x86_64 * C Compiler: gcc * C Flags: -DWOLFSSL_STATIC_PSK -g -ggdb -O0 -Wno-pragmas -Wall -Wno-strict-aliasing -Wextra -Wu nknown-pragmas --param=ssp-buffer-size=1 -Waddress -Warray-bounds -Wbad-function-cast -Wchar-subscripts -Wcomment -Wfloa t-equal -Wformat-security -Wformat=2 -Wmaybe-uninitialized -Wmissing-field-initializers -Wmissing-noreturn -Wmissing-pro totypes -Wnested-externs -Wnormalized=id -Woverride-init -Wpointer-arith -Wpointer-sign -Wredundant-decls -Wshadow -Wsig n-compare -Wstrict-overflow=1 -Wswitch-enum -Wundef -Wunused -Wunused-result -Wunused-variable -Wwrite-strings -fwrapv * C++ Compiler: * C++ Flags: * CPP Flags: * CCAS Flags: -DWOLFSSL_STATIC_PSK * LIB Flags: -pie -z relro -z now * Debug enabled: yes * Coverage enabled: * Warnings as failure: no * make -j: 9 * VCS checkout: no Features * FIPS: no * Single threaded: no * Filesystem: yes * OpenSSH Build: no * OpenSSL Extra API: no * OpenSSL Coexist: no * Old Names: yes * Max Strength Build: no * Distro Build: no * Reproducible Build: no * fastmath: yes * Assembly Allowed: yes * sniffer: no * snifftest: no * ARC4: no * AES: yes * AES-NI: no * AES-CBC: yes * AES-GCM: yes * AES-CCM: no * AES-CTR: no * AES-CFB: no * AES-OFB: no * DES3: no * IDEA: no * Camellia: no * NULL Cipher: no * MD2: no * MD4: no * MD5: yes * RIPEMD: no * SHA: yes * SHA-224: yes * SHA-384: yes * SHA-512: yes * SHA3: yes * SHAKE256: yes * BLAKE2: no * BLAKE2S: no * CMAC: no * keygen: no * certgen: no * certreq: no * certext: no * certgencache: no * HC-128: no * RABBIT: no * CHACHA: yes * XCHACHA: no * Hash DRBG: yes * PWDBASED: yes * scrypt: no * wolfCrypt Only: no * HKDF: yes * X9.63 KDF: no * MD4: no * PSK: yes * Poly1305: yes * LEANPSK: no * LEANTLS: no * RSA: yes * RSA-PSS: yes * DSA: no * DH: no * DH Default Parameters: yes * ECC: no * ECC Custom Curves no * ECC Minimum Bits 224 * CURVE25519: no * ED25519: no * CURVE448: no * ED448: no * FPECC: no * ECC_ENCRYPT: no * ASN: yes * Anonymous cipher: no * CODING: yes * MEMORY: yes * I/O POOL: no * LIGHTY: no * HAPROXY: no * STUNNEL: no * Apache httpd: no * NGINX: no * ASIO: no * LIBWEBSOCKETS: no * Qt no * Qt Unit Testing no * SIGNAL: no * ERROR_STRINGS: yes * DTLS: no * SCTP: no * Indefinite Length: no * Multicast: no * SSL v3.0 (Old): no * TLS v1.0 (Old): no * TLS v1.1 (Old): yes * TLS v1.2: yes * TLS v1.3: yes * Post-handshake Auth: no * Early Data: no * Send State in HRR Cookie: no * OCSP: no * OCSP Stapling: no * OCSP Stapling v2: no * CRL: no * CRL-MONITOR: no * Persistent session cache: no * Persistent cert cache: no * Atomic User Record Layer: no * Public Key Callbacks: no * NTRU: no * QSH: no * Whitewood netRandom: no * Server Name Indication: no * ALPN: no * Maximum Fragment Length: no * Trusted CA Indication: no * Truncated HMAC: no * Supported Elliptic Curves: no * FFDHE only in client: no * Session Ticket: no * Extended Master Secret: yes * Renegotiation Indication: no * Secure Renegotiation: no * Fallback SCSV: no * Keying Material Exporter: no * All TLS Extensions: no * PKCS#7 no * S/MIME no * wolfSSH no * wolfTPM no * wolfSCEP no * Secure Remote Password no * Small Stack: no * Linux Kernel Module: no * valgrind unit tests: no * LIBZ: no * Examples: yes * Crypt tests: yes * Stack sizes in tests: no * Heap stats in tests: no * User Crypto: no * Fast RSA: no * Single Precision: no * SP math implementation: no * Async Crypto: no * PKCS#11: no * PKCS#12: yes * Cavium Nitrox: no * Cavium Octeon (Sync): no * Intel Quick Assist: no * ARM ASM: no * AES Key Wrap: no * Write duplicate: no * Xilinx Hardware Acc.: no * Inline Code: yes * Linux AF_ALG: no * Linux devcrypto: no * Crypto callbacks: no code make # 如果遇到错误 'aclocal-1.15' is missing on your system” # 先执行autoreconf -f -i 在执行 ./configure 在 make ## 安装 如上 sudo make install # To test the build, run the testsuite program from the root wolfSSL directory: ./testsuite/testsuite.test # or use autoconf to run the testsuite as well as the standard wolfSSL API and crypto tests: make test ############################ # 如果没有configure 使用 cmake # 安装 cmake sudo apt-get install cmake # Usage: mkdir build &amp;&amp; cd build cmake .. cmake --build . 结果运行 在根目录下/exaples/ 中 有 server 和 client","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GnuTLS","slug":"GnuTLS","permalink":"https://www.sizaif.com/tags/GnuTLS/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"},{"name":"WolfSSL","slug":"WolfSSL","permalink":"https://www.sizaif.com/tags/WolfSSL/"}],"author":"sizaif"},{"title":"本地Navicat连接本地docker容器中mysql","slug":"本地navicat连接本地docker容器中mysql","date":"2021-08-10T06:04:59.000Z","updated":"2021-09-19T10:15:32.000Z","comments":true,"path":"posts/35862d23/","link":"","permalink":"https://www.sizaif.com/posts/35862d23/","excerpt":"","text":"本地navicat连接本地docker容器中mysql 😄 @Auther by sizaif 📆 2021-06-24 17:54:18 [TOC] 修订历史 2021-06-24 17:54:31: 首次编辑 2021-06-24 22:28:18: update bug 具体步骤 如果已经有了mysql镜像, 直接跳过,到docker mysql容器中 docker 拉去 mysql 镜像 $ docker pull mysql 启动MySQL镜像 $ docker run --name=mysql -itd -p &lt;宿主机映射端口>:3306 -e MYSQL_ROOT_PASSWORD=&lt;密码> mysql 进入MySQL容器 $ docker exec -it mysql /bin/bash 进入MySQL 设置允许外部登录的mysql用户 $ mysql -uroot -p&lt;密码> # 设置允许外部登录的mysql用户: 'test' host监听地址:'%' 密码 test $ mysql> CREATE USER If Not Exists 'test'@'%' IDENTIFIED WITH mysql_native_password BY 'test'; # 赋予用户权限 $ mysql> GRANT all privileges ON test.* TO 'test'@'%' identified by 'test'; # 刷新 $ mysql>flush privileges; 修改mysql配置，允许任意主机访问 # 修改 mysqld.cnf中 bind-address监听地址loaclhst为0.0.0.0 $ sed -i 's/^bind-address.*$/bind-address=0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf # 重启mysql $ service mysql restart 若嫌进入mysql太麻烦直接运行如下命令,替换掉&lt;&gt;中内容 #修改mysql配置，允许任意主机访问 $ sed -i 's/^bind-address.*$/bind-address=0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf $ service mysql restart # 新建允许外部登录的mysql用户：'&lt;test>'@'%'，密码&lt;test> USER=`cat /etc/mysql/debian.cnf |grep user|head -1|awk '&#123;print $3&#125;'` PW=`cat /etc/mysql/debian.cnf |grep password|head -1|awk '&#123;print $3&#125;'` mysql -u$&#123;USER&#125; -p$&#123;PW&#125; -e\"CREATE USER If Not Exists '&lt;test>'@'%' IDENTIFIED WITH mysql_native_password BY '&lt;test>';\" mysql -u$&#123;USER&#125; -p$&#123;PW&#125; -e\"GRANT all privileges ON &lt;your mysql continer name>.* TO '&lt;test>'@'%' identified by '&lt;test>';flush privileges;\" navicat 远程连接 然后远程连接【宿主机ip:&lt;宿主机映射端口&gt;】，使用新建的用户登录mysql即可。 >$ docker run --name=mysql -itd -p &lt;宿主机映射端口>:3306 -e MYSQL_ROOT_PASSWORD=&lt;密码> mysql 问题发现整理 报2013错误 这个原因一般是由mysql中已经设定用户的远程host为’%',但是mysqld.cnf 或 my.cnf中 bind-address 监听地址为localhost导致 报1045错误 Access defined 一般是由于密码不正确或用户不正确导致","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"},{"name":"Mysql","slug":"技术向/Mysql","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mysql/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"教程","slug":"教程","permalink":"https://www.sizaif.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.sizaif.com/tags/Mysql/"}],"author":"sizaif"},{"title":"生成Openssl && Gnutls  Keys","slug":"生成openssl-gnutls-keys","date":"2021-08-10T06:03:30.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/bb0d4a87/","link":"","permalink":"https://www.sizaif.com/posts/bb0d4a87/","excerpt":"","text":"生成openssl &amp;&amp; gnutls keys 😄 @by sizaif 📆 2021-05-17 20:36:00 [TOC] Openssl 代码 # Generate DH parameters openssl dhparam -outform PEM -out dhparams.pem -5 2048 # Generate CA key and certificate CA.pl or CA.sh /usr/lib/ssl/misc/CA.pl -newca # Generate server key and certificate openssl req -newkey rsa:1024 -nodes -keyout server.key -out server.req openssl ca -out server.crt -infiles server.req # Generate client key and certificate openssl req -newkey rsa:1024 -nodes -keyout client.key -out client.req openssl ca -out client.crt -infiles client.req # Generate client DH key and certificate openssl genpkey -paramfile dhparams.pem -out client_dh.key openssl pkey -in client_dh.key -pubout -out client_dh.pub #~/SSL/openssl/openssl-1.0.2/apps/openssl x509 -req -in client.req -CAkey demoCA/private/cakey.pem -CA demoCA/cacert.pem -force_pubkey client_dh.pub -out client_dh.crt -CAcreateserial -extensions v3_req -extfile ./openssl.cnf # Get keys in Java keystore # 这里设置服务端 的名称为 server 密码为 changeit openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12 -name server -CAfile ca.crt -caname root keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore keystore -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias server # 这里设置客户端 的名称为 client 密码为 changeit openssl pkcs12 -export -in client.crt -inkey client.key -out client.p12 -name client -CAfile ca.crt -caname root keytool -importkeystore -srckeystore client.p12 -destkeystore keystore -srcstoretype PKCS12 -srcstorepass changeit -deststorepass changeit -destkeypass changeit -alias client #openssl pkcs12 -export -in client_dh.crt -inkey client_dh.key -out client_dh.p12 -name clientdh -CAfile ca.crt -caname root #keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore keystore -srckeystore client_dh.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias clientdh # Get keys in Netscape keystore certutil -N -d . certutil -A -n ca -i demoCA/cacert.pem -d . -t TC certutil -A -n server -i server.crt -d . -t P pk12util -d . -i server.p12 certutil -A -n client1 -i client.crt -d . -t P pk12util -d . -i client.p12 GnuTLS code #生成CA私钥 certtool --generate-privkey > x509-ca-key.pem # 创建CA模版 vim ca.tmpl cn = \"GnuTLS test CA\" organization = \"TLSTest\" serial = 1 expiration_days = 3650 ca signing_key cert_signing_key crl_signing_key #生成CA证书 certtool --generate-self-signed --load-privkey x509-ca-key.pem --template ca.tmpl --outfile x509-ca.pem #生成Server私钥 certtool --generate-privkey > x509-server-key.pem #创建Server证书模版 vim server.tmpl cn = \"GnuTLS test server\" organization = \"TLSTest\" expiration_days = 3650 signing_key encryption_key tls_www_server #生成Server证书 certtool --generate-certificate --load-privkey x509-server-key.pem \\ --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \\ --template server.tmpl --outfile x509-server.pem #生成Client私钥 certtool --generate-privkey > x509-client-key.pem #创建Client证书模版 vim client.tmpl cn = GnuTLS test client tls_www_client encryption_key signing_key tls_www_client #生成Client证书 certtool --generate-certificate --load-privkey x509-client-key.pem \\ --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \\ --template client.tmpl --outfile x509-client.pem #转换为p12证书 以及java keystore ;Get keys in Java keystore # 这里设置的名称为 client # 密码为123456 certtool --to-p12 --load-ca-certificate x509-ca.pem \\ --load-privkey x509-client-key.pem --load-certificate x509-client.pem \\ --outder --outfile x509-client.p12 keytool -importkeystore -srckeystore x509-client.p12 -destkeystore keystore -srcstoretype PKCS12 -srcstorepass 123456 -deststorepass 123456 -alias client # 这里设置的名称为 server # 密码为123456 certtool --to-p12 --load-ca-certificate x509-ca.pem \\ --load-privkey x509-server-key.pem --load-certificate x509-server.pem \\ --outder --outfile x509-server.p12 keytool -importkeystore -srckeystore x509-server.p12 -destkeystore keystore -srcstoretype PKCS12 -srcstorepass 123456 -deststorepass 123456 -alias server","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GnuTLS","slug":"GnuTLS","permalink":"https://www.sizaif.com/tags/GnuTLS/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"}],"author":"sizaif"},{"title":"使用代理进行 Docker Build 问题的解决思路","slug":"使用代理进行-docker-build-问题的解决思路","date":"2021-08-10T06:01:12.000Z","updated":"2021-09-19T10:15:19.000Z","comments":true,"path":"posts/d4ac1b81/","link":"","permalink":"https://www.sizaif.com/posts/d4ac1b81/","excerpt":"","text":"使用代理进行 docker build 问题的解决思路 😄 @Auther: sizaif 📆 2021-06-10 00:03:14 🐔 转载至: 原文作者: simpleapples 原文链接: http://www.simpleapples.com/2019/04/18/building-docker-image-behind-proxy/ 许可协议: 知识共享署名-非商业性使用 4.0 国际许可协议 [TOC] 问题描述 在使用 docker build 打包镜像时，遇到了需要使用代理访问网络的需求。使用如下的 Dockerfile 来模拟这个场景： FROM golang:1.12 RUN curl www.google.com --max-time 3 国内一般网络环境下，curl www.google.com 是无法正常返回的，加入 –max-time 让 curl 的耗时不要太长。 配置 http_proxy 变量 首先需要在环境变量中设置 http_proxy 和 https_proxy，使得访问网络的命令（这里使用 curl 来代表）能够通过环境变量中配置的代理服务器访问 www.google.com。 docker build 命令虽然是在 docker 所在的宿主机上执行的，看上去像是直接使用了宿主机的网络环境，但实际上docker build 也是启动了一个container进行构建，所以在构建过程中的所有命令都是在 container 中执行的，http_proxy 和 https_proxy 的配置也应该是在 container 中进行的。可以使用 ENV 来配置 container 中的环境变量。 代理服务器启动在宿主机的 1087 端口上，修改 dockerfile 文件： FROM golang:1.12 ENV http_proxy \"http://127.0.0.1:1087\" ENV HTTP_PROXY \"http://127.0.0.1:1087\" ENV https_proxy \"http://127.0.0.1:1087\" ENV HTTPS_PROXY \"http://127.0.0.1:1087\" RUN curl www.google.com --max-time 3 重新执行 docker build 会发现 curl 依旧无法访问 www.google.com，从报错信息上可以看到 127.0.0.1 上的 1087 端口上并没有服务。 访问宿主机 由于 container 默认是桥接网络，宿主机和 container 是平级的，被放在了一个虚拟的网段里。访问宿主机上的代理服务器，对于 container 来说实际上是访问另一台机器上的服务器，127.0.0.1 指向的是 container 本身。在 docker 默认的桥接网络中，宿主机的 IP 一般是 172.17.0.1（Linux），或者 192.168.65.1（MacOS），可以将 http_proxy 中的 IP 换成 172.17.0.1/192.168.65.1，来实现通过宿主的代理服务器访问网络，修改 dockerfile： FROM golang:1.12 ENV http_proxy \"http://172.17.0.1:1087\" ENV HTTP_PROXY \"http://172.17.0.1:1087\" ENV https_proxy \"http://172.17.0.1:1087\" ENV HTTPS_PROXY \"http://172.17.0.1:1087\" RUN curl www.google.com --max-time 3 虽然使用这种方式可以达到目的，但是如果编译环境变了或者代理服务器的配置变了，哪怕只是操作系统从 Linux 变成了 MacOS，都得修改 dockerfile，显然不够解耦，也不方便。 配置网络模式 docker 中还有一种 host 网络模式，就是让 container 使用宿主机的网络，相当于 container 在网络层面和宿主机不做隔离，使用这种网络模式执行 docker build，就不需要在 dockerfile 中添加 http_proxy 环境变量，container 可以直接读取宿主上的环境变量。 首先在宿主上导入 http_proxy 环境变量： export http_proxy=\"http://127.0.0.1:7890\" export HTTP_PROXY=\"http://127.0.0.1:7890\" export https_proxy=\"http://127.0.0.1:7890\" export HTTPS_PROXY=\"http://127.0.0.1:7890\" 接下来将 dockerfile 简化： FROM golang:1.12 RUN curl www.google.com --max-time 3 重新执行 docker build，加上参数 –network host，使用宿主网络： docker build --network host . 执行后 curl 就可以像在宿主上直接执行一样，通过代理访问 www.google.com 了。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"证书间的道道油","slug":"证书间的道道油","date":"2021-08-10T05:57:13.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/b495581d/","link":"","permalink":"https://www.sizaif.com/posts/b495581d/","excerpt":"","text":"证书间的道道油 😄 @auther sizaif 📆 2021-05-20 17:29:05 [TOC] 什么是PEM文件格式 ( Privacy-Enhanced Mail) 是一种事实上的文件格式，用于存储和发送加密密钥、证书和其他数据，基于一组定义“增强隐私的邮件”的1993 IETF标准 许多密码学标准使用ASN.1来定义它们的数据结构，并使用区分编码规则**(Distinguished Encoding Rules, DER)**来序列化这些结构,因为DER产生二进制输出，所以通过只支持ASCII的系统(如电子邮件)传输结果文件可能很困难。 PEM格式通过使用base64对二进制数据进行编码解决了这个问题。PEM还定义了一行页眉，包括“-----BEGIN”、一个标签和“-----”;一行页脚，包括“-----END”、一个标签和“-----”。标签决定了编码的消息类型。常用标签有“CERTIFICATE”、“CERTIFICATE REQUEST”、“PRIVATE KEY”、“X509 CRL”等。 PEM数据通常存储在后缀为“ .pem”，后缀为“ .cer”或“ .crt”（用于证书）或后缀“ .key”（用于公钥或私钥）的文件中。[3] PEM文件中的标签比文件后缀更准确地表示数据类型，因为可以将许多不同类型的数据保存在“ .pem”文件中。 什么是X.690 X.690是一个ITU-T标准，指定了几种ASN.1编码格式: Basic Encoding Rules (BER) Canonical Encoding Rules (CER) Distinguished Encoding Rules (DER) 参考链接: https://en.wikipedia.org/wiki/X.690#DER_encoding BER encoding 基本编码规则的格式指定编码ASN.1数据结构的自描述和自定界格式。每个数据元素都被编码为类型标识符、长度描述、实际数据元素以及必要时的内容结束标记。这些编码类型通常称为类型-长度-值或TLV编码。这种格式允许接收方从不完整的流中解码ASN.1信息，而不需要任何关于数据的大小、内容或语义的预先知识 DER encoding DER (Distinguished Encoding Rules) 是BER的一个受限变体，用于为ASN.1描述的数据结构产生明确的传输语法。像CER, DER编码是有效的BER编码。除一个发送者的选项外，DER与BER是一样的。 DER是BER的子集，提供了一种对ASN.1值进行编码的方法。DER适用于需要唯一编码的情况，例如在密码学中，并确保需要进行数字签名的数据结构产生唯一的序列化表示。DER可以被认为是误码率的标准形式。例如，在BER中，一个布尔值true可以被编码为255个非零字节值中的任何一个，而在DER中，有一种方法可以将布尔值true编码。 最重要的DER编码约束是: 长度编码必须使用确定的形式 ​ 此外，必须使用尽可能短的长度编码 位字符串、八字节字符串和受限字符串必须使用原始编码 Set中的元素根据标记值按排序顺序进行编码 DER广泛用于X.509等数字证书。 CER encoding CER(规范编码规则)是BER的一种受限变体，用于为ASN.1描述的数据结构生成明确的传输语法。BER提供了对数据值如何编码的选择，而CER(连同DER)只从基本编码规则允许的编码中选择一种编码，消除了其他选项。当必须保留编码时，CER是有用的;例如，在证券交易中 BER、CER、DER比较 BER格式和CER或DER格式之间的关键区别是基本编码规则提供的灵活性 BER，如上所述，是ITU-T X.690给出的用于ASN.1数据结构传输的编码规则的基本集合。它为发送方想要发送的数据结构提供了明确的编码规则，但也给发送方留下了一些编码选择.正如X.690标准中所述，“作为发送方的选项，基本编码规则允许替代编码。”声称符合基本编码规则的接收方应支持所有替代方案” 接收方必须准备好接受所有合法编码，才能合法声明BER-compliance,相比之下，CER和DER都将可用长度规范限制为单个选项。因此，CER和DER是误码率的限制形式，用于消除误码率标准的歧义。 CER和DER的不同之处在于它们对发送方施加的限制。CER和DER的基本区别是，在某些精确定义的情况下，DER采用定长形式，CER采用不定长形式。也就是说，DER总是具有前导长度信息，而CER使用内容结束八位元，而不是提供编码数据的长度。因此，对于大的编码值，CER需要较少的元数据，而对于小的编码值，DER需要较少的元数据。 为了便于编码规则之间的选择，X.690标准文档提供了以下指导: 如果编码的值足够小，能够适应可用内存，并且需要快速跳过一些嵌套的值，那么区分编码规则比规范编码规则更合适。规范化编码规则比杰出的编码规则更合适的如果有需要编码值太大了,他们不能轻易适应可用内存或需要编码和传输的一部分价值在整个价值是可用的。基本编码规则比规范的或专有的编码规则i更合适 公钥,私钥,数字证书 公钥私钥 Bob有两把钥匙，一把叫公钥（public key），一把叫私钥（private key） Bob的公钥可以公开供其他人使用，他只保留自己的私钥。公钥和私钥用来加解密数据，如果使用任意一把来加密数据，那么只有使用另外一把才能解密数据。 Susan想给Bob写信，她可以使用Bob的公钥将内容加密以后发送给Bob，Bob收到以后，使用私钥解密以便阅读内容。Bob的的其他同事即使截获了Susan发送给Bob的信件，由于没有Bob的私钥，也无法解密，从而确保数据安全。以上就是使用公钥和私钥加解密的过程演示。 如果Bob给Susan回信，如何保证数据安全呢？他可以使用Susan的公钥加密消息后发给Susan，Susan使用自己的私钥解密后阅读。所以保护好自己的私钥是多么重要的事情啊。 数字签名 现在Bob决定给Pat写一份信，信件的内容不用加密，但是要保证Pat收到信件后，能够确认信件的确是Bob发出的，而不是别人冒充Bob发给Pat的，应该如果做呢？ Bob将信件通过hash软件计算一下，得到一串消息摘要（有的文章也称之为“hash值”）。这一过程能够保证2点： 1、过程不可逆。即不能通过消息摘计算出信件的内容。 2、消息摘要不会重复。即如果信件有任何改动，再次hash计算出的消息摘要一定不会和改动前的消息摘要一致。 然后，Bob使用自己的私钥，将消息摘要加密。加密后的结果，我们称之为“数字签名”。现在，Bob就可以将信件连同数字签名一起发给Pat。 Pat收到信件以后，会做2件事： 1、使用Bob的公钥将数字签名解密，如果顺利解密，说明的确是Bob签发的数字签名，不是别人签发的，因为Bob的私钥没有公开。 2、Pat使用hash软件对信件再次进行hash计算，和解密数字签名得到的消息摘要对比，如果一致，说明信件没有篡改，确实是Bob发出的。这就是数字签名的过程。它能够确保签名人发出的消息不被篡改，也能证明的确是签名人发出的消息。 数字证书 使用数字证书可以确保公钥不被冒充。数字证书是经过权威机构（CA）认证的公钥，通过查看数字证书，可以知道该证书是由那家权威机构签发的，证书使用人的信息，使用人的公钥。它有以下特点： 1、由专门的机构签发的数字证书才安全有效。 2、签发数字证书是收费的。 3、不会被冒充，安全可信。 4、数字证书有使用期限，过了使用期限，证书变为不可用。CA也可以在试用期内，对证书进行作废操作。 公钥私钥证书生成 参考: 生成OpenSSL &amp;&amp; GntTLS &amp;&amp; WolfSSL keys 文档","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"}],"author":"sizaif"},{"title":"JAXB 学习","slug":"JAXB-学习","date":"2021-08-10T05:53:06.000Z","updated":"2021-09-19T10:14:38.000Z","comments":true,"path":"posts/a893dad1/","link":"","permalink":"https://www.sizaif.com/posts/a893dad1/","excerpt":"","text":"JAXB 学习 😄 @Auther: sizaif 📆 2021-06-06 21:13:30 [TOC] 说明 Java XML绑定体系结构(JAXB)通过JAXB应用程序的示例介绍了Java XML绑定体系结构(JAXB)技术。 在阅读本教程之前 要理解和使用XML绑定Java体系结构(JAXB)教程中的信息，您应该了解以下技术: Java编程语言及其开发环境 可扩展标记语言 本教程只详细研究JAXB特有的代码。 JAXB概论 用于XML绑定的Java体系结构(JAXB)提供了一种快速而方便的方法来绑定XML模式和Java表示，使得Java开发人员可以很容易地在Java应用程序中合并XML数据和处理函数。作为此过程的一部分，JAXB提供了将XML实例文档编组(读取)为Java内容树，然后将Java内容树编组(写入)为XML实例文档的方法。JAXB还提供了一种从Java对象生成XML模式的方法。 AXB 2.0包含了JAXB 1.0的几个重要改进: 支持所有W3C XML Schema特性。(JAXB 1.0没有为某些W3C XML Schema特性指定绑定。) 通过添加javax.xml.bind.annotation包来控制这种绑定，支持将java绑定到xml。(JAXB 1.0指定了XML模式到java的映射，但没有指定java到XML模式的映射。) 显著减少了生成的模式派生类的数量。 通过JAXP 1.3验证api提供的额外验证功能。 较小的运行时库。 本课描述JAXB体系结构、函数和核心概念，并提供示例和使用JAXB的逐步过程。 JAXB架构 本节描述JAXB处理模型中的组件和交互。 结构概述 下图显示了组成JAXB实现的组件。 图:JAXB体系结构概述 JAXB实现由以下架构组件组成: 模式编译器:将源模式绑定到一组从模式派生的程序元素。绑定由基于xml的绑定语言描述。 模式生成器:将一组现有的程序元素映射到派生的模式。映射是由程序注释描述的。 绑定运行时框架:提供解组(读取)和编组(写入)操作，以便使用模式派生的或现有的程序元素访问、操作和验证XML内容。 JAXB绑定过程 下图显示了JAXB绑定过程中发生的事情。 图:JAXB绑定过程中的步骤 JAXB数据绑定过程中的一般步骤是: 生成类(Generate classes):将XML模式用作JAXB绑定编译器的输入，以基于该模式生成JAXB类。 编译类(Compile classes):必须编译所有生成的类、源文件和应用程序代码。 解组(Unmarshal):根据源模式中的约束编写的XML文档由JAXB绑定框架解组。请注意，JAXB还支持从文件和文档以外的源(如DOM节点、字符串缓冲区、SAX源等)对XML数据进行解组。 生成内容树(Generate content tree):解组过程生成从生成的JAXB类实例化的数据对象的内容树;这个内容树表示源XML文档的结构和内容。 验证(可选)😦 Validate (optional))解组过程涉及在生成内容树之前验证源XML文档。注意，如果在步骤6中修改了内容树，还可以使用JAXB Validate操作在将内容编组回XML文档之前验证更改。 过程内容(Process content):通过使用绑定编译器生成的接口，客户机应用程序可以修改Java内容树表示的XML数据。 封装(Marshal):将处理过的内容树封送到一个或多个XML输出文档。可以在编组前对内容进行验证。 More About Unmarshalling 解组(Unmarshalling)为客户机应用程序提供了将XML数据转换为jaxb派生的Java对象的能力。即 从xml -&gt; java object More About Marshalling Marshalling 为客户端应用程序提供将jaxb派生的Java对象树转换为XML数据的能力。 即从 java object -&gt; xml 默认情况下，Marshaller在生成XML数据时使用UTF-8编码。 客户机应用程序不需要在编组之前验证Java内容树。也不要求Java内容树相对于其原始模式是有效的，以便将其编组为XML数据。 More About Validation Validation 是验证XML文档是否满足模式中表示的所有约束的过程 JAXB 1.0在编组时提供验证，并在JAXB内容树上支持按需验证。JAXB 2.0只允许在解组和编组时进行验证。web服务处理模型在读取数据时是宽松的，而在写出数据时是严格的。为了满足该模型，在封送时间中添加了验证，以便用户可以确认在修改JAXB表单中的文档时没有使XML文档失效。 表示 XML 内容 本节描述 JAXB 如何将 XML 内容表示为 Java 对象。 XML 模式的 Java 表示 JAXB 支持在 Java 包中对生成的类进行分组。一个包包含以下内容： 从 XML 元素名称派生或由绑定定制指定的 Java 类名称。 一个ObjectFactory的类，它是用来返回一个必然的Java类的实例的工厂。 绑定 XML 模式 本节介绍 JAXB 使用的默认 XML-to-Java 绑定。所有这些绑定都可以通过使用自定义绑定声明来全局或逐个覆盖。有关默认 JAXB 绑定的完整信息，请参阅 JAXB 规范。 简单类型定义 使用简单类型定义的模式组件通常绑定到 Java 属性。因为有不同种类的架构组件，以下 Java 属性属性（架构组件通用）包括： 基础类型 集合类型，如果有 谓词 其余的 Java 属性属性是使用简单类型定义在模式组件中指定的。 默认数据类型绑定 以下部分解释了默认的 schema-to-Java、 JAXBElement和 Java-to-schema 数据类型绑定。 Schema-to-Java Mapping Java语言提供了比XML模式更丰富的数据类型集,下表提供了JAXB中XML数据类型到Java数据类型的映射。 XML Schema Type Java Data Type xsd:string java.lang.String xsd:integer java.math.BigInteger xsd:int int xsd.long long xsd:short short xsd:decimal java.math.BigDecimal xsd:float float xsd:double double xsd:boolean boolean xsd:byte byte xsd:QName javax.xml.namespace.QName xsd:dateTime javax.xml.datatype.XMLGregorianCalendar xsd:base64Binary byte[] xsd:hexBinary byte[] xsd:unsignedInt long xsd:unsignedShort int xsd:unsignedByte short xsd:time javax.xml.datatype.XMLGregorianCalendar xsd:date javax.xml.datatype.XMLGregorianCalendar xsd:g javax.xml.datatype.XMLGregorianCalendar xsd:anySimpleType java.lang.Object xsd:anySimpleType java.lang.String xsd:duration javax.xml.datatype.Duration xsd:NOTATION javax.xml.namespace.QName 表:XML模式内置数据类型的JAXB映射 JAXBElement对象 当XML内容的派生Java表示不能推断XML元素信息时，将提供一个JAXBElement对象。该对象具有获取和设置对象名称和对象值的方法。 Java-to-Schema Mapping 下表显示了Java类到XML数据类型的默认映射。 Java Class XML Data Type java.lang.String xs:string java.math.BigInteger xs:integer java.math.BigDecimal xs:decimal java.util.Calendar xs:dateTime java.util.Date xs:dateTime javax.xml.namespace.QName xs:QName java.net.URI xs:string javax.xml.datatype.XMLGregorianCalendar xs:anySimpleType javax.xml.datatype.Duration xs:duration java.lang.Object xs:anyType java.awt.Image xs:base64Binary javax.activation.DataHandler xs:base64Binary javax.xml.transform.Source xs:base64Binary java.util.UUID xs:string 表:XML数据类型到Java类的JAXB映射 自定义生成的类和 Java 程序元素 以下部分描述了如何定制生成的 JAXB 类和 Java 程序元素。 Schema-to-Java 自定义JAXB绑定声明使您能够在XML模式中特定于XML的约束之外自定义生成的JAXB类，以包括特定于java的细化，例如类和包名映射。 JAXB 提供了两种自定义 XML 模式的方法： 作为源 XML 模式中的内联注释 作为传递给 JAXB 绑定编译器的外部绑定定制文件中的声明 本文档后面提供了展示如何定制 JAXB 绑定的代码示例。 Java-to-Schema javax.xml.bind.annotation 包中定义的 JAXB 注释可用于自定义 Java 程序元素到 XML 模式的映射。下表总结了可用于 Java 包的 JAXB 注释。 表：与 Java 包关联的 JAXB 注释 下表总结了可以与Java类一起使用的JAXB注释。 表：与 Java 类关联的 JAXB 注释 下表总结了可用于 Java枚举类型的JAXB 注释。 表：与 Java枚举 类型关联的 JAXB 注释 下表总结了可用于 Java 属性和字段的 JAXB 注释。 表：与 Java 属性和字段关联的 JAXB 注释 下表总结了可用于对象工厂的 JAXB 注释。 表：与对象工厂关联的 JAXB 注释 下表总结了可与适配器一起使用的 JAXB 注释。 表：与适配器关联的 JAXB 注释 JAXB Examples 以下部分描述了如何使用 JAXB RI 包中包含的示例应用程序。JAXB RI 包可从 http://jaxb.java.net 获得。下载并安装 JAXB RI 包。这些示例位于jaxb-ri-install /samples/目录中。这些示例演示并建立在关键的 JAXB 特性和概念之上。按照显示的顺序执行这些程序。 阅读完本节后，您应该对 JAXB 感到很舒服，您可以： 从 XML 模式生成 JAXB Java 类 使用模式派生的 JAXB 类来解组和编组 Java 应用程序中的 XML 内容 使用派生架构的 JAXB 类创建 Java 内容树 在解组和运行时验证 XML 内容 自定义 JAXB 模式到 Java 的绑定 本文档描述了三组示例： 基本示例（Modify Marshal、Unmarshal Validate）演示了基本的 JAXB 概念，例如使用默认设置和绑定解组、编组和验证 XML 内容。 自定义示例（自定义内联、数据类型转换器、外部自定义）演示了自定义 XML 模式到 Java 对象的默认绑定的各种方法。 java-to-schema 示例展示了如何使用注释将 Java 类映射到 XML 模式。 注意： 基本和自定义示例基于采购订单场景。每个都使用一个 XML 文档po.xml，它是针对 XML 模式po.xsd 编写的。这些文档来自 W3C XML Schema Part 0: Primer，由 David C. Fallside 编辑。 基本和自定义示例目录包含几个基本文件： po.xsd是 XML 模式，用作 JAXB 绑定编译器的输入，将从模式派生的 JAXB Java 类生成。对于自定义内联和数据类型转换器示例，此文件包含内联绑定自定义。 po.xml是包含示例 XML 内容的采购订单 XML 文件，它是每个示例中解组到 Java 内容树中的文件。该文件在每个示例中几乎相同；有细微的内容差异来突出不同的 JAXB 概念。 Main.java是每个示例的主要 Java 类。 build.xml是一个为您提供方便的 Ant 项目文件。使用 Ant 工具自动生成、编译和运行模式派生的 JAXB 类。该的build.xml文件跨越例子变化。 inline-customize示例中的MyDatatypeConverter.java是一个 Java 类，用于提供自定义数据类型转换。 外部定制示例中的binding.xjb是一个外部绑定声明文件，它被传递到 JAXB 绑定编译器以定制默认的 JAXB 绑定。 下表简要描述了基本的、定制的和 java-to-schema JAXB 示例。 Example Name Description Modify Marshal 演示如何修改Java内容树。 Unmarshal Validate 演示如何在解组期间启用验证 表:定制JAXB示例 Example Name Description Customize Inline 演示如何通过在 XML 模式中使用内联注释来自定义默认 JAXB 绑定。 Datatype Converter 说明 XML simpleType定义到 Java 数据类型的替代、更简洁的绑定，类似于自定义内联示例。 External Customize 说明如何使用外部绑定声明文件将只读模式的绑定自定义传递给 JAXB 绑定编译器。 表:java到模式的JAXB示例 Example Name Description Create Marshal 演示如何使用 ObjectFactory 类创建 Java 内容树并将其编组为 XML 数据。它还演示了如何向 JAXB 列表属性添加内容。 XmlAccessorOrder 说明如何在 Java 类中使用@XmlAccessorOrder和@XmlType.propOrder映射注释来控制 Java 类型编组或解组 XML 内容的顺序。 XmlAdapter 说明如何使用接口XmlAdapter和注释@XmlJavaTypeAdapter提供 XML 内容进出HashMap（字段）的自定义映射，该字段使用整数 ( int ) 作为键，将字符串 ( String ) 作为值。 XmlAttribute 说明如何使用注解@XmlAttribute定义要作为 XML 属性处理的属性或字段。 XmlRootElement 说明如何使用注释@XmlRootElement为相应类的 XML 架构类型定义 XML 元素名称。 XmlSchemaType Class 说明如何使用注释@XmlSchemaType自定义属性或字段到 XML 内置类型的映射。 XmlType 说明如何使用注释@XmlType将类或枚举类型映射到 XML 架构类型。 下表描述了基本示例的这些类及其与源XML模式的特定绑定。 表:Schema-to-Java绑定 Schema-Derived JAXB Classes 下一节将简要解释JAXB绑定编译器为示例生成的以下各个类的功能: [Items Class](#Items` Class) [ObjectFactory Class](#ObjectFactory` Class) [PurchaseOrderType Class](# Class) [USAddress Class](#USAddress` Class) Items Class In Items.java: 该项目类是部分 primer.po包。 该类为Items 和ItemType提供公共接口。 此类实例化中的内容绑定到 XML ComplexTypes Items及其子元素 ItemType。 Item提供了getItem()方法。 ItemType提供以下方法： getPartNum(); setPartNum(String value); getComment(); setComment(java.lang.String value); getUSPrice(); setUSPrice(java.math.BigDecimal value); getProductName(); setProductName(String value); getShipDate(); setShipDate(java.util.Calendar value); getQuantity(); setQuantity(java.math.BigInteger value); ObjectFactory Class In ObjectFactory.java: 所述的ObjectFactory类是部分primer.po包。 ObjectFactory提供了工厂方法，用于在 Java 内容树中实例化表示 XML 内容的 Java 接口。 方法名称是通过连接生成的： 字符串常量create。 所有外部 Java 类名称，如果 Java 内容接口嵌套在另一个接口中。 Java 内容接口的名称。 例如，在这种情况下，对于 Java 接口prime.po.Items.ItemType，ObjectFactory创建方法createItemsItemType()。 PurchaseOrderType Class In PurchaseOrderType.java: 所述PurchaseOrderType类是部分primer.po包。 此类实例化中的内容绑定到名为PurchaseOrderType的 XML 架构子元素。 PurchaseOrderType是一个公共接口，提供以下方法： getItems(); setItems(primer.po.Items value); getOrderDate(); setOrderDate(java.util.Calendar value); getComment(); setComment(java.lang.String value); getBillTo(); setBillTo(primer.po.USAddress value); getShipTo(); setShipTo(primer.po.USAddress value); USAddress Class In USAddress.java: 的校舍地址类是部分 primer.po包。 此类实例化中的内容绑定到名为USAddress的 XML 模式元素。 USAddress是一个公共接口，提供以下方法： getState(); setState(String value); getZip(); setZip(java.math.BigDecimal value); getCountry(); setCountry(String value); getCity(); setCity(String value); getStreet(); setStreet(String value); getName(); setName(String value); 基本示例 本节介绍了基本 JAXB 示例（Modify Marshal、Unmarshal Validate），这些示例演示了如何： 将 XML 文档解组为 Java 内容树并访问其中包含的数据 修改 Java 内容树 使用ObjectFactory类创建 Java 内容树，然后将其编组为 XML 数据 在解组期间执行验证 在运行时验证 Java 内容树 Modify Marshal Example Modify Marshal示例演示了如何修改Java内容树。 该JAXB里安装/samples/modify-marshal/src/Main.java类声明导入三种标准的Java类，五JAXB绑定框架类和的primer.po包： import java.io.FileInputStream; import java.io.IOException; import java.math.BigDecimal; import javax.xml.bind.JAXBContext; import javax.xml.bind.JAXBElement; import javax.xml.bind.JAXBException; import javax.xml.bind.Marshaller; import javax.xml.bind.Unmarshaller; import primer.po.*; 创建了一个JAXBContext实例来处理在prime.po 中生成的类 JAXBContext jc = JAXBContext.newInstance( \"primer.po\" ); 创建了一个Unmarshaller实例，并解组了po.xml文件。 Unmarshaller u = jc.createUnmarshaller(); PurchaseOrder po = (PurchaseOrder) u.unmarshal(new FileInputStream(\"po.xml\")); set方法用于修改内容树的地址分支中的信息。 USAddress address = po.getBillTo(); address.setName(\"John Bob\"); address.setStreet(\"242 Main Street\"); address.setCity(\"Beverly Hills\"); address.setState(\"CA\"); address.setZip(new BigDecimal address.setName(\"John Bob\"); address.setStreet(\"242 Main Street\"); address.setCity(\"Beverly Hills\"); address.setState(\"CA\"); address.setZip(new BigDecimal(\"90210\")); 创建了一个Marshaller实例，并将更新的 XML 内容编组到system.out。所述的setProperty API用于指定输出编码; 在这种情况下，它是格式化的（人类可读的）XML。 Marshaller m = jc.createMarshaller(); m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE); m.marshal(po, System.out); Building and Running the Modify Marshal Example Using Ant 要使用 Ant 编译和运行 Modify Marshal 示例，请在终端窗口中，转到jaxb-ri-install /samples/modify-marshal/目录并键入以下内容： ant Unmarshal Validate Example Unmarshal Validate 示例演示了如何在解组期间启用验证。请注意，JAXB 在解组期间提供验证功能，但在编组期间不提供。验证在更多关于验证中进行了更详细的解释 。 该JAXB里安装/samples/unmarshal-validate/src/Main.java类声明为一个标准的Java类，十JAXB绑定框架类和进口primer.po包： import java.io.File; import javax.xml.bind.JAXBContext; import javax.xml.bind.JAXBException; import javax.xml.bind.Marshaller; import javax.xml.bind.UnmarshalException; import javax.xml.bind.Unmarshaller; import javax.xml.bind.ValidationEvent; import javax.xml.bind.ValidationEventHandler; import javax.xml.bind.ValidationEventLocator; import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI; import javax.xml.validation.SchemaFactory; import javax.xml.validation.Schema; import primer.po.*; 创建了一个JAXBContext实例来处理在prime.po包中生成的类。 JAXBContext jc = JAXBContext.newInstance(\"primer.po\"); 一个Unmarshaller的实例被创建。 Unmarshaller u = jc.createUnmarshaller(); 默认的 JAXB Unmarshaller ``ValidationEventHandler已启用以向system.out发送验证警告和错误。默认配置会导致解组操作在遇到第一个验证错误时失败。 u.setValidating( true ); 尝试将po.xml文件解组为 Java 内容树。出于本示例的目的，po.xml文件包含故意错误 PurchaseOrder po = (PurchaseOrder)u.unmarshal( new FileInputStream(\"po.xml\")); 默认验证事件处理程序处理验证错误，生成输出到system.out，然后抛出异常. &#125; catch( UnmarshalException ue ) &#123; System.out.println(\"Caught UnmarshalException\");&#125; catch( JAXBException je ) &#123; je.printStackTrace();&#125; catch( IOException ioe ) &#123; ioe.printStackTrace();&#125; Building and Running the Unmarshal Validate Example Using Ant 要使用 Ant 编译和运行 Unmarshal Validate 示例，请在终端窗口中，转到jaxb-ri-install /samples/unmarshal-validate/目录并键入以下内容： ant","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"JAXB","slug":"笔记/JAXB","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/JAXB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Xml","slug":"Xml","permalink":"https://www.sizaif.com/tags/Xml/"},{"name":"JAXB","slug":"JAXB","permalink":"https://www.sizaif.com/tags/JAXB/"}],"author":"sizaif"},{"title":"IDEA 配置Docker 本地环境开发Java","slug":"IDEA-配置docker-本地环境开发java","date":"2021-08-10T05:50:35.000Z","updated":"2021-09-19T10:14:55.000Z","comments":true,"path":"posts/8904d55a/","link":"","permalink":"https://www.sizaif.com/posts/8904d55a/","excerpt":"","text":"IDEA 配置docker 本地环境开发java 😄 @by sizaif 📆 2021-05-17 22:52:02 [TOC] 说明 初步的思路是: 在windows平台下 使用idea调试代码, 通过 docker 配置运行linux环境, 连接到docker 容器中, 在docker容器中运行代码 安装docker插件 docker-winwdos 开启tcp远程连接 idea中配置docker环境 idea配置运行环境 未完待续","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.sizaif.com/tags/IDEA/"}],"author":"sizaif"},{"title":"Git 多人协作 & 贡献","slug":"git-多人协作-贡献","date":"2021-08-10T05:44:06.000Z","updated":"2021-09-19T10:15:01.000Z","comments":true,"path":"posts/8ea2fec1/","link":"","permalink":"https://www.sizaif.com/posts/8ea2fec1/","excerpt":"","text":"git 多人协作 &amp; 贡献 😄 @Auther by sizaif 📆 2021-06-24 17:03:01 [TOC] 修订历史 2021-06-24 17:04:08: 首次编辑 2021-06-25 10:23:09: 添加pull request图片 整体流程 首先fork别人的项目到在自己的github仓库中,然后拉取项目到本地开发,开发完成后做Pull Request 别人项目(主仓): upstream/master 自己远程仓库: origin/master 本地仓库: local/master 保持你的仓库和原作者的仓库一致 一是在github项目中点击: 二是通过git命令实现 child:codeblock open:false color:green #查看本地远程仓库信息 $ git remote -v #添加主仓到本地仓,并命为upstream,( 这个仓库保持最新与原作者的master一致) $ git remote add upstream 原作者的项目.git #再次查看本地远程仓库信息,此时 upstream 显示为原作者的项目地址 $ git remote-v #将主仓fetch到本地和本地master合并 $ git pull upstream master # 将本地master push到 你的远程仓库实现最新 $ git push Pull Request 当本地开发完,想pull 给作者贡献时, 用到pull request 在接下来的界面中,添加一下你的主要工作内容,让原作者可以清晰的理解你的新get点, 提交后等待即可. 也可以直接在jetbrains家 idea,pycharm等软件里直接提交","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Git","slug":"技术向/Git","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.sizaif.com/tags/Git/"}],"author":"sizaif"},{"title":"Dockerfile构建docker时apt-Get Install遇到交互式处理方法","slug":"Dockerfile构建docker时apt-get-install遇到交互式处理方法","date":"2021-08-10T05:38:52.000Z","updated":"2021-09-19T10:15:07.000Z","comments":true,"path":"posts/37be8a52/","link":"","permalink":"https://www.sizaif.com/posts/37be8a52/","excerpt":"","text":"Dockerfile构建docker时apt-get install遇到交互式处理方法 😄 @auther by sizaif 📆2021-07-01 02:20:43 [TOC] 编辑历史 2021-07-01 02:21:01: 第一次编辑 问题说明 当使用Dockerfile构建docker时,执行命令apt-get install -y build-essential 时,会安装tzdata, 但从tzdata 2018版本开始（如2018d），安装过程中默认采用交互式，即要求输入指定的Geographic area和Time zone，从而必须人工值守进行安装，输出信息如下。 而Dockerfile构建过程中,无法进行交互. 解决方法 在 apt-get install -y 命令前 添加 DEBIAN_FRONTEND=noninteractive 即: RUN DEBIAN_FRONTEND=noninteractive apt-get install -y &lt;software name> 注: DEBIAN_FRONTEND=noninteractive 同样适用于shell 脚本","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"Dockerfile Tutorial","slug":"Dockerfile-Tutorial","date":"2021-08-10T05:17:22.000Z","updated":"2021-09-19T10:15:10.000Z","comments":true,"path":"posts/f8a23a09/","link":"","permalink":"https://www.sizaif.com/posts/f8a23a09/","excerpt":"","text":"Dockerfile Tutorial 😄 @Auther: sizaif 📆2021-06-08 15:30:38 [TOC] Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。 在一个空白目录中，建立一个文本文件，并命名为 Dockerfile： $ mkdir mynginx $ cd mynginx $ touch Dockerfile 其内容为： FROM nginx RUN echo '&lt;h1>Hello, Docker!&lt;/h1>' > /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 FROM FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 FROM XXX ... 在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 RUN 执行命令 RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。 既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样： FROM debian:stretch RUN apt-get update RUN apt-get install -y gcc libc6-dev make wget RUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。 Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。 上面的 Dockerfile 正确的写法应该是这样： Dickerfile FROM debian:stretch RUN set -x; buildDeps='gcc libc6-dev make wget' \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。 构建镜像 好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。 在 Dockerfile 文件所在目录执行： $ docker build -t nginx:v3 . Sending build context to Docker daemon 2.048 kB Step 1 : FROM nginx ---> e43d811ce2f4 Step 2 : RUN echo '&lt;h1>Hello, Docker!&lt;/h1>' > /usr/share/nginx/html/index.html ---> Running in 9cdc27646c7b ---> 44aa4490ce2c Removing intermediate container 9cdc27646c7b Successfully built 44aa4490ce2c 从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。 这里我们使用了 docker build 命令进行镜像构建。其格式为： docker build [选项] &lt;上下文路径/URL/-> 在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。 镜像构建上下文（Context） 如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？ 这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： COPY ./package.json /app/ 这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。 因此，COPY 这类指令中的源文件的路径都是**相对路径。**这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。 如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程： $ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kB... 理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。 这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。 当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。 COPY 复制文件 格式： COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt; COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如： COPY package.json /usr/src/app/ &lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： COPY hom* /mydir/COPY hom?.txt /mydir/ &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 在使用该指令的时候还可以加上 --chown=&lt;user&gt;:&lt;group&gt; 选项来改变文件的所属用户及所属组。 COPY --chown=55:mygroup files* /mydir/COPY --chown=bin files* /mydir/COPY --chown=1 files* /mydir/COPY --chown=10:11 files* /mydir/ 如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"Docker Tutorial","slug":"Docker-Tutorial","date":"2021-08-10T05:17:05.000Z","updated":"2021-09-19T10:15:14.000Z","comments":true,"path":"posts/ac15f71a/","link":"","permalink":"https://www.sizaif.com/posts/ac15f71a/","excerpt":"","text":"Docker Tutorial 😄 @Auther: sizaif 📆 2021-06-08 15:38:53 [TOC] docker docs https://docs.docker.com/get-docker/ Install Docker Desktop for Windows https://docs.docker.com/docker-for-windows/install/ overview Commands https://docs.docker.com/engine/reference/commandline/cli/ Build $ docker build [OPTIONS] PATH | URL | - Run Usage $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Options options Name, shorthandDefaultDescription--add-hostAdd a custom host-to-IP mapping (host:ip)--attach , -aAttach to STDIN, STDOUT or STDERR--blkio-weightBlock IO (relative weight), between 10 and 1000, or 0 to disable (default 0)--blkio-weight-deviceBlock IO weight (relative device weight)--cap-addAdd Linux capabilities--cap-dropDrop Linux capabilities--cgroup-parentOptional parent cgroup for the container--cgroupnsAPI 1.41+ Cgroup namespace to use (host|private) ‘host’: Run the container in the Docker host’s cgroup namespace ‘private’: Run the container in its own private cgroup namespace ‘’: Use the cgroup namespace as configured by the default-cgroupns-mode option on the daemon (default)--cidfileWrite the container ID to the file--cpu-countCPU count (Windows only)--cpu-percentCPU percent (Windows only)--cpu-periodLimit CPU CFS (Completely Fair Scheduler) period--cpu-quotaLimit CPU CFS (Completely Fair Scheduler) quota--cpu-rt-periodAPI 1.25+ Limit CPU real-time period in microseconds--cpu-rt-runtimeAPI 1.25+ Limit CPU real-time runtime in microseconds--cpu-shares , -cCPU shares (relative weight)--cpusAPI 1.25+ Number of CPUs--cpuset-cpusCPUs in which to allow execution (0-3, 0,1)--cpuset-memsMEMs in which to allow execution (0-3, 0,1)--detach , -dRun container in background and print container ID--detach-keysOverride the key sequence for detaching a container--deviceAdd a host device to the container--device-cgroup-ruleAdd a rule to the cgroup allowed devices list--device-read-bpsLimit read rate (bytes per second) from a device--device-read-iopsLimit read rate (IO per second) from a device--device-write-bpsLimit write rate (bytes per second) to a device--device-write-iopsLimit write rate (IO per second) to a device--disable-content-trusttrueSkip image verification--dnsSet custom DNS servers--dns-optSet DNS options--dns-optionSet DNS options--dns-searchSet custom DNS search domains--domainnameContainer NIS domain name--entrypointOverwrite the default ENTRYPOINT of the image--env , -eSet environment variables--env-fileRead in a file of environment variables--exposeExpose a port or a range of ports--gpusAPI 1.40+ GPU devices to add to the container (‘all’ to pass all GPUs)--group-addAdd additional groups to join--health-cmdCommand to run to check health--health-intervalTime between running the check (ms|s|m|h) (default 0s)--health-retriesConsecutive failures needed to report unhealthy--health-start-periodAPI 1.29+ Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s)--health-timeoutMaximum time to allow one check to run (ms|s|m|h) (default 0s)--helpPrint usage--hostname , -hContainer host name--initAPI 1.25+ Run an init inside the container that forwards signals and reaps processes--interactive , -iKeep STDIN open even if not attached--io-maxbandwidthMaximum IO bandwidth limit for the system drive (Windows only)--io-maxiopsMaximum IOps limit for the system drive (Windows only)--ipIPv4 address (e.g., 172.30.100.104)--ip6IPv6 address (e.g., 2001:db8::33)--ipcIPC mode to use--isolationContainer isolation technology--kernel-memoryKernel memory limit--label , -lSet meta data on a container--label-fileRead in a line delimited file of labels--linkAdd link to another container--link-local-ipContainer IPv4/IPv6 link-local addresses--log-driverLogging driver for the container--log-optLog driver options--mac-addressContainer MAC address (e.g., 92:d0:c6:0a:29:33)--memory , -mMemory limit--memory-reservationMemory soft limit--memory-swapSwap limit equal to memory plus swap: ‘-1’ to enable unlimited swap--memory-swappiness-1Tune container memory swappiness (0 to 100)--mountAttach a filesystem mount to the container--nameAssign a name to the container--netConnect a container to a network--net-aliasAdd network-scoped alias for the container--networkConnect a container to a network--network-aliasAdd network-scoped alias for the container--no-healthcheckDisable any container-specified HEALTHCHECK--oom-kill-disableDisable OOM Killer--oom-score-adjTune host’s OOM preferences (-1000 to 1000)--pidPID namespace to use--pids-limitTune container pids limit (set -1 for unlimited)--platformAPI 1.32+ Set platform if server is multi-platform capable--privilegedGive extended privileges to this container--publish , -pPublish a container’s port(s) to the host--publish-all , -PPublish all exposed ports to random ports--pullmissingPull image before running (“always”|“missing”|“never”)--read-onlyMount the container’s root filesystem as read only--restartnoRestart policy to apply when a container exits--rmAutomatically remove the container when it exits--runtimeRuntime to use for this container--security-optSecurity Options--shm-sizeSize of /dev/shm--sig-proxytrueProxy received signals to the process--stop-signalSIGTERMSignal to stop a container--stop-timeoutAPI 1.25+ Timeout (in seconds) to stop a container--storage-optStorage driver options for the container--sysctlSysctl options--tmpfsMount a tmpfs directory--tty , -tAllocate a pseudo-TTY--ulimitUlimit options--user , -uUsername or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])--usernsUser namespace to use--utsUTS namespace to use--volume , -vBind mount a volume--volume-driverOptional volume driver for the container--volumes-fromMount volumes from the specified container(s)--workdir , -wWorking directory inside the container # 启动容器 $ docker exec -it XXID /bin/bash #创造容器 $ docker run -dit -p 8080:80 -v /e/windowssrc:容器里映射路径 --name 起个名字 ubuntu:你的镜像tag（默认是latest） #创造容器并运行多个命令 $ docker run -dit XXX(images) /bin/bash -c \"ls &amp;&amp; pwd\" #删除容器 $ docker rm -f XXID #查看所有的容器命令如下： $ docker ps -a 容器打包并做成镜像 容器打包 $ docker commit containerId dockerUserName/XXX 注：containerId为你需要上传的容器id，dockerUserName为dockerHub的登录名，xxx为仓库名,当然也不一定非得是dockerUserName/xxx，只是为了方便起见 接下来为存在于本地的镜像打标签 $ docker tag imageName dockerUserName/xxx[:tag] #注：imageName为你需要上传的镜像name， # dockerUserName为dockerHub的登录名，xxx为仓库名，必须和你在dockerhub中新建的仓库名相同，tag不指定就是latest 打包好之后，就把打包好的镜像上传 $ docker push dockerUserName/xxx[:tag] 注：tag不指定就是latest ———————————————— git设置、查看、取消代理 设置代理： $ git config --global http.proxy 'socks5://127.0.0.1:1080' $ git config --global https.proxy 'socks5://127.0.0.1:1080' 查看代理： $ git config --global --get http.proxy $ git config --global --get https.proxy 取消代理： $ git config --global --unset http.proxygit config --global --unset https.proxy 换源 针对docker容器的代理配置： 在创建(run)容器的时候，加上 --net=host 这个选项，就可以实现容器内外共享网络，然后再在容器内部配置git，就可以实现容器内代理了 Ubuntu系统中，软件源文件地址为：/etc/apt/sources.list 1.备份原来的源，将以前的源备份一下，以防以后可以用的。 $ sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak 2.打开/etc/apt/sources.list文件，在前面添加如下条目，并保存。 $ sudo vim /etc/apt/sources.list（可将vim更换为自己熟悉的编辑器） 添加源 #添加阿里源 deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse #添加清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse 3.更新 更新源 $ sudo apt-get update 如出现依赖问题，解决方式如下： $ sudo apt-get -f install 更新软件： $sudo apt-get upgrade 修改/etc/profile 打包后不生效得问题 解决办法: 可以将环境变量放到 /root/.bashrc 这个里面 docker 容器中 默认用户为 root, 将环境变量放到 ./bashrc 中","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"教程","slug":"教程","permalink":"https://www.sizaif.com/tags/%E6%95%99%E7%A8%8B/"}],"author":"sizaif"},{"title":"Java 8 Tutorial 教程","slug":"Java-8-Tutorial-教程","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-19T10:14:49.000Z","comments":true,"path":"posts/c65d65/","link":"","permalink":"https://www.sizaif.com/posts/c65d65/","excerpt":"","text":"Java 8 Tutorial 教程 😄 @Auther sizaif 📆 2021-05-29 20:41:05 🔗 翻译自 https://winterbe.com/posts/2014/03/16/java-8-tutorial/ [TOC] 说明 欢迎来到我对Java 8的介绍。本教程将逐步指导您了解所有新的语言特性。在简短简单的代码示例的支持下，您将学习如何使用默认接口方法、lambda表达式、方法引用和可重复注释。在本文的最后，您将熟悉最新的API变化，如流、功能接口、地图扩展和新的日期API。 接口缺省方法 Java 8允许我们利用default关键字向接口添加非抽象的方法实现。 此特性也称为扩展方法( Extension Methods.)。这是第一个例子: interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125; &#125; 除了抽象方法calculate接口外，Formula还定义了默认方法sqrt。具体类只需实现抽象方法calculate 默认方法sqrt可以开箱即用。 Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125; &#125;; formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0 该公式以匿名对象的形式实现。这段代码相当冗长:6行代码就可以完成这样一个简单的sqrt(a * 100)计算。正如我们将在下一节中看到的，在Java 8中有一种更好的实现单个方法对象的方法。 拉姆达(Lambda)表达式 让我们从一个简单的例子开始，在以前的Java版本中如何对字符串列表排序: List&lt;String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\"); Collections.sort(names, new Comparator&lt;String>() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125; &#125;); 静态实用方法Collections.sort接受一个列表和一个比较器，以便对给定列表的元素进行排序. 您经常会发现自己创建了匿名比较器并将它们传递给sort方法。 Java 8的语法要短得多，而不是整天创建匿名对象， lambda expressions: Collections.sort(names, (String a, String b) -> &#123; return b.compareTo(a); &#125;); 正如您所看到的，代码更短，更容易阅读。但它变得更短: Collections.sort(names, (String a, String b) -> b.compareTo(a)); 对于一行方法主体，可以跳过大括号{}和return关键字。但它变得更短: Collections.sort(names, (a, b) -> b.compareTo(a)); java编译器知道参数类型，所以您也可以跳过它们。让我们更深入地了解lambda表达式在实际中是如何使用的 函数式接口 lambda表达式如何适应java类型系统?每个lambda对应于由接口指定的给定类型.一个所谓的函数接口必须包含一个抽象方法声明。 该类型的每个lambda表达式都将与这个抽象方法匹配。由于默认方法不是抽象的，您可以自由地将默认方法添加到函数接口中。 只要接口只包含一个抽象方法，我们就可以将任意接口作为lambda表达式使用。为了确保您的接口满足需求，您应该添加@FunctionalInterface注释。编译器知道这个注释，当您试图向接口添加第二个抽象方法声明时，就会抛出编译器错误。 Example: @FunctionalInterface interface Converter&lt;F, T> &#123; T convert(F from); &#125; Converter&lt;String, Integer> converter = (from) -> Integer.valueOf(from); Integer converted = converter.convert(\"123\"); System.out.println(converted); // 123 请记住，如果@FunctionalInterface注释被省略，那么代码也是有效的。 方法和构造函数引用 通过使用静态方法引用，可以进一步简化上面的示例代码: Converter&lt;String, Integer> converter = Integer::valueOf; Integer converted = converter.convert(\"123\"); System.out.println(converted); // 123 Java 8允许您通过::关键字传递方法或构造函数的引用。上面的例子展示了如何引用静态方法。但我们也可以引用对象方法: class Something &#123; String startsWith(String s) &#123; return String.valueOf(s.charAt(0)); &#125;&#125; Something something = new Something();Converter&lt;String, String> converter = something::startsWith;String converted = converter.convert(\"Java\");System.out.println(converted); // \"J\" 让我们看看::关键字如何在构造函数中工作。首先，我们定义了一个带有不同构造函数的示例bean: class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 接下来，我们指定一个用于创建新人员的人员工厂接口: interface PersonFactory&lt;P extends Person> &#123; P create(String firstName, String lastName);&#125; 我们不是手动实现工厂，而是通过构造函数引用将所有东西粘在一起: PersonFactory&lt;Person> personFactory = Person::new;Person person = personFactory.create(\"Peter\", \"Parker\"); 通过Person::new创建对Person构造函数的引用。Java编译器通过匹配PersonFactory.create的签名自动选择正确的构造函数。 Lambda范围 从lambda表达式访问外部作用域变量非常类似于匿名对象。您可以从本地外部作用域以及实例字段和静态变量访问最终变量。 访问局部变量 我们可以从lambda表达式的外部作用域读取最终局部变量: final int num = 1;Converter&lt;Integer, String> stringConverter = (from) -> String.valueOf(from + num);stringConverter.convert(2); // 3 但与匿名对象不同的是，变量num不必声明为final。此代码也是有效的: int num = 1;Converter&lt;Integer, String> stringConverter = (from) -> String.valueOf(from + num);stringConverter.convert(2); // 3 但是num必须是隐式的final，才能编译代码。以下代码无法编译: int num = 1;Converter&lt;Integer, String> stringConverter = (from) -> String.valueOf(from + num);num = 3; 也禁止从lambda表达式内写入num。 访问字段和静态变量 与局部变量相比，我们可以从lambda表达式中读写实例字段和静态变量。这种行为在匿名对象中很常见。 class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String> stringConverter1 = (from) -> &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String> stringConverter2 = (from) -> &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125;&#125; 访问缺省接口方法 还记得第一部分的公式例子吗? 接口Formula定义了一个默认方法sqrt，可以从每个公式实例(包括匿名对象)访问该方法。这不适用于lambda表达式。 不能从lambda表达式中访问默认方法。以下代码无法编译: Formula formula = (a) -> sqrt( a * 100); 内置函数式接口 JDK 1.8 API包含许多内置的功能性接口。它们中的一些在较早的Java版本中很有名，比如Comparator或Runnable。通过@FunctionalInterface注释对这些现有接口进行了扩展，以支持Lambda。 但是Java 8 API也充满了新的功能接口，使您的生活更轻松。其中一些新接口来自 Google Guava库。即使您熟悉这个库，也应该密切关注这些接口是如何通过一些有用的方法扩展来扩展的。 谓词(Predicates) 谓词是一个参数的布尔值函数。该接口包含用于将谓词组合成复杂逻辑术语(和或否定)的各种默认方法。 Predicate&lt;String> predicate = (s) -> s.length() > 0;predicate.test(\"foo\"); // truepredicate.negate().test(\"foo\"); // falsePredicate&lt;Boolean> nonNull = Objects::nonNull;Predicate&lt;Boolean> isNull = Objects::isNull;Predicate&lt;String> isEmpty = String::isEmpty;Predicate&lt;String> isNotEmpty = isEmpty.negate(); 函数(Functions) 函数接受一个参数并产生一个结果。默认方法可以用于将多个函数链接在一起(compose, andThen)。 Function&lt;String, Integer> toInteger = Integer::valueOf;Function&lt;String, String> backToString = toInteger.andThen(String::valueOf);backToString.apply(\"123\"); // \"123\" suppliers Suppliers生成给定泛型类型的结果。与函数不同，,Suppliers不接受参数。 Supplier&lt;Person> personSupplier = Person::new;personSupplier.get(); // new Person Consumers 消费者表示对单个输入参数执行的操作 Consumer&lt;Person> greeter = (p) -> System.out.println(\"Hello, \" + p.firstName);greeter.accept(new Person(\"Luke\", \"Skywalker\")); comparators 比较器在较早的Java版本中很有名。Java 8向接口中添加了各种默认方法。 Comparator&lt;Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);Person p1 = new Person(\"John\", \"Doe\");Person p2 = new Person(\"Alice\", \"Wonderland\");comparator.compare(p1, p2); // > 0comparator.reversed().compare(p1, p2); // &lt; 0 Optionals 可选对象不是函数接口，而是一个防止NullPointerException的漂亮实用工具。这是下一节的一个重要概念，所以让我们快速了解一下optional是如何工作的。 Optional是一个简单的值容器，它可以是空值或非空值。考虑一个可能返回非空结果但有时什么也不返回的方法。在Java 8中，不是返回null，而是返回一个Optional。 Optional&lt;String> optional = Optional.of(\"bam\");optional.isPresent(); // trueoptional.get(); // \"bam\"optional.orElse(\"fallback\"); // \"bam\"optional.ifPresent((s) -> System.out.println(s.charAt(0))); // \"b\" Streams stream表示一个可以执行一个或多个操作的元素序列。流操作可以是中间操作，也可以是终端操作。终端操作返回某种类型的结果，而中间操作返回流本身，因此您可以在一行中链接多个方法调用。流是在源文件上创建的，例如java.util.Collection，如列表或集合(不支持映射)。流操作可以顺序执行，也可以并行执行。 让我们首先看看顺序流是如何工作的。首先，我们以字符串列表的形式创建一个示例源: List&lt;String> stringCollection = new ArrayList&lt;>();stringCollection.add(\"ddd2\");stringCollection.add(\"aaa2\");stringCollection.add(\"bbb1\");stringCollection.add(\"aaa1\");stringCollection.add(\"bbb3\");stringCollection.add(\"ccc\");stringCollection.add(\"bbb2\");stringCollection.add(\"ddd1\"); Java 8中的集合被扩展了，所以你可以通过调用Collection.stream()或Collection.parallelStream()简单地创建流。下面的部分解释了最常见的流操作。 Filter Filter接受一个谓词(predicate)来过滤流中的所有元素。这个操作是中间的，它使我们能够对结果调用另一个流操作(forEach)。ForEach 接受要为过滤流中的每个元素执行的使用者。ForEach是一个终端操作。它是void的，所以我们不能调用另一个流操作。 stringCollection .stream() .filter((s) -> s.startsWith(\"a\")) .forEach(System.out::println);// \"aaa2\", \"aaa1\" Sorted Sorted是一个中间操作，它返回流的排序视图。元素按自然顺序排序，除非传递自定义Comparator。 stringCollection .stream() .sorted() .filter((s) -> s.startsWith(\"a\")) .forEach(System.out::println);// \"aaa1\", \"aaa2\" ==请记住，sorted只创建流的排序视图，而不操作后台集合的顺序。stringCollection的顺序是不变的:== System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map 中间操作映射(Map)通过给定的函数将每个元素转换为另一个对象。下面的示例将每个字符串转换为大写字符串。但是您也可以使用map将每个对象转换为另一种类型。结果流的泛型类型取决于传递给map的函数的泛型类型。 // 映射map 从小写变成大写, 并按照从小到大排序stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -> b.compareTo(a)) .forEach(System.out::println);// \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\" Match 可以使用各种匹配操作来检查某个谓词是否与流匹配。所有这些操作都是terminal，并返回一个布尔结果。 // 是否有至少一个以a开头的存在?boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -> s.startsWith(\"a\"));System.out.println(anyStartsWithA); // true//是否全都是以a开头?boolean allStartsWithA = stringCollection .stream() .allMatch((s) -> s.startsWith(\"a\"));System.out.println(allStartsWithA); // false// 是否不存在以z开头?boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -> s.startsWith(\"z\"));System.out.println(noneStartsWithZ); // true Count Count是一个终端操作，将流中的元素个数作为long返回。 // 以B开头的个数long startsWithB = stringCollection .stream() .filter((s) -> s.startsWith(\"b\")) .count();System.out.println(startsWithB); // 3 Reduce 这个终端操作使用给定函数对流中的元素进行还原。结果是一个可选(Optional)的保存减少的值。 Optional&lt;String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -> s1 + \"#\" + s2);reduced.ifPresent(System.out::println);// \"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\" Parallel Streams 如上所述，流可以是顺序的，也可以是并行的。顺序流上的操作在单个线程上执行，而并行流上的操作在多个线程上并发执行。 下面的示例演示了通过使用并行流来提高性能是多么容易。 首先，我们创建了一系列独特元素: int max = 1000000;List&lt;String> values = new ArrayList&lt;>(max);for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString());&#125; 现在我们测量对这个集合的流进行排序所花费的时间。 Sequential Sort long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(\"sequential sort took: %d ms\", millis));// sequential sort took: 899 ms Parallel Sort long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(\"parallel sort took: %d ms\", millis));// parallel sort took: 472 ms 正如您可以看到的，这两个代码片段几乎是相同的，但并行排序大约快50%。您需要做的就是将stream()更改为parallelStream()。 Map 如前所述，映射不支持流。相反，映射现在支持各种新的、有用的方法来完成常见的任务。 Map&lt;Integer, String> map = new HashMap&lt;>();for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, \"val\" + i);&#125;map.forEach((id, val) -> System.out.println(val)); 上面的代码应该是不言自明的:putIfAbsent阻止我们写额外的if null检查;forEach接受一个消费者来为映射的每个值执行操作。 这个例子展示了如何使用函数在mao上计算代码: map.computeIfPresent(3, (num, val) -> val + num);map.get(3); // val33map.computeIfPresent(9, (num, val) -> null);map.containsKey(9); // falsemap.computeIfAbsent(23, num -> \"val\" + num);map.containsKey(23); // truemap.computeIfAbsent(3, num -> \"bam\");map.get(3); // val33 接下来，我们学习如何删除一个给定键的条目，仅当它当前映射到一个给定值时: map.remove(3, \"val3\");map.get(3); // val33map.remove(3, \"val33\");map.get(3); // null 另一个有用的方法: map.getOrDefault(42, \"not found\"); // not found 合并一个map条目是很容易的: map.merge(9, \"val9\", (value, newValue) -> value.concat(newValue));map.get(9); // val9map.merge(9, \"concat\", (value, newValue) -> value.concat(newValue));map.get(9); // val9concat 合并要么把键/值放到映射中，如果键不存在，要么调用合并函数来改变现有的值。 Date API Java 8在Java .time包下包含了一个全新的日期和Date API。新的Date API可以与J Joda-Time库相比较，但是它们是不同的。下面的示例涵盖了这个新API的最重要部分。 Clock Clock提供对当前日期和时间的访问。时钟知道一个时区，可以用来代替System.currentTimeMillis()来检索当前的毫秒数。这种时间线上的瞬时点也可以用Instant类表示。instant可用于创建遗留的java.util.Date对象。 Clock clock = Clock.systemDefaultZone();long millis = clock.millis();Instant instant = clock.instant();Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones 时区用ZoneId表示。可以通过静态工厂方法轻松地访问它们。时区定义了在瞬间和本地日期和时间之间进行转换时非常重要的偏移量。 System.out.println(ZoneId.getAvailableZoneIds());// prints all available timezone idsZoneId zone1 = ZoneId.of(\"Europe/Berlin\");ZoneId zone2 = ZoneId.of(\"Brazil/East\");System.out.println(zone1.getRules());System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=+01:00]// ZoneRules[currentStandardOffset=-03:00] LocalTime LocalTime表示没有时区的时间，例如晚上10点或17:30:15。下面的示例为上面定义的时区创建两个本地时间。然后我们比较这两个时间，并计算这两个时间的 LocalTime now1 = LocalTime.now(zone1);LocalTime now2 = LocalTime.now(zone2);System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); // -3System.out.println(minutesBetween); // -239 LocalTime附带了各种工厂方法来简化新实例的创建，包括时间字符串的解析。 LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late); // 23:59:59DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);System.out.println(leetTime); // 13:37 LocalDate LocalDate表示一个不同的日期，例如2014-03-11。它是不可变的，工作方式与LocalTime完全类似。该示例演示了如何通过增加或减少日、月或年来计算新的日期。请记住，每个操作都返回一个新实例。 LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY 从字符串中解析LocalDate就像解析LocalTime一样简单: DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter);System.out.println(xmas); // 2014-12-24 LocalDateTime LocalDateTime表示**日期-时间**。它将上面的日期和时间合并到一个实例中。LocalDateTime是不可变的，工作原理类似于LocalTime和LocalDate。我们可以利用方法从日期-时间中检索某些字段: LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 1439 通过附加的时区信息，可以将其转换为瞬间。瞬间可以很容易地转换为java.util.Date类型的遗留日期。 Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();Date legacyDate = Date.from(instant);System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化日期-时间就像格式化日期或时间一样。我们可以从自定义模式创建格式化器，而不是使用预定义的格式。 DateTimeFormatter formatter = DateTimeFormatter .ofPattern(\"MMM dd, yyyy - HH:mm\");LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);String string = formatter.format(parsed);System.out.println(string); // Nov 03, 2014 - 07:13 与java.text.NumberFormat不同，新的DateTimeFormatter是不可变的和线程安全的。 Annotations Java 8中的注释是可重复的。让我们直接进入一个例子来解决这个问题。 首先，我们定义一个包装注释，它包含一个实际注释的数组: @interface Hints &#123; Hint[] value();&#125;@Repeatable(Hints.class)@interface Hint &#123; String value();&#125; Java 8允许我们通过声明注释@Repeatable来使用相同类型的多个注释。 变体1:使用容器注释(旧式) @Hints(&#123;@Hint(\"hint1\"), @Hint(\"hint2\")&#125;)class Person &#123;&#125; 变体2:使用可重复的注释(新学校) @Hint(\"hint1\")@Hint(\"hint2\")class Person &#123;&#125; 通过使用变体2,java编译器隐式地在底层设置@Hints注释。这对于通过反射阅读注释信息很重要。 Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint); // nullHints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length); // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length); // 2 尽管我们从来没有在Person类上声明@Hints注释，但通过getnotation (hint .class)仍然可读。然而，更方便的方法是getAnnotationsByType，它允许直接访问所有带注释的@Hin注释。 此外，Java 8中注释的使用扩展到了两个新的目标: @Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)@interface MyAnnotation &#123;&#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"}],"author":"sizaif"},{"title":"Py自动化脚本实现去除hexo标签插件语法","slug":"py自动化脚本实现去除hexo标签插件语法","date":"2021-08-08T13:26:40.000Z","updated":"2021-09-19T10:15:49.000Z","comments":true,"path":"posts/28f3a3fd/","link":"","permalink":"https://www.sizaif.com/posts/28f3a3fd/","excerpt":"","text":"py自动化脚本实现去除hexo标签插件语法 [TOC] 需求 鱼和熊掌不可兼得,当采用typora编写md文档时,typora等其他软件是不支持hexo的插件语法的,故而不会实时渲染的.只会显示源代码: 例如 源码 &#123;% note danger, note error/danger %&#125; &#123;% note success, note done/success %&#125; 当同步发表到CSDN等其他博客时,会把源代码显示出来,显得非常不美观,且含有乱码. 故而写一个自动化脚本去除含有 hexo 语法的 内容, 尝试还源一个纯净的md文件 代码 code # !/usr/bin/python # -*- coding: utf-8 -*- # @Author: float311@163.com; sizaif2000@163.com # @Description: 将hexo博客修改为csdn可以使用的格式 # @Date 2021/8/8 17:59 # @Update 2021-08-09 10:17:50 # @note: # 已知bug: # 1. hexo语法不能与文本混用,即处在一行中, 例如: 带 &#123;% u 下划线 %&#125; 的文本 ; 会导致 文本内容丢失 # 2. 代码框中内容也会被处理 import sys,re def matchstring(line): # radio, checkout note matchradio = re.search(r'&#123;% [rcn].*',line,re.I) if matchradio: return re.sub( r'%&#125;', \"\", ','.join(line.split(',')[1:]) ).replace(\" \", \"\") # floding timeline, tab end matchall = re.search(r'&#123;% [fte].*',line,re.I) if matchall: # 全部丢弃 return None # link matchlink = re.search(r'&#123;% link .*',line,re.I) if matchlink: temp = line.split(',') line = \"[\"+temp[0].split(' ')[-1]+\"](\"+re.sub(r'%&#125;',\"\",temp[-1])+\")\" return line.strip() # audio,video matchaudio = re.search(r'&#123;% [av].*',line,re.I) if matchaudio: return line.split(' ')[-2].replace(\" \",\"\") # &lt;!--类 matchall2 = line.find(\"&lt;!--\") if matchall2: return None def modify(original, result): \"\"\" 根据hexo MD文件生成CSDN博客适用的MD文件 :param original: 源文件 :param result: 新文件 \"\"\" content = \"\" with open(original, \"r+\", encoding=\"UTF-8\") as o: for line in o.readlines(): if line.find(\"&#123;%\") == -1 and line.find(\"&lt;!--\"): content += line else: line = matchstring(line) if line is not None: content += line with open(result, \"w+\", encoding=\"UTF-8\") as n: n.write(content) if __name__ == '__main__': original_md = sys.argv[1] + \".md\" result_md = sys.argv[2] + \".md\" modify(original_md, result_md) 使用方法 # 文件名不需要带md $ py main 源文件 输出文件 已知bug radio,checkout,note 文本内容中不能含有’,'(逗号), 会导致分割数据丢失 hexo语法不能与文本混用,即处在一行中, 例如: 带&#123;% u 下划线 %&#125;的文本; 会导致文本内容丢失 代码框中的内容也会被处理 ​ 上面的情况暂时需要手动处理 感谢 感谢 float311@163.com","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Python","slug":"技术向/Python","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Python/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://www.sizaif.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Python","slug":"Python","permalink":"https://www.sizaif.com/tags/Python/"}],"author":"sizaif"},{"title":"Hexo-Gui Project","slug":"hexo-gui-project","date":"2021-08-08T12:35:30.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/739d4da5/","link":"","permalink":"https://www.sizaif.com/posts/739d4da5/","excerpt":"","text":"[toc] hexo图形界面 gui需求文档 [ ] 部署到github [ ] 一键创建文章,并自动资源管理器中打开_post文件夹 [ ] 一键创建page,并自动资源管理器中打开source文件夹 [ ] 一键本地预览 [ ] 一键生成,发布到github仓库( 需要配置仓库名称, 待讨论) [ ] 一键打开更改hexo配置 [ ] 一键打开更改hexo 主题配置 一键创建文章 几种方案: 选择其中一种 [ ] 一键创建文章,并自动资源管理器中打开_post文件夹 [ ] 一键创建文章,并自动调用typora打开文章 一键创建page 方案雷同 创建文章 一键本地预览 $ hexo s -g 一键生成,发布到github仓库 若直接调用 $ hexo s -d 则会交互要求输入 github用户名和密码进行验证 不想交互输入的话, 提前设定 用户名和密码 使用sshkey git推送 一键打开设置hexo配置 类同 更改hexo主题配置 一键打开更改hexo 主题配置 需要在hexo 根目录下 新建_config.主题.yml 调用 程序打开, 或者 打开所在文件夹,或者 根据主题一键部署(待讨论, 工作量大) 选择其中一种 [ ] 调用程序打开 e.g sublime text, notep++,等 [ ] 直接打开所在文件夹,用户自己打开配置 [ ] 调用窗口,gui 设定参数(工作量大)","categories":[{"name":"项目","slug":"项目","permalink":"https://www.sizaif.com/navigation/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"github计划","slug":"github计划","permalink":"https://www.sizaif.com/tags/github%E8%AE%A1%E5%88%92/"}],"author":"sizaif"},{"title":"AutoHotkey+Typora 实现快捷键输入Hexo标签插件","slug":"AutoHotkey-Typora-实现快捷键输入hexo标签插件","date":"2021-08-08T12:30:40.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/96be5746/","link":"","permalink":"https://www.sizaif.com/posts/96be5746/","excerpt":"","text":"AutoHotkey+Typora 实现快捷键输入hexo标签插件 [toc] 需求 使用hexo写博客时,hexo包括主题文件,提供了丰富的标签插件美化,在博客上非常美观简洁,甚是喜欢. 但语法写起来比较麻烦,需要每次查询,或者手打. 人类的本质是去掉重复工作,懒是提高生产力的最大障碍. 故而想到了使用快捷键的方式在typora中快速的插入语法 所需环境 AutoHotkey Typora AutoHotkey: 去官网安装即可 AutoHotkey官网https://www.autohotkey.com/ Typora: 去官网安装 Typora官网https://typora.io/ 编写Autohotkey脚本 创建xxx.ahk文件 粘贴我写的代码进去, 可自定义脚本,添加其他功能. ^ : ctrl !: alt #: win +: shift ~: alt+tab 代码 ; Typora ; 快捷设置兼容hexo格式 ; SendInput &#123;Text&#125; 解决中文输入法问题 #IfWinActive ahk_exe Typora.exe &#123; ; ctrl+1 tab ^1::addtabcode() ; ctrl+2 note ^2::addnotecode() ; ctrl+3 folding ^3::addfoldingcode() ; ctrl+4 link ^4::addlinkcode() ; ctrl+5 span ^5::addspancode() ; ctrl+6 radio ^6::addradiocode() &#125; ; 快捷设置tab addtabcode()&#123; clipboard := \"&#123;% tabs tab-id %&#125;`n`t&lt;!-- tab 1 -->`nreplace`n&lt;!-- endtab -->`n&lt;!-- tab 2 -->`nreplace`n&lt;!-- endtab -->`n&#123;% endtabs %&#125;\" Send ^v return &#125; ; 快捷设置note addnotecode()&#123; clipboard := \"&#123;% note danger, note error/danger %&#125;`n&#123;% note success, note done/success %&#125;\" Send ^v return &#125; ; 快捷设置folding addfoldingcode()&#123; clipboard := \"&#123;% folding green, text %&#125;`n&#123;% endfolding %&#125;\" Send ^v return &#125; ; 快捷设置link addlinkcode()&#123; clipboard := \"&#123;% link title, link %&#125;\" Send ^v return &#125; ; 快捷设置span addspancode()&#123; clipboard := \"&#123;% span parm, txt %&#125;\" Send ^v return &#125; ; 快捷设置radio addradiocode()&#123; clipboard := \"&#123;% radio green checked, text %&#125;\" Send ^v return &#125; 编译运行 xxx.ahk文件 鼠标右键文件 compiler script 双击启动脚本 Typora中运行 快去愉快的测试吧! 遇到问题 当设置 alt 按键的时候, 如果运行时按下出现键盘功能变得诡异, 请再按一次alt 相关文档 但鱼和熊掌不可兼得,当采用typora编写md文档时,typora等其他软件是不支持hexo的插件语法的,故而不会实时渲染的.只会显示源代码: 例如 源码 &#123;% note danger, note error/danger %&#125; &#123;% note success, note done/success %&#125; 当去CSDN等其他博客发表时,会把源代码显示出来,显得非常丑. 解决方法: py自动化脚本实现去除hexo标签插件语法https://www.sizaif.com/2021/08/08/py%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%BB%E9%99%A4hexo%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6%E8%AF%AD%E6%B3%95/","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}],"author":"sizaif"},{"title":"Volantis 5.0 标签插件","slug":"volantis-5-0-标签插件","date":"2021-08-08T03:24:11.000Z","updated":"2021-08-14T14:15:24.000Z","comments":true,"path":"posts/e55b6fd4/","link":"","permalink":"https://www.sizaif.com/posts/e55b6fd4/","excerpt":"","text":"volantis 5.0 标签插件 为了兼容老用户，旧的标签插件在重构之前依然沿用旧的格式，即 command + 空格 作为参数分隔符，而部分新增标签插件是 空格 + 英文竖线 + 空格 ，请注意区分。 我们也在探索哪种分隔符既简单又不容易引起冲突，所以可能存在多种格式，具体以对应文档描述为准。 text 效果源码带 下划线 的文本；带 着重号 的文本；带 波浪线 的文本；带 删除线 的文本 键盘样式的文本：⌘ + D 密码样式的文本：这里没有验证码带 &#123;% u 下划线 %&#125; 的文本；带 &#123;% emp 着重号 %&#125; 的文本；带 &#123;% wavy 波浪线 %&#125; 的文本；带 &#123;% del 删除线 %&#125; 的文本 键盘样式的文本：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125; 密码样式的文本：&#123;% psw 这里没有验证码 %&#125; 标签插件https://volantis.js.org/v5/tag-plugins/","categories":[{"name":"建站笔记","slug":"建站笔记","permalink":"https://www.sizaif.com/navigation/categories/%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}],"author":"sizaif"},{"title":"Hexo+github博客搭建","slug":"hexo-github博客搭建","date":"2021-08-08T03:20:47.000Z","updated":"2021-09-19T10:16:09.000Z","comments":true,"path":"posts/b4a23979/","link":"","permalink":"https://www.sizaif.com/posts/b4a23979/","excerpt":"","text":"hexo+github博客搭建 需求 将本地博客存放在DropBox云中 使用hexo构建博客系统 使用github作为远程仓库 使用gitee作为备用仓库 绑定域名 本地使用ssh git方式推送 搭建步骤 安装必要环境 git windows10 (非必须) Hexo: 4.2 ~ 5.x hexo-cli: 3.1 ~ 4.x node.js: 12.16 ~ latest # 推荐使用 LTS 版 npm: 6.13 ~ latest 安装node,js: https://nodejs.org/en/ 安装git: https://git-scm.com/ 安装node.js 和git后进行测试: $ npm -v $ git --version 安装hexo: 因为我将blog文件存放在Dropbox云中, 而Dropbox本地文件在.Dropbox\\XXX 若之间使用npm命令则会出现找不到包的问题 我这里的解决方法是: 先在控制台使用npm 命令安装 npm install hexo-cli -g 将目录C:\\Users\\XXX\\AppData\\Roaming\\npm 下的 node_modules和 hexo*相关的文件复制一份到.Dropbox\\XXX\\Blog\\下 在.Dropbox\\XXX\\Blog\\下打开控制台继续执行安装hexo的命令 # 安装 npm install hexo-cli -g # 测试版本 $ hexo -v # 安装 $ hexo init blog &amp; cd blog &amp; npm install # 浏览器访问 localhost:4000 测试 $ hexo server # 此时本地安装hexo已完成 hexo文件树: . ├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json ├── scaffolds # 模版文件夹 ├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹 | ├── _drafts # 草稿文件 | └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 如果遇到npm 安装 报错问题, 尝试删除 package-lock.json 再试 hexo常用命令: hexo npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿 hexo publish [layout] &lt;title> 安装hexo主题: 安装适合自己口味的主题 设置github github 新建仓库,仓库名称为 XXX.github.io; XXX为你的用户名! 注意项: 1. ==仓库名称中XXX必须与用户名对应!!!!== 2. 方式为`public` 设置使用ssh方式推送 查看本地C:\\Users\\XXX\\.ssh 下有无id_rsa样式文件 若无,创建新的ssh 密钥, $ ssh-keygen -T rsa -C 'github邮箱地址' # 回车继续, passphrase 密码可输入可不输 复制.ssh目录下的id_rsa.pub中文件内容到github ssh keys管理中 测试ssh $ ssh git@github.com 若出现: ssh: connect to host github.com port 22: Connection refused 错误 解决方法: XXX\\.ssh目录下创建config文件 config文件中写入下面的信息： Host github.com User xxxxx@xx.com(github用户邮箱) Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 再使用ssh git@github.com测试 选择配置自己的hexo 主题(可选) 选择适合自己口味的blog主题即可 域名绑定github 域名解析商解析方式选择CNAME; 站点为: XXX.github.io xxx.github.io仓库中,setting选项Page中配置 Custom domain 内容为你的域名,save保存 blog 根目录下的source文件中创建CNAME文件 (必须选项) 内容为你的域名 作用: 防止每次hexo推送博客后,域名解析失效,重新配置Custom domain","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Hexo","slug":"技术向/Hexo","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Hexo/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}],"author":"sizaif"},{"title":"吹一吹云空调","slug":"吹一吹云空调","date":"2021-08-07T17:09:52.000Z","updated":"2022-02-03T09:28:25.511Z","comments":true,"path":"posts/bfcf32d/","link":"","permalink":"https://www.sizaif.com/posts/bfcf32d/","excerpt":"","text":"","categories":[],"tags":[],"author":"sizaif"},{"title":"第一次建站","slug":"第一次建站","date":"2021-08-07T15:28:55.000Z","updated":"2021-09-19T07:24:21.000Z","comments":true,"path":"posts/8b3781ae/","link":"","permalink":"https://www.sizaif.com/posts/8b3781ae/","excerpt":"","text":"[TOC] 春江花月夜 春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰； 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年望相似。 不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月裴回，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。 寄语 愿所有日日夜夜的努力都能迎来明日的初升的太阳 by sizaif 2021-08-07 23:38:41 你好明天","categories":[{"name":"杂文","slug":"杂文","permalink":"https://www.sizaif.com/navigation/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}],"author":"sizaif"},{"title":"Java8 Stream 教程学习","slug":"Java8-Stream-教程学习","date":"2021-05-29T12:37:59.000Z","updated":"2021-09-19T10:15:53.000Z","comments":true,"path":"posts/2180828f/","link":"","permalink":"https://www.sizaif.com/posts/2180828f/","excerpt":"","text":"Java8 Stream 教程学习 😄 @Auther: sizaif 📆 2021-05-29 20:37:59 🔗 转载翻译于 https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/ [TOC] 说明 这个示例驱动的教程深入概述了Java 8流。当我第一次读到Stream API时，我对它的名字感到困惑，因为它听起来类似于Java I/O中的InputStream和OutputStream。但是Java 8流是完全不同的东西。Stream是Monads，因此在将函数式编程引入Java中扮演着重要的角色: 在函数式编程，Monads是一个结构，表示计算定义为一系列的步骤。一个具有单子结构的类型定义了将操作链起来的含义，或将该类型的函数嵌套在一起。 本指南教你如何使用Java 8流以及如何使用不同类型的可用流操作。您将了解处理顺序以及流操作的顺序如何影响运行时性能。更强大的流操作reduce，collect和flatMap将详细介绍。本教程最后对并行流进行了深入研究。 流是如何工作的(How streams work) 一个流表示一个元素序列，并支持不同类型的操作来对这些元素执行计算: List&lt;String> myList = Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\"); myList .stream() .filter(s -> s.startsWith(\"c\")) .map(String::toUpperCase) .sorted() .forEach(System.out::println); // C1 // C2 流操作可以是中间操作，也可以是终端操作。中间操作返回一个流，因此我们可以不使用分号链接多个中间操作.终端操作要么为空，要么返回非流结果.上面的过滤器示例中，map和sorted是中间操作，而forEach是终端操作。有关所有可用流操作的完整列表，请参阅stream Javadoc。如上例中所示的这种流操作链也称为操作管道。 大多数流操作接受某种类型的lambda表达式参数，一个指定操作确切行为的函数接口。大多数操作必须是无干扰和无状态的。这是什么意思? 当一个函数不修改流的基础数据源时，它就是无干扰的,例如,在上面的例子中，没有一个lambda表达式通过从集合中添加或删除元素来修改myList。 当操作的执行是确定的时，函数就是无状态 的，例如，在上面的例子中，没有lambda表达式依赖于在执行过程中可能改变的外部作用域的任何可变变量或状态。 不同类型的流(Different kind of streams) 可以从各种数据源创建流，特别是集合。列表和集合支持新的方法stream()和parallelStream()来创建顺序流或并行流。并行流能够在多个线程上操作，本教程的后面一节将对此进行介绍。我们现在主要关注顺序流: Arrays.asList(\"a1\", \"a2\", \"a3\") .stream() .findFirst() .ifPresent(System.out::println); // a1 在对象列表上调用方法stream()将返回一个常规对象流。但我们不需要创建集合来处理流，就像我们在下一个代码示例中看到的: Stream.of(\"a1\", \"a2\", \"a3\") .findFirst() .ifPresent(System.out::println); // a1 只需使用stream .of()从一堆对象引用创建一个流。 除了常规的对象流之外，Java 8还提供了特殊类型的流，用于处理基本数据类型int、long和double。你可能已经猜到是IntStream, LongStream和DoubleStream。 IntStreams可以使用IntStream.range()替换常规的for循环: IntStream.range(1, 4) .forEach(System.out::println); // 1 // 2 // 3 所有这些基元流都像普通的对象流一样工作，有以下不同:基元流使用特化的lambda表达式，例如用IntFunction代替Function，用IntPredicate代替Predicate。原始流支持附加的终端聚合操作sum()和average(): Arrays.stream(new int[] &#123;1, 2, 3&#125;) .map(n -> 2 * n + 1) .average() .ifPresent(System.out::println); // 5.0 有时将常规对象流转换为基本流很有用，反之亦然。为此，对象流支持特殊的映射操作mapToInt()、mapToLong()和mapToDouble: Stream.of(\"a1\", \"a2\", \"a3\") .map(s -> s.substring(1)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); // 3 原始流可以通过mapToObj()转换为对象流: IntStream.range(1, 4) .mapToObj(i -> \"a\" + i) .forEach(System.out::println); // a1 // a2 // a3 下面是一个组合的例子:double类型的流首先映射到int类型的流，然后再映射到string类型的对象流: Stream.of(1.0, 2.0, 3.0) .mapToInt(Double::intValue) .mapToObj(i -> \"a\" + i) .forEach(System.out::println); // a1 // a2 // a3 处理次序(Processing Order) 现在，我们已经学习了如何创建和使用不同类型的流，让我们深入了解如何在幕后处理流操作。中间操作的一个重要特征是惰性。看看这个例子，这里缺少了一个终端操作: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> &#123; System.out.println(\"filter: \" + s); return true; &#125;); 在执行此代码片段时，不会将任何内容打印到控制台。这是因为只有在存在终端操作时才会执行中间操作。 让我们通过终端操作forEach来扩展上面的示例: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> &#123; System.out.println(\"filter: \" + s); return true; &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); 执行此代码片段会在控制台上产生所需的输出: filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c 结果的顺序可能会令人惊讶。一种简单的方法是在流的所有元素上一个接一个地水平执行操作.但是每个元素都沿着链垂直移动。第一个字符串“d2”传递filter然后forEach，只有这样第二个字符串“a2”才会被处理。 这种行为可以减少对每个元素执行的实际操作数，在下一个例子中我们可以看到: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .anyMatch(s -> &#123; System.out.println(\"anyMatch: \" + s); return s.startsWith(\"A\"); &#125;); // map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2 只要谓词应用于给定的输入元素，anyMatch操作就返回true。对于传递给“A2”的第二个元素是这样的。由于流链是垂直执行的，所以在这种情况下只需要执行两次map。因此，不是映射流的所有元素，而是尽可能少地调用map。 Why order matters 下一个示例包含两个中间操作map和filter以及终端操作forEach。让我们再次检查这些操作是如何执行的: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .filter(s -> &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"A\"); &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); // map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C 您可能已经猜到，对于底层集合中的每个字符串，map和filter都被调用5次，而forEach只被调用一次。 如果我们改变操作的顺序，将filter移到链的开头，就可以大大减少实际执行的次数: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); // filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c 现在，map只被调用一次，所以对于大量输入元素，操作管道的执行速度要快得多。在编写复杂的方法链时，请记住这一点。 让我们通过一个额外的操作来扩展上面的例子，sorted: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .sorted((s1, s2) -> &#123; System.out.printf(\"sort: %s; %s\\n\", s1, s2); return s1.compareTo(s2); &#125;) .filter(s -> &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); 排序是一种特殊的中间操作。这是一个所谓的有状态操作，因为为了对元素集合排序，您必须在排序期间保持状态。 执行这个示例会得到以下控制台输出: sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2 首先，对整个输入集合执行排序操作。换句话说，排序是水平执行的。所以在这种情况下，对于输入集合中的每个元素的多个组合，sorted被调用8次。 再一次，我们可以通过重新排序链来优化性能: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .sorted((s1, s2) -> &#123; System.out.printf(\"sort: %s; %s\\n\", s1, s2); return s1.compareTo(s2); &#125;) .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); // filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2 在本例中，从未调用sorted，因为filter将输入集合减少到只有一个元素。因此，对于更大的输入集合，性能会大大提高 复用流(Reusing Streams) Java 8流不能被重用。当你调用任何终端操作时，流就会被关闭: Stream&lt;String> stream = Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> s.startsWith(\"a\")); stream.anyMatch(s -> true); // ok stream.noneMatch(s -> true); // exception 在同一个流的anyMatch之后调用nonmatch会导致以下异常: java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459) at com.winterbe.java8.Streams5.test7(Streams5.java:38) at com.winterbe.java8.Streams5.main(Streams5.java:28) 为了克服这个限制，我们必须为想要执行的每个终端操作创建一个新的流链，例如，我们可以创建一个流供应商来构造一个所有中间操作都已经设置好的新流: Supplier&lt;Stream&lt;String>> streamSupplier = () -> Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> s.startsWith(\"a\"));streamSupplier.get().anyMatch(s -> true); // okstreamSupplier.get().noneMatch(s -> true); // ok 对get()的每次调用都会构造一个新流，我们将在其上保存以调用所需的终端操作。 高级操作(Advanced Operations) 流支持许多不同的操作。我们已经学习了最重要的操作，如filter或map。我把所有其他可用的操作留给您去发现(请参阅Stream Javadoc)。相反，让我们深入研究更复杂的操作收集、flatMap和reduce。 本节中的大多数代码示例使用以下人员列表进行演示: class Person &#123; String name; int age; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return name; &#125; &#125; List&lt;Person> persons = Arrays.asList( new Person(\"Max\", 18), new Person(\"Peter\", 23), new Person(\"Pamela\", 23), new Person(\"David\", 12)); Collect Collect是一个非常有用的终端操作，可以将流的元素转换为另一种结果，例如: list,map,set.Collect接受Collector，收集器由四种不同的操作组成:供应商(supplier)、累加器( accumulator)、合并器(combiner)和收尾器(finisher)。乍一听，这听起来非常复杂，但好的部分是Java 8通过collector类支持各种内置收集器。所以对于最常见的操作，你不需要自己实现收集器。 让我们从一个非常常见的用例开始: List&lt;Person> filtered = persons .stream() .filter(p -> p.name.startsWith(\"P\")) .collect(Collectors.toList());System.out.println(filtered); // [Peter, Pamela] 如您所见，从流的元素构造一个列表非常简单。需要一个集合而不是列表-只需使用collections . toset()。 下一个例子将所有人按年龄分组: Map&lt;Integer, List&lt;Person>> personsByAge = persons .stream() .collect(Collectors.groupingBy(p -> p.age)); personsByAge .forEach((age, p) -> System.out.format(\"age %s: %s\\n\", age, p)); // age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David] Collectors是非常多才多艺的。你也可以创建流元素的聚合， 例如确定所有人的平均年龄: Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -> p.age)); System.out.println(averageAge); // 19.0 如果您对更全面的统计信息感兴趣，汇总收集器将返回一个特殊的内置汇总统计信息对象。因此，我们可以简单地确定人员的最小年龄，最大年龄和算术平均年龄以及总和和计数。 IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -> p.age));System.out.println(ageSummary);// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125; 下一个例子将所有人连接到一个字符串中: String phrase = persons .stream() .filter(p -> p.age >= 18) .map(p -> p.name) .collect(Collectors.joining(\" and \", \"In Germany \", \" are of legal age.\"));System.out.println(phrase);// In Germany Max and Peter and Pamela are of legal age. 连接收集器接受分隔符以及可选的前缀和后缀。 为了将流元素转换为映射，我们必须指定键和值应该如何映射。请记住，映射的键必须是唯一的，否则抛出IllegalStateException。您可以选择将merge函数作为附加参数传递，以绕过异常: Map&lt;Integer, String> map = persons .stream() .collect(Collectors.toMap( p -> p.age, p -> p.name, (name1, name2) -> name1 + \";\" + name2));System.out.println(map);// &#123;18=Max, 23=Peter;Pamela, 12=David&#125; 现在我们已经了解了一些最强大的内置收集器，让我们尝试构建自己的特殊收集器。我们想要将流中的所有人转换为单个字符串，该字符串由以|管道字符分隔的所有大写字母组成。 为了实现这一点，我们通过collector .of()创建一个新的收集器。我们必须传递收集器的四个组成部分:供应商(supplier)、累加器( accumulator)、合并器(combiner)和收尾器(finisher) Collector&lt;Person, StringJoiner, String> personNameCollector = Collector.of( () -> new StringJoiner(\" | \"), // supplier (j, p) -> j.add(p.name.toUpperCase()), // accumulator (j1, j2) -> j1.merge(j2), // combiner StringJoiner::toString); // finisherString names = persons .stream() .collect(personNameCollector);System.out.println(names); // MAX | PETER | PAMELA | DAVID 由于Java中的字符串是不可变的，我们需要一个像StringJoiner这样的helper类来让收集器构造我们的字符串。提供者最初构造这样一个带有适当分隔符的StringJoiner。累加器用于将每个人的大写名称添加到StringJoiner中。组合器知道如何将两个StringJoiners合并为一个。在最后一步中，完成器从StringJoiner构造所需的字符串。 FlatMap 我们已经学习了如何利用map操作将流的对象转换为另一种类型的对象。Map有一定的局限性，因为每个对象只能映射到另一个对象。但是，如果我们想将一个对象转换为多个其他对象，或者根本不转换该怎么办呢?这就是flatMap的救星。 FlatMap将流的每个元素转换为其他对象的流。因此，每个对象将被转换为0个、一个或多个由流支持的其他对象。这些流的内容将被放置到flatMap操作返回的流中。 在我们看到flatMap的实际应用之前，我们需要一个适当的类型层次结构: class Foo &#123; String name; List&lt;Bar> bars = new ArrayList&lt;>(); Foo(String name) &#123; this.name = name; &#125; &#125; class Bar &#123; String name; Bar(String name) &#123; this.name = name; &#125; &#125; 我们利用我们关于流的知识来实例化几个对象: List&lt;Foo> foos = new ArrayList&lt;>(); // create foos IntStream .range(1, 4) .forEach(i -> foos.add(new Foo(\"Foo\" + i))); // create bars foos.forEach(f -> IntStream .range(1, 4) .forEach(i -> f.bars.add(new Bar(\"Bar\" + i + \" &lt;- \" + f.name)))); 现在我们有一个包含三个foo的列表，每个foo由三个bar组成。 FlatMap接受一个必须返回对象流的函数。因此，为了解析每个foo的bar对象，我们只需传递适当的函数: foos.stream() .flatMap(f -> f.bars.stream()) .forEach(b -> System.out.println(b.name)); // Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3 正如您所看到的，我们已经成功地将三个foo对象的流转换为九个bar对象的流。 最后，上面的代码示例可以简化为一个流操作的单一管道: IntStream.range(1, 4) .mapToObj(i -> new Foo(\"Foo\" + i)) .peek(f -> IntStream.range(1, 4) .mapToObj(i -> new Bar(\"Bar\" + i + \" &lt;- \" f.name)) .forEach(f.bars::add)) .flatMap(f -> f.bars.stream()) .forEach(b -> System.out.println(b.name)); FlatMap也适用于Java 8中引入的Optional类。flatMap操作返回另一种类型的可选对象。因此可以利用它来防止讨厌的空检查。 想想这样一个高度分层的结构: class Outer &#123; Nested nested;&#125;class Nested &#123; Inner inner;&#125;class Inner &#123; String foo;&#125; 为了解析外部实例的内部字符串foo，你必须添加多个空检查来防止可能的nullpointerexception: Outer outer = new Outer();if (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) &#123; System.out.println(outer.nested.inner.foo);&#125; 同样的行为可以通过使用可选的flatMap操作获得: Optional.of(new Outer()) .flatMap(o -> Optional.ofNullable(o.nested)) .flatMap(n -> Optional.ofNullable(n.inner)) .flatMap(i -> Optional.ofNullable(i.foo)) .ifPresent(System.out::println); 对flatMap的每次调用返回一个可选的包装(如果存在)所需对象，如果不存在则返回null。 Reduce reduce操作将流的所有元素合并为一个结果。Java 8支持三种不同的reduce方法。第一种方法将元素流缩减为流中的一个元素。 让我们看看如何使用这个方法来确定最年长的人: persons .stream() .reduce((p1, p2) -> p1.age > p2.age ? p1 : p2) .ifPresent(System.out::println); // Pamela reduce方法接受一个BinaryOperator累加器函数。这实际上是一个BiFunction，其中两个操作数共享同一类型，在这里是Person。BiFunctions类似于Function，但接受两个参数。示例函数比较两个人的年龄，以便返回具有最大年龄的人。 第二个reduce方法同时接受标识值和BinaryOperator累加器。该方法可用于构造一个新的Person， 该Person具有来自流中所有其他人员的聚合名称和年龄: Person result = persons .stream() .reduce(new Person(\"\", 0), (p1, p2) -> &#123; p1.age += p2.age; p1.name += p2.name; return p1; &#125;); System.out.format(\"name=%s; age=%s\", result.name, result.age); // name=MaxPeterPamelaDavid; age=76 第三个reduce方法接受三个参数:一个标识值、一个BiFunction累加器和一个BinaryOperator类型的组合函数。因为身份值类型不限于Person类型，我们可以利用这个约简来确定所有人的年龄总和: Integer ageSum = persons .stream() .reduce(0, (sum, p) -> sum += p.age, (sum1, sum2) -> sum1 + sum2);System.out.println(ageSum); // 76 正如你所看到的，结果是76，但在引擎盖下到底发生了什么?让我们通过一些调试输出来扩展上面的代码: Integer ageSum = persons .stream() .reduce(0, (sum, p) -> &#123; System.out.format(\"accumulator: sum=%s; person=%s\\n\", sum, p); return sum += p.age; &#125;, (sum1, sum2) -> &#123; System.out.format(\"combiner: sum1=%s; sum2=%s\\n\", sum1, sum2); return sum1 + sum2; &#125;);// accumulator: sum=0; person=Max// accumulator: sum=18; person=Peter// accumulator: sum=41; person=Pamela// accumulator: sum=64; person=David 正如你所看到的，累加器函数完成了所有的工作。它首先被调用，初始值为0，第一个人是Max。在接下来的三个步骤中，总和随着最后一步的年龄不断增加，直到76岁。 Wait what?合成器(combiner)从来没有被调用?并行执行同一个流将解除秘密: Integer ageSum = persons .parallelStream() .reduce(0, (sum, p) -> &#123; System.out.format(\"accumulator: sum=%s; person=%s\\n\", sum, p); return sum += p.age; &#125;, (sum1, sum2) -> &#123; System.out.format(\"combiner: sum1=%s; sum2=%s\\n\", sum1, sum2); return sum1 + sum2; &#125;); // accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35 并行执行此流会导致完全不同的执行行为。现在合并器被调用了。由于累加器是并行调用的，因此需要合并器将单独累加的值相加。 让我们在下一章更深入地探讨并行流。 并行流(Parallel Streams) 流可以并行执行，以提高大量输入元素的运行时性能。并行流使用通过静态ForkJoinPool. commonpool()方法可用的公共ForkJoinPool。底层线程池的大小最多使用5个线程—取决于可用的物理CPU内核的数量: ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); // 3 在我的机器上，公共池初始化时的并行度默认为3。这个值可以通过设置以下JVM参数来增加或减少: -Djava.util.concurrent.ForkJoinPool.common.parallelism=5 集合支持parallelStream()方法来创建元素的并行流。或者，您可以在给定流上调用中间方法parallel()来将顺序流转换为并行对应流。 为了少描述并行流的并行执行行为，下面的例子将当前线程的信息打印到sout: Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\") .parallelStream() .filter(s -> &#123; System.out.format(\"filter: %s [%s]\\n\", s, Thread.currentThread().getName()); return true; &#125;) .map(s -> &#123; System.out.format(\"map: %s [%s]\\n\", s, Thread.currentThread().getName()); return s.toUpperCase(); &#125;) .forEach(s -> System.out.format(\"forEach: %s [%s]\\n\", s, Thread.currentThread().getName())); 通过研究调试输出，我们应该更好地理解哪些线程实际用于执行流操作: filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-1] map: a2 [ForkJoinPool.commonPool-worker-1] filter: c2 [ForkJoinPool.commonPool-worker-3] map: c2 [ForkJoinPool.commonPool-worker-3] filter: c1 [ForkJoinPool.commonPool-worker-2] map: c1 [ForkJoinPool.commonPool-worker-2] forEach: C2 [ForkJoinPool.commonPool-worker-3] forEach: A2 [ForkJoinPool.commonPool-worker-1] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-3] map: a1 [ForkJoinPool.commonPool-worker-3] forEach: A1 [ForkJoinPool.commonPool-worker-3] forEach: C1 [ForkJoinPool.commonPool-worker-2] 正如您可以看到的，并行流利用了公共ForkJoinPool中的所有可用线程来执行流操作。连续运行时的输出可能不同，因为实际使用的特定线程的行为是不确定的。 让我们通过一个额外的流操作——sort来扩展这个示例: Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\") .parallelStream() .filter(s -> &#123; System.out.format(\"filter: %s [%s]\\n\", s, Thread.currentThread().getName()); return true; &#125;) .map(s -> &#123; System.out.format(\"map: %s [%s]\\n\", s, Thread.currentThread().getName()); return s.toUpperCase(); &#125;) .sorted((s1, s2) -> &#123; System.out.format(\"sort: %s &lt;> %s [%s]\\n\", s1, s2, Thread.currentThread().getName()); return s1.compareTo(s2); &#125;) .forEach(s -> System.out.format(\"forEach: %s [%s]\\n\", s, Thread.currentThread().getName())); 乍一看，结果可能很奇怪: filter: c2 [ForkJoinPool.commonPool-worker-3]filter: c1 [ForkJoinPool.commonPool-worker-2]map: c1 [ForkJoinPool.commonPool-worker-2]filter: a2 [ForkJoinPool.commonPool-worker-1]map: a2 [ForkJoinPool.commonPool-worker-1]filter: b1 [main]map: b1 [main]filter: a1 [ForkJoinPool.commonPool-worker-2]map: a1 [ForkJoinPool.commonPool-worker-2]map: c2 [ForkJoinPool.commonPool-worker-3]sort: A2 &lt;> A1 [main]sort: B1 &lt;> A2 [main]sort: C2 &lt;> B1 [main]sort: C1 &lt;> C2 [main]sort: C1 &lt;> B1 [main]sort: C1 &lt;> C2 [main]forEach: A1 [ForkJoinPool.commonPool-worker-1]forEach: C2 [ForkJoinPool.commonPool-worker-3]forEach: B1 [main]forEach: A2 [ForkJoinPool.commonPool-worker-2]forEach: C1 [ForkJoinPool.commonPool-worker-1] 排序似乎只在主线程上顺序执行。实际上，在并行流上排序使用了新的Java 8方法Arrays.parallelSort()。如Javadoc中所述，如果排序是顺序执行还是并行执行，该方法决定数组的长度: 如果指定数组的长度小于最小粒度，则使用适当的Arrays对其进行排序。排序方法。 回到上一节的reduce示例。我们已经发现，combiner函数只在并行中调用，而不是在顺序流中调用。让我们看看哪些线程真正涉及: List&lt;Person> persons = Arrays.asList( new Person(\"Max\", 18), new Person(\"Peter\", 23), new Person(\"Pamela\", 23), new Person(\"David\", 12)); persons .parallelStream() .reduce(0, (sum, p) -> &#123; System.out.format(\"accumulator: sum=%s; person=%s [%s]\\n\", sum, p, Thread.currentThread().getName()); return sum += p.age; &#125;, (sum1, sum2) -> &#123; System.out.format(\"combiner: sum1=%s; sum2=%s [%s]\\n\", sum1, sum2, Thread.currentThread().getName()); return sum1 + sum2; &#125;); 控制台输出显示累加器和组合器函数在所有可用线程上并行执行: accumulator: sum=0; person=Pamela; [main] accumulator: sum=0; person=Max; [ForkJoinPool.commonPool-worker-3] accumulator: sum=0; person=David; [ForkJoinPool.commonPool-worker-2] accumulator: sum=0; person=Peter; [ForkJoinPool.commonPool-worker-1] combiner: sum1=18; sum2=23; [ForkJoinPool.commonPool-worker-1] combiner: sum1=23; sum2=12; [ForkJoinPool.commonPool-worker-2] combiner: sum1=41; sum2=35; [ForkJoinPool.commonPool-worker-2] 总之，可以这样说，并行流可以为具有大量输入元素的流带来很好的性能提升。但是请记住，像reduce和collect这样的并行流操作需要额外的计算(合并操作)，这在顺序执行时是不需要的。 此外，我们还了解到所有并行流操作共享同一个jvm范围的公共ForkJoinPool。因此，您可能希望避免实现缓慢阻塞的流操作，因为这可能会降低应用程序中严重依赖并行流的其他部分的速度。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"author":"sizaif"}],"categories":[{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/navigation/categories/Master/"},{"name":"LLVM","slug":"Master/LLVM","permalink":"https://www.sizaif.com/navigation/categories/Master/LLVM/"},{"name":"论文","slug":"Master/论文","permalink":"https://www.sizaif.com/navigation/categories/Master/%E8%AE%BA%E6%96%87/"},{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Linux","slug":"技术向/Linux","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Linux/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"},{"name":"Azure","slug":"技术向/Azure","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Azure/"},{"name":"Rust","slug":"技术向/Rust","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Rust/"},{"name":"python","slug":"技术向/python","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/python/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"Wireshark","slug":"笔记/Wireshark","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/Wireshark/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"},{"name":"游戏向","slug":"游戏向","permalink":"https://www.sizaif.com/navigation/categories/%E6%B8%B8%E6%88%8F%E5%90%91/"},{"name":"TSW2","slug":"游戏向/TSW2","permalink":"https://www.sizaif.com/navigation/categories/%E6%B8%B8%E6%88%8F%E5%90%91/TSW2/"},{"name":"Hexo","slug":"技术向/Hexo","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Hexo/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.sizaif.com/navigation/categories/%E6%9D%82%E8%B0%88/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"},{"name":"杂项","slug":"技术向/杂项","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9D%82%E9%A1%B9/"},{"name":"图床","slug":"技术向/图床","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E5%9B%BE%E5%BA%8A/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"},{"name":"Js","slug":"技术向/Js","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Js/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"},{"name":"Springboot","slug":"技术向/Springboot","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Springboot/"},{"name":"算法","slug":"技术向/算法","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"技术向/C","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/C/"},{"name":"路由器","slug":"技术向/路由器","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"VS2019","slug":"技术向/VS2019","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/VS2019/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"},{"name":"OpenCV","slug":"机器学习/OpenCV","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/OpenCV/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"},{"name":"Mysql","slug":"技术向/Mysql","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mysql/"},{"name":"JAXB","slug":"笔记/JAXB","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/JAXB/"},{"name":"Git","slug":"技术向/Git","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Git/"},{"name":"Python","slug":"技术向/Python","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Python/"},{"name":"项目","slug":"项目","permalink":"https://www.sizaif.com/navigation/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"建站笔记","slug":"建站笔记","permalink":"https://www.sizaif.com/navigation/categories/%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/"},{"name":"杂文","slug":"杂文","permalink":"https://www.sizaif.com/navigation/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"标签二","slug":"标签二","permalink":"https://www.sizaif.com/tags/%E6%A0%87%E7%AD%BE%E4%BA%8C/"},{"name":"标签一","slug":"标签一","permalink":"https://www.sizaif.com/tags/%E6%A0%87%E7%AD%BE%E4%B8%80/"},{"name":"fuzzing","slug":"fuzzing","permalink":"https://www.sizaif.com/tags/fuzzing/"},{"name":"LLVM","slug":"LLVM","permalink":"https://www.sizaif.com/tags/LLVM/"},{"name":"AFL","slug":"AFL","permalink":"https://www.sizaif.com/tags/AFL/"},{"name":"论文","slug":"论文","permalink":"https://www.sizaif.com/tags/%E8%AE%BA%E6%96%87/"},{"name":"make","slug":"make","permalink":"https://www.sizaif.com/tags/make/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.sizaif.com/tags/ubuntu/"},{"name":"Master","slug":"Master","permalink":"https://www.sizaif.com/tags/Master/"},{"name":"fastboot","slug":"fastboot","permalink":"https://www.sizaif.com/tags/fastboot/"},{"name":"驱动","slug":"驱动","permalink":"https://www.sizaif.com/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"miflash unlock","slug":"miflash-unlock","permalink":"https://www.sizaif.com/tags/miflash-unlock/"},{"name":"Azure","slug":"Azure","permalink":"https://www.sizaif.com/tags/Azure/"},{"name":"微软","slug":"微软","permalink":"https://www.sizaif.com/tags/%E5%BE%AE%E8%BD%AF/"},{"name":"rust","slug":"rust","permalink":"https://www.sizaif.com/tags/rust/"},{"name":"Rust","slug":"Rust","permalink":"https://www.sizaif.com/tags/Rust/"},{"name":"OIDC","slug":"OIDC","permalink":"https://www.sizaif.com/tags/OIDC/"},{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"https://www.sizaif.com/tags/OAuth2-0/"},{"name":"Azure AD","slug":"Azure-AD","permalink":"https://www.sizaif.com/tags/Azure-AD/"},{"name":"python","slug":"python","permalink":"https://www.sizaif.com/tags/python/"},{"name":"soap","slug":"soap","permalink":"https://www.sizaif.com/tags/soap/"},{"name":"DNS","slug":"DNS","permalink":"https://www.sizaif.com/tags/DNS/"},{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"5G","slug":"5G","permalink":"https://www.sizaif.com/tags/5G/"},{"name":"[object Object]","slug":"object-Object","permalink":"https://www.sizaif.com/tags/object-Object/"},{"name":"USIM","slug":"USIM","permalink":"https://www.sizaif.com/tags/USIM/"},{"name":"Pcap","slug":"Pcap","permalink":"https://www.sizaif.com/tags/Pcap/"},{"name":"DPI","slug":"DPI","permalink":"https://www.sizaif.com/tags/DPI/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://www.sizaif.com/tags/Wireshark/"},{"name":"ASN.1","slug":"ASN-1","permalink":"https://www.sizaif.com/tags/ASN-1/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"TSW2","slug":"TSW2","permalink":"https://www.sizaif.com/tags/TSW2/"},{"name":"Win","slug":"Win","permalink":"https://www.sizaif.com/tags/Win/"},{"name":"脚本格式","slug":"脚本格式","permalink":"https://www.sizaif.com/tags/%E8%84%9A%E6%9C%AC%E6%A0%BC%E5%BC%8F/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.sizaif.com/tags/Hexo/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.sizaif.com/tags/%E6%9D%82%E8%B0%88/"},{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"},{"name":"图床","slug":"图床","permalink":"https://www.sizaif.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Waline","slug":"Waline","permalink":"https://www.sizaif.com/tags/Waline/"},{"name":"PicGo","slug":"PicGo","permalink":"https://www.sizaif.com/tags/PicGo/"},{"name":"Gitee","slug":"Gitee","permalink":"https://www.sizaif.com/tags/Gitee/"},{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"},{"name":"Js","slug":"Js","permalink":"https://www.sizaif.com/tags/Js/"},{"name":"Layui","slug":"Layui","permalink":"https://www.sizaif.com/tags/Layui/"},{"name":"Jdk","slug":"Jdk","permalink":"https://www.sizaif.com/tags/Jdk/"},{"name":"Linux","slug":"Linux","permalink":"https://www.sizaif.com/tags/Linux/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.sizaif.com/tags/Springboot/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://www.sizaif.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"路由器","slug":"路由器","permalink":"https://www.sizaif.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"Hyper-v","slug":"Hyper-v","permalink":"https://www.sizaif.com/tags/Hyper-v/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"VS2019","slug":"VS2019","permalink":"https://www.sizaif.com/tags/VS2019/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.sizaif.com/tags/OpenCV/"},{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"},{"name":"GnuTLS","slug":"GnuTLS","permalink":"https://www.sizaif.com/tags/GnuTLS/"},{"name":"WolfSSL","slug":"WolfSSL","permalink":"https://www.sizaif.com/tags/WolfSSL/"},{"name":"教程","slug":"教程","permalink":"https://www.sizaif.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.sizaif.com/tags/Mysql/"},{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Xml","slug":"Xml","permalink":"https://www.sizaif.com/tags/Xml/"},{"name":"JAXB","slug":"JAXB","permalink":"https://www.sizaif.com/tags/JAXB/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.sizaif.com/tags/IDEA/"},{"name":"Git","slug":"Git","permalink":"https://www.sizaif.com/tags/Git/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"脚本","slug":"脚本","permalink":"https://www.sizaif.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Python","slug":"Python","permalink":"https://www.sizaif.com/tags/Python/"},{"name":"github计划","slug":"github计划","permalink":"https://www.sizaif.com/tags/github%E8%AE%A1%E5%88%92/"},{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}]}