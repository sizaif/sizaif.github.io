{"meta":{"title":"Sizaif's Blog","subtitle":"Sizaif的小领地","description":"春江潮水连海平,海上明月共潮生.","author":"sizaif","url":"https://www.sizaif.com","root":"/"},"pages":[{"title":"","date":"2021-08-16T01:05:20.376Z","updated":"2021-08-15T15:35:26.149Z","comments":true,"path":"google16e673252f94d06c.html","permalink":"https://www.sizaif.com/google16e673252f94d06c","excerpt":"","text":"google-site-verification: google16e673252f94d06c.html"},{"title":"","date":"2021-08-06T16:01:23.000Z","updated":"2021-08-09T08:19:55.000Z","comments":true,"path":"page/friends/index.html","permalink":"https://www.sizaif.com/page/friends/","excerpt":"相聚短暂，孤独常态。","text":"相聚短暂，孤独常态。 &nbsp;举个栗子&nbsp;前置要求 &nbsp;本站信息 友链格式，除高亮行，其余均可选~- title: # 网站名称 url: # 访问地址 avatar: # 头像地址 description: # 描述/一句话概述/格言 screenshot: # 网站截图/展示图 backgroundColor: # 头像背景颜色 textColor: # 文本颜色 keywords: - 标签一 - 标签二 有实质性原创内容的 HTTPS 站点 合法的、非营利性、无商业广告） 访问地址：https://www.sizaif.com/ 站点名称：Sizaif's Blog 头像地址：https://gitee.com/sizaif/images/raw/master/img/20210807132935.jpeg 描述信息：春江潮水连海平,海上明月共潮生"},{"title":"","date":"2021-08-06T15:58:57.000Z","updated":"2021-09-20T01:12:03.202Z","comments":true,"path":"page/about/index.html","permalink":"https://www.sizaif.com/page/about/","excerpt":"","text":"About Me 关于我统计占位自我评价 热爱生活，热爱技术 默默的程序猿，默默的做事 探索，查找，分享 … 说点什么 简单的记录分享科研探索中遇到的问题以及可能的相关解决方法. 分享+1 == 快乐+1 == 收获+1; 闭门造车+1 == 自闭+1 == 快乐-n 联系方式 echo \"c2l6YWlmMjAwMEBnbWFpbC5jb20Kc2l6YWlmMjAwMEAxNjMuY29t\" | base64 -d 春江花月夜 张若虚 春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰； 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年望相似。 不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月裴回，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。"},{"title":"建 站 史","date":"2021-08-07T05:00:34.000Z","updated":"2021-09-20T01:36:46.732Z","comments":true,"path":"page/history/index.html","permalink":"https://www.sizaif.com/page/history/","excerpt":"","text":"2021-09-20 修复每日说说界面 2021-09-19 添加暗黑模式,右键点击切换图片由png切换为webp,增加访问速度 2021-09-17 增加阅读模式简化背景图样式重构 2021-08-16 css优化,博文标题居中标签和归档整合到归档中 2021-08-14 尝试使用CDN加速将首页gitee图床背景图更换到本地,加快加载速度大量使用本地图片 2021-08-14 使用hexo-abbrlink插件,修改文章链接地址唯一 2021-08-13 更换评论系统由 valine 更换为 Waline, 增加图片上传功能 2021-08-10 部分博客从CSDN搬运过来 2021-08-09 图标样式修改 fas-&gt;fad添加友链(小伙伴界面)添加留言板功能添加每日心情(说说)功能添加关于(我) 界面 2021-08-08 配置代码高亮,代码背景块颜色绑定域名到 www.sizaif.com 2021-08-07 第一次建站采用 Volantis5.0.alpha 主题"},{"title":"More","date":"2021-08-06T16:08:12.000Z","updated":"2021-08-07T01:18:25.000Z","comments":true,"path":"page/more/index.html","permalink":"https://www.sizaif.com/page/more/","excerpt":"","text":""},{"title":"","date":"2021-08-07T02:43:15.000Z","updated":"2021-08-09T09:00:36.000Z","comments":true,"path":"page/messages/index.html","permalink":"https://www.sizaif.com/page/messages/","excerpt":"","text":"请遵守相关法律法规，文明灌水，谢谢合作~"},{"title":"","date":"2021-08-07T14:36:59.000Z","updated":"2021-09-20T01:32:03.020Z","comments":true,"path":"page/shuoshuo/index.html","permalink":"https://www.sizaif.com/page/shuoshuo/","excerpt":"","text":""},{"title":"Wiki","date":"2021-08-06T15:47:59.000Z","updated":"2021-08-06T15:47:59.000Z","comments":true,"path":"page/wiki/index.html","permalink":"https://www.sizaif.com/page/wiki/","excerpt":"","text":""},{"title":"笔记","date":"2021-08-06T15:48:11.000Z","updated":"2021-09-27T06:44:23.978Z","comments":true,"path":"page/notes/index.html","permalink":"https://www.sizaif.com/page/notes/","excerpt":"","text":"WIFI&WPA34G&5G LTE状态机学习TLS差异测试IOT 计划 A Chosen Random Value Attack on WPA3 SAE authentication protocol 2019-801 Active Dictionary Attack on WPA3-SAE Cryptanalysis of the Dragonfly key exchange protocol Dragonblood_ Analyzing the DragonflyHandshake of WPA3 and EAP-pwd Model based fuzzing of the WPA3 Dragonfly handshake master thesis On the Provable Security of the Dragonfly Protocol Simultaneous Deauthentication of Equals Attack 2021-09-17 -&gt; 2021-09-24 CSAI: Open-Source Cellular Radio Access Network Security Analysis Instrument srsRAN https://github.com/srsran/srsRAN 2021-09-05 -&gt; 2021-09-24 总结LTE相关攻击;汇总成PPT报告. 2021-08-20 -&gt; 2021-08-31 小组行动小组行动:王 :Breaking LTE on Layer Two杨:Bookworm Game Automatic Discovery of LTE Vulnerabilities Through Documentation An赵 :Touching the Untouchables_ Dynamic Security Analysis of the LTE Control Plane 2021-08-13 -&gt; 2021-08-20 ProChecker-An-Automated-Security-and-Privacy-Analysis-Framework-for-4G-LTE-Protocol-Implementations 2021-08-07 -&gt; 2021-08-13 Emulation-Instrumented Fuzz Testing of 4G_LTE Android Mobile Devices Guided by Reinforcement Learning 2021-08-01 -&gt; 2021-08-06 Berserker ASN.1-based Fuzzing of Radio Resource Control Protocol for 4G and 5G 2021-07-23 -&gt; 2021-07-30 On the Challenges of Automata Reconstruction in LTE Networks 2021-07-11 -&gt; 2021-07-17 ProFuzzBench/AFLnet&amp;AFLnwe AFLNET: A Greybox Fuzzer for Network Protocols American fuzzy lop 2021-05-28 -&gt; 2021-06-11 TLS-Attacker Protocol state fuzzing of TLS implementations Analysis of DTLS Implementations Using Protocol State Fuzzing 2021-05-20 -&gt; 2021-05-27 改进计划第一次尝试 Protocol state fuzzing of TLS implementations Analysis of DTLS Implementations Using Protocol State Fuzzing 47 Systematic Fuzzing and Testing of TLS Libraries 2021-05-17 -&gt; 2021-05-20 IPSec_VPN安全性漏洞分析及验证_周益旻 2021-04-30 -&gt; 2021-05-17 了解TLS&amp;DTLS Protocol state fuzzing of TLS implementations Analysis of DTLS Implementations Using Protocol State Fuzzing 2021-04-23 -&gt; 2021-04-30 初识状态机 45 基于L_学习算法的安全协议自适应模型检测技术研究 基于模型学习的OpenVPN系统脆弱性分析 64 Model Learning and Model Checking of IPSec Implementations for Internet of Things 基于L学习算法的安全协议自适应模型检测技术研究检测 46 A Tale of the OpenSSL State Machine A Large-Scale Black-Box Analysis 51 Model Learning and Model Checking of SSH Implementations 47 Systematic Fuzzing and Testing of TLS Libraries 2021-06-24 -&gt; 2021-07-01 Towards Fuzzing-Based Differential Black-Box Testing of TLS Implementations 2021-09-17 -&gt; 2021-09-24 王: A framework for automating security analysis of the internet of things杨: Automated Analysis of Secure Internet of Things Protocols"},{"title":"所有分类","date":"2021-08-06T15:26:13.000Z","updated":"2021-08-14T16:15:40.775Z","comments":true,"path":"navigation/categories/index.html","permalink":"https://www.sizaif.com/navigation/categories/","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-06T14:20:10.000Z","updated":"2021-08-14T16:15:40.808Z","comments":true,"path":"navigation/tags/index.html","permalink":"https://www.sizaif.com/navigation/tags/","excerpt":"","text":""},{"title":"Clubmanualv1","date":"2021-09-16T03:26:03.000Z","updated":"2021-09-23T11:47:11.288Z","comments":true,"path":"page/clubmanualv1/index.html","permalink":"https://www.sizaif.com/page/clubmanualv1/","excerpt":"","text":"基本镜像说明 [image]:[tag] tag版本号会逐步更新 如果不加版本号的话, 默认使用带有latest的版本( 这里latest并不是最新的意思,而是标记tag为latest 的意思) ubuntu:20.04 V1 使用清华源 已安装基本工具: VIM - Vi IMproved 8.1 (2018 May 18, compiled Apr 15 2020 06:40:31) cmake version 3.16.3 gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) g++ (4:9.3.0-1ubuntu2). wget,git,autoconf,automake,build-essential Python 3.8.10 (default, Jun 2 2021, 10:49:15) pip3 pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) 创建使用此镜像创建容器 # 事例, /home/sizworkhome/ 为要映射的主机文件夹目录 # /home/workhome/ 为容器中要映射的目录 # siztest1 为创建的容器名称 # sizaif2000/ubuntu2004v1:2.0 为远程的镜像名称以及版本 # -p 8080:80 $ docker run -dit -v /home/sizworkhome:/home/workhome --name siztest1 sizaif2000/ubuntu2004v1:2.0 ubuntu:20.04 V2 使用清华源 已安装基本工具: VIM - Vi IMproved 8.1 (2018 May 18, compiled Apr 15 2020 06:40:31) cmake version 3.16.3 gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) g++ (4:9.3.0-1ubuntu2). wget,git,autoconf,automake,build-essential Python 3.8.10 (default, Jun 2 2021, 10:49:15) pip3 pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) new add &gt;&gt; java-jdk1.8.0_291 创建使用此镜像创建容器 # 事例, /home/sizworkhome/ 为要映射的主机文件夹目录 # /home/workhome/ 为容器中要映射的目录 # siztest1 为创建的容器名称 # sizaif2000/ubuntu2004v2:2.0 为远程的镜像名称以及版本 # -p 8080:80 $ docker run -dit -v /home/sizworkhome:/home/workhome --name siztest1 sizaif2000/ubuntu2004v2:2.0 docker 常见基本命令 常用命令 新增说明2.0! 在使用文件夹路径映射后, 需首先进入容器内使用chmod g+wxr /&lt;映射后的文件夹路径&gt; 给组添加权限,否则容器外创建用户会出现没有权限修改映射文件 说明 一: 容器 id 可以由 前三位id 简称代替 e.g: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS f586c498d512 sizaif2000/ubuntu2004v1:1.0 “bash” 14 hours ago Exited (255) 5 minutes ago 则f586c498d512 可以用f58代替, 例如: docker exec -it f58 /bin/bash 二: 带有[xxx] 命令样式的, 输入命令时不需要输入[ ] 查看镜像查看容器创建新的容器启动容器进入容器容器与主机间的数据拷贝删除容器#列出本地images $ docker images #含中间映像层 $ docker images -a#查看正在运行的容器 $ docker ps #查看正在运行+历史运行过的容器 $ docker ps -a #查看正在运行的容器的ID $ docker ps -q #显示运行容器总文件大小 $ docker ps -s新增说明2.0! 在使用文件夹路径映射后, 需首先进入容器内使用chmod g+wxr /&lt;映射后的文件夹路径&gt; 给组添加权限,否则容器外创建用户会出现没有权限修改映射文件 # docker run -dit -p 主机端口:容器中端口 -v 主机中要映射的文件夹绝对目录:容器里映射路径 --name 起个名字 ubuntu:你的镜像tag（默认是latest） # 如果不需要端口映射 就不需要加 -p 参数 # e.g: docker run -dit -v /home/whxiang/workdir:/home/workdir --name whx_test sizaif2000/ubuntu2004v1:1.0 当在进行测试的时候发现一个新的问题: 即组内普通用户创建的文件在容器中因为没有相应的uid:gid 映射, 并且容器中的root用户的权限很低时(组管理员拥有sudo权限,但需要输入sudo才可以; 而容器中时没有sudo命令的,所有说这里的root权限很低)在这种情况下: 就会出现普通用户创建的文件,在容器中被识别为: `nobody ,nogroups 现象 暂时的解决方法 普通用户删除私有组,即让普通用户的主组为(docker容器映射的管理员所在的组)​ 例如: 本文演示小组管理员为siz, 组名为(siz) 则让 普通用户test&lt;xxx&gt; 的主组为siz# 命令: sudo usermod -g &lt;小组管理员名称> &lt;普通用户名称> # 将普通用户的主组从私有组改为小组管理员所在的组 $ sudo usermod -g test1 siz对宿主机(容器外)组成员中普通用户创建的文件或文件夹提升组权限目的: 使容器内root获得对这个文件夹拥有修改(w) 权限 $ chmod g+wxr &lt;xxx>对容器内root 创建的文件或文件夹提升组权限目的: 使宿主机(容器外) 组成员普通用户获得对这个文件夹拥有修改(w) 权限$ chmod g+wxr &lt;xxx>缺陷:当内外创建新的文件和文件夹使, 内外要不断的使用chmod 命令进行授权, $ docker start [container_id]# 常用进入命令 $ docker exec -it [container_id] /bin/bash # 或者使用attach 命令 # 注意!!!! 使用 attach命令时, 须在run创建容器的时候带有 -it 参数, 负责会出现进入容器后无法交互输入命令的情况 $ docker attach [container_id]#将容器中的某个路径下文件copy至主机本地路径 $ docker cp [container_id]:/[container_file_path] [local_path] #将主机文件copy至容器中的某个路径下 $ docker cp [local_file_path] [container_id]:/[container_file_path]/ #将主机文件copy至容器中中的某个路径下，目录重命名为[container_path]（注意与非重命名copy的区别） $ docker cp [local_file_path] [container_id]:/[container_file_path]$ docker rm [container_id] 镜像操作详细 拉取镜像推送镜像删除镜像#下载ubuntu官方最新镜像，相当于：docker pull ubuntu:latest $ docker pull ubuntu #下载仓库所有Redis镜像 $ docker pull -a ubuntu #下载私人仓库镜像 # docker pull dockerUserName/xxxx:tag # e.g: docker pull sizaif2000/ubuntu2004v1:1.0推送前,需要先打包成 dockerUserName/xxx:tag 如果从容器开始推送, 则需要先执行 $ docker commit [container_Id] dockerUserName/xxx:tag 如果从镜像开始推送,则需要执行$ docker tag imageName dockerUserName/xxx[:tag] # 将打包好的镜像推送的dockerhub中 $ docker push dockerUserName/xxx:tag#单个镜像删除，相当于：docker rmi ubuntu:latest $ docker rmi [image_name] #强制删除(针对基于镜像有运行的容器进程) $ docker rmi -f [image_name] #多个镜像删除，不同镜像间以空格间隔 $ docker rmi -f ubuntu tomcat nginx #删除本地全部镜像 $ docker rmi -f $(docker images -q) 容器操作详细 创建新的容器本地目录映射容器端口映射容器进入容器构建镜像删除容器新增说明2.0! 在使用文件夹路径映射后, 需首先进入容器内使用chmod g+wxr /&lt;映射后的文件夹路径&gt; 给组添加权限,否则容器外创建用户会出现没有权限修改映射文件 #新建并启动容器，参数：-i 以交互模式运行容器；-t 为容器重新分配一个伪输入终端; -d 已守护方式启动容器；--name 为容器指定一个名称 # 格式 docker run -dit --name [name] [images]:[tag] $ docker run -dit --name siztest sizaif2000/ubuntu20004v1:1.0 # docker run -dit -p 8080:80 -v /e/windowssrc:容器里映射路径 --name 起个名字 ubuntu:你的镜像tag（默认是latest）顾名思义: 映射本地目录, 即把主机本地目录映射到容器中指定目录中,实现在主机本地修改,在从容器中可同步查看修改 方式: 一般是在创建容器时,设置本地目录映射 创建时映射本地目录 # 格式 -v 主机文件夹目录:容器里映射路径 $ docker run -dit -v /e/windowssrc:/home/workhome --name siztest sizaif2000/ubuntu20004v1:1.0 一问一答 问题一: 如果我已经创建完容器了, 我再想映射本地目录如何实现?答:删掉容器重新创建(如果是刚开始)删除现有的容器重新创建容器查看容器的相信信息对现有容器构建镜像，再从这个镜像重新启动一个新的容器对现有的容器进行保存镜像删除原有的容器通过新镜像,生成新的容器查看新容器的相关配置信息更改现有容器的配置文件修改现有配置需要重启整个docker,会影响到其他正在运行的容器 一问一答 问题三: 我已经创建完容器了并设置了文件夹映射,但我想往这个文件夹里添加文件却提示没有权限怎么回事?答:​ 没有做创建完容器后进入容器,进入到映射后的路径,给这个文件夹赋予组权限(wxr)​ 例如:​ docker run -dit -v /home/siz/test1:/home/siz b19​ 做完映射后, 需执行$ docker attach &lt;新创建容器_id> $ cd /home/siz $ chmod g+wxr ./test1 # 执行完这个过程后, 在容器外的用户才有权限去修改创建文件!!!! 当在进行测试的时候发现一个新的问题: 即组内普通用户创建的文件在容器中因为没有相应的uid:gid 映射, 并且容器中的root用户的权限很低时(组管理员拥有sudo权限,但需要输入sudo才可以; 而容器中时没有sudo命令的,所有说这里的root权限很低)在这种情况下: 就会出现普通用户创建的文件,在容器中被识别为: `nobody ,nogroups 现象 暂时的解决方法 普通用户删除私有组,即让普通用户的主组为(docker容器映射的管理员所在的组)​ 例如: 本文演示小组管理员为siz, 组名为(siz) 则让 普通用户test&lt;xxx&gt; 的主组为siz# 命令: sudo usermod -g &lt;小组管理员名称> &lt;普通用户名称> # 将普通用户的主组从私有组改为小组管理员所在的组 $ sudo usermod -g test1 siz对宿主机(容器外)组成员中普通用户创建的文件或文件夹提升组权限目的: 使容器内root获得对这个文件夹拥有修改(w) 权限 $ chmod g+wxr &lt;xxx>对容器内root 创建的文件或文件夹提升组权限目的: 使宿主机(容器外) 组成员普通用户获得对这个文件夹拥有修改(w) 权限$ chmod g+wxr &lt;xxx>缺陷:当内外创建新的文件和文件夹使, 内外要不断的使用chmod 命令进行授权, 创建时开启端口映射 # 将 容器中的 80端口映射到本地的8080端口 # 格式 -p 8080:80 $ docker run -dit -p 8080:80 --name siztest sizaif2000/ubuntu20004v1:1.0 一问一答 问题二: 如果我已经创建完容器了, 我再想追加端口映射怎么实现?答:删掉容器重新创建(如果是刚开始)删除现有的容器重新创建容器查看容器的相信信息对现有容器构建镜像，再从这个镜像重新启动一个新的容器对现有的容器进行保存镜像删除原有的容器通过新镜像,生成新的容器查看新容器的相关配置信息更改现有容器的配置文件修改现有配置需要重启整个docker,会影响到其他正在运行的容器 #使用run方式在创建时进入 $ docker run -it centos /bin/bash #关闭容器并退出 $ exit #仅退出容器，不关闭 # 快捷键：Ctrl + P + Q #直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false 确保CTRL-D或CTRL-C不会关闭容器 $ docker attach --sig-proxy=false centos #在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i 即使没有附加也保持STDIN 打开；-t 分配一个伪终端 $ docker exec -i -t centos /bin/bash #以交互模式在容器中执行命令，结果返回到当前终端屏幕 $ docker exec -i -t centos ls -l /tmp #以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端 $ docker exec -d centos touch cache.txt # 常用进入命令 $ docker exec -it [container_id] /bin/bash # 或者 使用attach 命令 # 注意!!!! 使用 attach命令时, 须在run创建容器的时候带有 -it 参数, 负责会出现进入容器后无法交互输入命令的情况 $ docker attach [container_id]# 注：containerId为需要打包的容器id， # imagename 为 打包的镜像名称;可添加tag参数, 例如 testv1:1.0 $ docker commit [container_Id] imagename#停止一个运行中的容器 $ docker stop redis #杀掉一个运行中的容器 $ docker kill redis #删除一个已停止的容器 $ docker rm redis #删除一个运行中的容器 $ docker rm -f redis #删除多个容器 $ docker rm -f $(docker ps -a -q) $ docker ps -a -q | xargs docker rm # -l 移除容器间的网络连接，连接名为 db $ docker rm -l db # -v 删除容器，并删除容器挂载的数据卷 $ docker rm -v redis 修订历史 2021-09-23 修复映射文件夹路径权限问题 修复日志 2021-09-17 构建基础镜像ubuntu2004v2:2.0版本构建基础镜像ubuntu2004v1:2.0版本添加基础镜像latest版本增加启动镜像 2021-09-16 添加第一版手册"}],"posts":[{"title":"使用Wireshark抓包LTE RRC","slug":"使用Wireshark抓包LTE-RRC","date":"2021-10-07T08:18:15.000Z","updated":"2021-10-07T08:47:02.202Z","comments":true,"path":"posts/172b8d62/","link":"","permalink":"https://www.sizaif.com/posts/172b8d62/","excerpt":"","text":"[TOC] 使用Wireshark抓包LTE RRC 包 实验环境说明 一台ubuntu20.04虚拟机 Wireshark 基于srsRAN 模拟LTE环境 使用ZeroMQ RF 实现无RF硬件构建srsUE与srsENB 通信 With srsRAN this can be achieved by replacing the radio link between eNodeB and UE with a mechanism that allows to exchange baseband IQ samples over an alternative transport. For this purpose, we’ve implemented a ZeroMQ-based RF driver that essentially acts as a transmit and receive pipe for exchanging IQ samples over TCP or IPC. Wireshark配置 在srsran doc 文档中由提到wireshark 抓取用法 Examining PCAPs with Wireshark 打开DLT_User选项 添加配置 保存后即可开始抓取, 按照原文的意思设置此项后就可以抓取到LTE消息. 但在使用ZeroMQ 实现免RF中并没有出现上述的情况, 因为ZeroMQ的流量都是通过localhost:2000 和 localhost:2001 端口 实现流量交换 既然如此,尝试添加解析选项 分析-&gt; 解码为, 添加对应端口, 以及要解析成的协议,保存即可 srsRAN配置 在~/.config/srsran/ 目录下, 修改epc.conf, enb.conf,ue.conf 文件 在对应的pcap 选项下, 设置 enable = true 当运行完成后,即可以用wireshark 打开 /tmp/目录下对应的pcap文件, 设置对应解析查看","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://www.sizaif.com/tags/Wireshark/"}],"author":"sizaif"},{"title":"提取3GPP TS中RRC ASN.1模式及编译","slug":"提取3GPP-TS中RRC-ASN-1模式及编译","date":"2021-10-05T03:30:26.000Z","updated":"2021-10-06T08:53:56.600Z","comments":true,"path":"posts/b0e1c2b9/","link":"","permalink":"https://www.sizaif.com/posts/b0e1c2b9/","excerpt":"","text":"整体流程图 ASN.1 标准简介 在电信和计算机网络领域，ASN.1（Abstract Syntax Notation One) 是一套标准，是描述数据、编码、传输、解码的灵活的抽象语义记法。它提供了一套正式、无歧义和精确的规则以描述独立于特定计算机硬件的对象结构。 3GPP协议 5G NR 的无线资源控制(RRC)协议是 38.331 38.331https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3197 LTE 的无线资源控制(RRC)协议是 36.331 36.331https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=2440 提取RRC,ASN1样式 转换工具下载 将下载后的3GPP协议Word 文档去掉页眉页脚后转换成纯文本txt, 编码选择UTF-8 使用txt2asn1 转换 txt2asn1https://github.com/Dybinx/txt2asn1 请下载ZIP格式并解压,避免出现exe权限无法运行问题 在同目录下终端运行 得到xxx.asn1文件 ./txt2asn1.exe XXX.txt 使用extract_asn1_from_spec.pl extract_asn1_from_spechttps://gitlab.eurecom.fr/oai/openairinterface5g/-/blob/master/openair2/RRC/LTE/MESSAGES/asn1c/ASN1_files/extract_asn1_from_spec.pl 下载文件后, 源文件同目录终端运行 perl extract_asn1_from_spec xxxx.txt 得到 EUTRA-RRC-Definitions.asn, EUTRA-UE-Variables.asn ,EUTRA-InterNodeDefinitions 三个文件 ASN1C编译ASN.1文件 ASN1C 是将 ASN.1 规范转换为 C 源代码的免费开源编译器。 它支持一系列 ASN.1 语法，包括 ISO/IEC/ITU ASN.1 1988、'94、'97、2002 和以后的修正。 支持的编码规则集是 BER: ITU-T Rec. X.690 | ISO/IEC 8825-1 (2002) (BER/DER/CER) PER: X.691|8825-2 (2002) (PER). XER: X.693|8825-3 (2001) (BASIC-XER/CXER). asn1c官网http://www.lionet.info/asn1c/ asn1c源码https://github.com/vlm/asn1c ubuntu 可直接通过 sudo apt-get install asn1c 进行安装 sudo apt update sudo apt install asn1c 使用asn1c 编译 asn1c -S /usr/share/asn1c -fcompound-names -gen-PER -pdu=auto 36331-f40.asn1 # -pdu=auto 产生pdu_colletion.c文件 # -fcompound-names 去除重定义 # -gen-PER 使用PER编码 # -S /usr/share/asn1c 指定asn1c库文件位置, 通过使用whereis asn1c命令查看其库位置 FAQ Q.: Does asn1c support BER encoding? I see only DER encoding in documentation.A.: Yes, the asn1c compiler fully supports BER encoding. Any DER encoded data is, by definition, a valid BER data, from the receiver’s point of view.If you want data to be BER or DER encoded, just invoke der_encode().Q.: My linker complains: Undefined symbols: _asn_DEF_PDU.A.: If you have your own file with main() routine, just delete the converter-sample.cfile, you won’t need it. If you haven’t created the main() routine yourself and wish to rely on converter-sample.c for your transcoding needs, add -DPDU=YourPdu to the list of compiler flags.Q.: How to compile the 3GPP Radio Resource Control specification?A.: The asn1c distribution includes an RRC 25.331 (version 7.1.0) example, check out https://github.com/vlm/asn1c/tree/master/examples/sample.source.RRC. You can also use the pre-compiled rrc-dump.exe program, which is part of Windows ASN.1 compiler installer.Q.: How to compile the ISO 13522 (MHEG-5) specification?A.: The ASN.1 compiler comes with a MHEG-5 decoder. Follow the https://github.com/vlm/asn1c/tree/master/examples/sample.source.MHEG5 README file instructions. You can also use the pre-compiled mheg5dump.exe program, which is part of Windows ASN.1 compiler installer.Q.: How to compile the XYZ decoder?A.: If XYZ is one of MEGACO (Media Gateway Control), PKIX1/X.509, LDAP, GSM TAP3 or OAM ULP, just go to examples/sample.source.XYZ and run make. The Windows ASN.1 compiler installer already contains the pre-compiled decoders for these encoding formats.If you have something else, you should either use the Online ASN.1 compiler, or download the ASN.1 compiler source code. 如果不使用自己的main()函数, 直接使用converter-sample.c的化, 需要在其中添加一个目标PDU #include &lt;asn_application.h&gt; #include &lt;asn_internal.h&gt; &#x2F;* for ASN__DEFAULT_STACK_MAX *&#x2F; #define PDU BCCH_BCH_Message &#x2F;* Convert &quot;Type&quot; defined by -DPDU into &quot;asn_DEF_Type&quot; *&#x2F; #define ASN_DEF_PDU(t) asn_DEF_ ## t #define DEF_PDU_Type(t) ASN_DEF_PDU(t) #define PDU_Type DEF_PDU_Type(PDU) 或者在Makefile.am.sample 文件中, 修改 CFLAGS 添加 -DPDU= 选项 CFLAGS += -DHAVE_CONFIG_H -DJUNKTEST -D_DEFAULT_SOURCE -DPDU=BCCH_BCH_Message -DASN_PDU_COLLECTION -I. OBJS=$&#123;ASN_MODULE_SRCS:.c=.o&#125; $&#123;ASN_CONVERTER_SOURCES:.c=.o&#125; all: $(TARGET) $(TARGET): $&#123;OBJS&#125; $(CC) $(CFLAGS) -o $(TARGET) $&#123;OBJS&#125; $(LDFLAGS) $(LIBS)","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"ASN.1","slug":"ASN-1","permalink":"https://www.sizaif.com/tags/ASN-1/"}],"author":"sizaif"},{"title":"LTE 基础知识","slug":"LTE-基础知识","date":"2021-10-04T03:06:13.000Z","updated":"2021-10-05T04:01:22.800Z","comments":true,"path":"posts/cdac3e0/","link":"","permalink":"https://www.sizaif.com/posts/cdac3e0/","excerpt":"","text":"LTE相关基础知识 LTE架构 第一层物理层(PHY),在时间和频率域使用无线电资源进行通信。 第二层由介质访问控制(MAC)、无线链路控制(RLC)、分组数据收敛协议(PDCP)三层组成。它们支持上行和下行调度、分组分割、加密和完整性保护等功能。 RRC是一个第三层协议，负责创建和维护无线电连接、广播系统信息、发送分页通知、配置和报告无线电测量以及隧道化NAS消息。 NAS是终端与CN之间的控制平面协议;它负责设置安全性，处理移动性和会话管理。 UE代表手机; RAN为终端提供无线通信服务; CN(EPC)(包括其他功能)在终端和Internet之间路由数据。 RAN由无线基站组成，在5G中称为gNB，在4G中称为eNB。gNB所使用的无线电接入技术被称为新无线电(NR)， eNB所使用的无线电接入技术被称为进化通用地面无线电接入(E-UTRA)。 CN由几个网络功能组成，其中5G的接入和移动性管理功能(AMF)和4G的移动性管理实体(MME)如图所示。UE到RAN/CN的方向称为上行，另一个方向称为下行。 4G和5G的流量有两种类型: 一种称为控制平面的类型负责建立和维护连接，并建立安全性; 用户平面: 承载实际数据，如语音通话和互联网数据。每种类型都由几个协议组成。 控制平面上使用的协议栈的空中接口,包括无线电资源控制协议(RRC)和不可访问层协议(NAS)， RRC(Radio Resource Control) 无线资源控制 RRC是一个第三层协议，负责创建和维护无线电连接、广播系统信息、发送分页通知、配置和报告无线电测量以及隧道化NAS消息。 在NG-RAN中，RRC在UE和gNB之间的控制平面消息中进行操作。它携带了与RAN控制平面程序相关的信息 RRC层还为终端和核心网接入移动性管理功能(Access and Mobility Management Function, AMF)之间发送的NAS消息提供服务。 RRC中的消息依赖于PDCP,在必要时提供一个具有加密和完整性保护的通道。 RRC负责广播系统信息或获取系统信息以便在小区内进行通信，用于在RRC_IDLE状态下发送寻呼消息、连接管理、移动性管理等。 RRC三种状态转换 5G NR中 引入了额外的状态RRC_INACTIVE RRC_IDLE: 网络不包含终端RRC连接信息的状态。因此，设备不能发送或接收数据。设备定期醒来，接收来自网络的寻呼消息，将状态更改为RRC_CONNECTED。小区和网络之间的移动性可以通过小区重新选择过程实现 RRC_INACTIVE: 无法发送或接收数据。 在UE和gNB中都维护RRC上下文。UE可以类似于RRC_IDLE模式休眠，以节省电池电量。减少到RRC_CONNECTED模式的转换时间,用于数据传输，因为已经在核心网络建立了上下文。 通过小区重选程序的移动性 RRC_CONNECTED: 在UE和gNB之间建立RRC上下文，用于在网络上传输数据。通过小区无线网络临时标识符(C-RNTI)用于信令的网络识别设备。由RAN管理的移动性，在需要时进行切换 新的状态RRC_INACTIVE有助于减少发送用户数据之前的状态转换所涉及的信令量。 RRC_INACTIVE充当了一个中介状态，用于在RRC上下文已经建立时直接转换。在RRC_INACTIVE状态下，设备会像RRC_IDLE一样休眠。 RRC层负责控制平面过程中的大量消息，对于任何RRC层的实现来说，健壮地抵御恶意攻击并向上层提供可靠的服务都是非常重要的。 RRC组成 RC消息是使用平台无关的ASN.1定义的，可以看作图2中的树。每个RRC消息由结构化的(SEQUENCE, SEQUENCE OF, CHOICE) 和原语(BOOLEAN,INTEGER, ENUMERATED,BIT STRING,OCTET STRING) 数据类型, 每个结构化数据类型可以进一步由结构化数据类型和基本数据类型组成. 在传输过程中，RRC消息使用Unaligned Packed Encoding Rules (UPER)[36]进行编码，该规则将数据结构转换为紧凑的字节序列。 [36] ITU. Recommendation ITU-T X.691 International Standard 8825-2: Information technology – ASN.1 encoding rules: Specification of Packed Encoding Rules (PER), Aug 2015. Available at https://www.itu.int/rec/T-REC-X.680-X.693-201508-I/en. RRC 消息 RRC层利用底层的服务实现RRC消息的可靠、安全的传递。上行通道为ULCCCH、UL-DCCH，下行通道为DL-CCCH、DL-DCCH、BCCH、PCCH。 CCCH、PCCH和BCCH通道中的消息通过RLC中的透明模式™以明文形式发送，用于初始AS激活和随机访问过程。因此这些消息不使用PDCP层的服务进行加密和完整性保护。RLC仍然提供检测到错误的重传和RRC有效负载的无重复交付。在上行链路中，RRC报文只通过UL-CCCH和UL-DCCH发送。 5G NR 5G New Radio Fuzzing Radio Resource Control messages in 5G and LTE systems 5G系统提出新的无线电标准, 5G New Radio; 新标准应该支持为将来使用而确定的需求，如更高的数据速度、更低的延迟、移动性和可靠性。5G NR是在RAN和UE之间使用经过许可的电磁频谱传输数据的接入机制。5G系统中的NG-RAN可以由多个下一代节点基站(gNB)或单个gNB组成。NG-RAN将为LTE、3G等传统无线接入技术提供支持。RAN为终端提供了与核心网络和数据网络交互的接口。5G NR由处理控制平面的网络协议栈和处理用户平面消息的网络协议栈组成，分别如下所示 UE和NG-RAN之间的接口叫做Uu，它同时承载着控制平面和用户平面的流量。 缩写名词解释","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"标签二","slug":"标签二","permalink":"https://www.sizaif.com/tags/%E6%A0%87%E7%AD%BE%E4%BA%8C/"}],"author":"sizaif"},{"title":"Docker文件夹映射权限问题思考及可能解决方法","slug":"docker文件夹映射权限问题思考及可能解决方法","date":"2021-09-23T02:19:50.000Z","updated":"2021-09-23T11:41:29.560Z","comments":true,"path":"posts/39ff9093/","link":"","permalink":"https://www.sizaif.com/posts/39ff9093/","excerpt":"","text":"docker文件夹映射权限问题思考及可能解决方法 背景分析 在多用户服务器上公用docker搭建环境时,初步设想为宿主机用户为普通用户,容器内用户为root, 用户在容器内自由搭建自己所需的环境,而不影响其他人以及容器外的环境. 但当用户在使用docker挂载磁盘的时候,由于容器内使用root运行程序，会导致挂载中产生的文件属于root:root。而容器外用户并不是root，会使的文件共享甚至阅读日志产生权限上的问题,导致不可读或不可写之类的问题。 本文旨在宿主机使用普通用户,而容器内仍然使用root用户,且不会产生文件权限的问题. 案例截图: 可以看到创建映射的 srs和srsRAN 文件夹 因为是由docker run 命令自动创建的,权限被化为root 普通用户在这个文件夹下没有权限!, 需求 容器外使用普通用户(没有sudo权限等管理员权限) 容器内使用带管理员权限的root用户 文件挂载原理 简而言之，docker的文件挂载中，容器内外uid与gid相同。 最简单的挂载磁盘，例如：docker run -v $PWD:/data bash，就是将当前目录挂载到容器内的/data目录。文件的权限可以通过ls -l查看。 容器内可能有使用root用户和非root用户运行程序的两种情况。 若容器内使用root运行程序，可以想象，产生的文件属于0:0，也就是root:root。容器外文件也会属于0:0，同样是root:root。这样产生的文件就需要容器外的root权限才可以操作。 若容器内使用非root运行程序，例如demo:x:1000:1000::/home/blog:/bin/bash，产生的文件属于1000:1000。容器外文件也会属于1000:1000，而容器外uid为1000的用户可能是test，这是若碰巧你就是test，你就可以顺利读取这个文件。但若你是uid为1001的test2，而且t是个test2讨厌鬼，你就告别这个文件了。甚至容器外根本没有uid为1000的用户，那这个文件就不属于任何人。 docker用户组 docker用户组的出现,目的在于当普通用户既无sudo权限,有想运行docker命令时出现. 一般来说,在linux环境下安装完成docker,系统会自动创建id=999的docker组 . 此时只需要将普通用户加入到docker组中即可. 具体 docker组的id, 请自行查看 方式有两种(需要在拥有sudo权限的账号下修改): 使用usermod命令 $ sudo usermod -aG docker &lt;用户名> # e.g sudo usermod -aG docker test1 直接修改 /etc/group 中 docker 所在组 $ sudo vim /etc/group # 在docker所在行,按格式在后面添加用户名即可 修改完成后,重启ssh或重新登即可, 使用id &lt;用户名&gt; 检查是否在docker所在组 三种可能解决方法 1. 限定开启用户 即运行 docker run -u &lt;xxx&gt;:&lt;xxx&gt; 但这个方法无法解决上述的需求 2.使用子用户 若容器内外文件的uid:gid可以不同，这个问题就可以很容易解决。的确有这么一个方案，让容器内所有的uid:gid以一定的规则映射，我推荐使用这一方案。文章的方案演示节中我会演示这一方案。 在官方文档中，这个方案本身是为了解决安全问题，见这里。发生容器挂载磁盘root权限提权也不是一次两次了，这算是一个官方的解决方案。 https://docs.docker.com/engine/security/userns-remap/ 但这个方案会有一些限制： 不可使用--pid=host 或 --network=host 不可使用无法识别或使用用户映射的挂载磁盘 若使用docker run --privileged则必须同时使用--userns=host 都是不大的限制，使用的时候留个心眼即可。 解释: 因为docker 权限映射的原理是, 容器内外uid与gid相同, 那么我是否可以 通过 userns-remap 命令实现, 将容器内的root 映射到容器外宿主机上一个具有管理员(sudo)的用户(称为siz)上呢,而其他普通用户(test&lt;xxx&gt;)只需要在这个siz所在的组即可. 而这个组的小组管理员即为siz. 但此时一个新的问题出现了: 当普通用户创建文件夹映射时, 此文件夹的所属者为siz,但小组权限仅为xr 即所在组的成员没有修改的权限,只有读和运行的权限, 并且此时普通用户(test&lt;xxx&gt; 并没有sudo权限,也就无法通过chmod g+w 等命令来实现提权. 此时该如何解决呢? 答: 通过进入容器内提权实现, ​ 因为容器内的用户为root,即对应的权限为小组管理员siz, 而小组管理员拥有(sudo) 权限, 又因为文件映射是容器内外相同的, 在容器内修改了文件权限, 那么在容器外普通用户就有了读写执行的权限. 操作实现 修改/etc/subuid 与 /etc/subgid 查看小组的管理员id $ id siz uid=1000(siz) gid=1000(siz) groups=1000(siz) # 得到 siz的id 为 1000 使用带sudo的权限账号修改 /etc/subuid 与 /etc/subgid 文件 格式为: &lt;name>:start:number 对应方式: 如果组管理员id 为1000 , 则对应容器内的root 为1 , 即&lt;name&gt;:1000:1 如果组管理员id为 1003 ,则对应容器内的root 为 1+(1003-1000)=4 即 &lt;name&gt;:1003:4 根据组管理员id 对应设置好映射 例如本文组管理员siz 的 id 为1000 , 则修改为如下样式, 并保存修改 # sudo vim /etc/subuid siz:1000:1 siz:100000:65536 test1:165536:65536 test2:231072:65536 demo:296608:65536 # sudo vim /etc/subgid siz:1000:1 siz:100000:65536 test1:165536:65536 test2:231072:65536 demo:296608:65536 修改docker 守护程序 /etc/docker/daemon.json 注意修改 /etc/docker/daemon.json 文件后, 会导致之前的 镜像与容器不被识别, 所以请做好备份. 容器-&gt;打包成镜像-&gt; 推送到hub Enabling userns-remap effectively masks existing image and container layers, as well as other Docker objects within /var/lib/docker/. This is because Docker needs to adjust the ownership of these resources and actually stores them in a subdirectory within /var/lib/docker/. It is best to enable this feature on a new Docker installation rather than an existing one. # 没有这个文件的化, 请创建 # sudo vim /etc/docker/daemon.json &#123; \"userns-remap\":\"&lt;组管理员名称>\" &#125; # sudo service docker restart # 查看docker 状态 sudo systemctl status docker.service 这里 `“userns-remap”:&quot;&lt;组管理员名称&gt;&quot;的格式 参考官方文档 https://docs.docker.com/engine/security/userns-remap/ Edit /etc/docker/daemon.json. Assuming the file was previously empty, the following entry enables userns-remap using user and group called testuser. You can address the user and group by ID or name. You only need to specify the group name or ID if it is different from the user name or ID. If you provide both the user and group name or ID, separate them by a colon (:) character. The following formats all work for the value, assuming the UID and GID of testuser are 1001: testuser testuser:testuser 1001 1001:1001 testuser:1001 1001:testuser 修改普通用户的组 当在进行测试的时候发现一个新的问题: 即组内普通用户创建的文件在容器中因为没有相应的`uid:gid` 映射, 并且容器中的`root`用户的权限很低时(组管理员拥有sudo权限,但需要输入sudo才可以; 而容器中时没有sudo命令的,所有说这里的`root`权限很低)在这种情况下: 就会出现普通用户创建的文件,在容器中被识别为: `nobody ,nogroups 现象 暂时的解决方法 普通用户删除私有组,即让普通用户的主组为(docker容器映射的管理员所在的组)​ 例如: 本文演示小组管理员为siz, 组名为(siz) 则让 普通用户test&lt;xxx&gt; 的主组为siz# 命令: sudo usermod -g &lt;小组管理员名称> &lt;普通用户名称> # 将普通用户的主组从私有组改为小组管理员所在的组 $ sudo usermod -g test1 siz对宿主机(容器外)组成员中普通用户创建的文件或文件夹提升组权限目的: 使容器内root获得对这个文件夹拥有修改(w) 权限$ chmod g+wxr &lt;xxx>对容器内root 创建的文件或文件夹提升组权限目的: 使宿主机(容器外) 组成员普通用户获得对这个文件夹拥有修改(w) 权限$ chmod g+wxr &lt;xxx>缺陷:当内外创建新的文件和文件夹使, 内外要不断的使用chmod 命令进行授权, 演示: 组成员 组管理员(siz) 进行映射测试: 组成员test1 进行映射测试 使用entrypoint.sh 定制脚本 这个过程是在编写Dockerfile文件时使用的, 目的是让容器内外对应的用户相等来解决文件夹映射目录权限的问题. 主要的思路是,从主机中读取当前用户的id, 然后再创建容器时相应的在容器内部新建一个对应的用户, 这样保证了容器内外的uid:gid 相等. 但在这个里不符合我们的需求, 故不讨论. 总结 为了解决让宿主机使用普通用户来使用docker,而在容器中相对给与较高的root 权限用户需求. 本文采用了修改docker守护程序的方法,其官方文件本意是docker为了解决容器内root升权的问题 所谓升权, 即不做任何修改情况下, 容器内root 与宿主机root相对应, 虽然这个容器内的权限是有一定限制的root 权限, 但可以通过映射宿主机根目录,将所有内容映射到容器中, 实现在容器中获得所有文件的权限,来实现恶意攻击. 通过映射用户, 容器中的root 权限与宿主机被映射的用户权限相等, 可以思考这样一个问题: 如果我映射的宿主机用户是一个普通用户(没有sudo)权限,那么容器里的root 有没有sudo权限呢? 答案 答案是没有的, 可以尝试一下. 容器的的root 仅仅是个名称, 它可以叫做superhero 也可以叫做 tom , 只是个名字,并无所谓,真正相关的是uid:gid","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"实验室服务器用户分级管理+Docker多环境运行设想","slug":"实验室服务器用户分级管理-docker多环境运行设想","date":"2021-09-10T14:39:54.000Z","updated":"2021-09-20T00:45:22.574Z","comments":true,"path":"posts/55127002/","link":"","permalink":"https://www.sizaif.com/posts/55127002/","excerpt":"","text":"[TOC] 用户分级管理 初步设想: root 用户为超级管理员, 管理员-A 拥有管理权限,负责维护. 普通群组无超级管理员权限, 但拥有对docker镜像容器的创建修改删减启动等权限. 普通用户从dockerhub中拉取镜像,创建容器环境 跳转 docker使用手册v1 步骤 安装Docker 查看版本 $ cat /proc/version $ uname -a $ lsb_release -a $ cat /etc/issue 对症下药 ubuntu 参考文档 https://docs.docker.com/engine/install/ubuntu/ 使用远程仓库安装 Install using the repository Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository. Update the apt package index and install packages to allow apt to use a repository over HTTPS $ sudo apt-get update # 必要软件 $ sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release Add Docker’s official GPG key: $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg Use the following command to set up the stable repository. To add the nightly or test repository, add the word nightly or test (or both) after the word stable in the commands below. Learn about nightly and test channels. ​ Note: The lsb_release -cs sub-command below returns the name of your Ubuntu distribution, such as xenial. Sometimes, in a distribution like Linux Mint, you might need to change $(lsb_release -cs) to your parent Ubuntu distribution. For example, if you are using Linux Mint Tessa, you could use bionic. Docker does not offer any guarantees on untested and unsupported Ubuntu distributions. x86_64 / amd64armhfarm64s390x$ echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null$ echo \\ \"deb [arch=armhf signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null$ echo \\ \"deb [arch=arm64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null$ echo \\ \"deb [arch=s390x signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null Install Docker Engine Update the apt package index, and install the latest version of Docker Engine and containerd, or go to the next step to install a specific version: $ sudo apt-get update $ sudo apt-get install docker-ce docker-ce-cli containerd.io Got multiple Docker repositories? If you have multiple Docker repositories enabled, installing or updating without specifying a version in the apt-get install or apt-get update command always installs the highest possible version, which may not be appropriate for your stability needs. Upgrade Docker Engine To upgrade Docker Engine, first run sudo apt-get update, then follow the installation instructions, choosing the new version you want to install. 添加测试用户 $ sudo adduser test1 Adding user `test1' ... Adding new group `test1' (1001) ... Adding new user `test1' (1001) with group `test1' ... Creating home directory `/home/test1' ... Copying files from `/etc/skel' ... New password: Retype new password: passwd: password updated successfully Changing the user information for test1 Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] y $ sudo adduser test2 Adding user `test2' ... Adding new group `test2' (1002) ... Adding new user `test2' (1002) with group `test2' ... Creating home directory `/home/test2' ... Copying files from `/etc/skel' ... New password: Retype new password: passwd: password updated successfully Changing the user information for test2 Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] y siz@ubuntu:/etc/apt$ 查看test1,test2 用户 $ id test1 # uid=1001(test1) gid=1001(test1) groups=1001(test1) $ id test2 # uid=1002(test2) gid=1002(test2) groups=1002(test2) # 可以发现 test1 test2 没有sudo 等权限,为 普通用户 授予docker权限 将test1,test2 普通用户 添加到docker组中 $ sudo usermod -aG docker test1 $ sudo usermod -aG docker test2 重新登陆ssh 或者 log out 在登陆后, 查看 用户标识 $ id test1 # uid=1001(test1) gid=1001(test1) groups=1001(test1),,998(docker) # 可以发现多了docker的 组标识 # 此时运行docker info 测试 $ docker info Client: Context: default Debug Mode: false Plugins: app: Docker App (Docker Inc., v0.9.1-beta3) buildx: Build with BuildKit (Docker Inc., v0.6.1-docker) scan: Docker Scan (Docker Inc., v0.8.0) 拉取 docker images 测试test1拉去docker镜像 $ docker pull sizaif2000/ubuntu2004v1:1.0 ubuntu:20.04 V1 使用清华源 已安装基本工具: VIM - Vi IMproved 8.1 (2018 May 18, compiled Apr 15 2020 06:40:31) cmake version 3.16.3 gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) g++ (4:9.3.0-1ubuntu2). wget,git,autoconf,automake,build-essential Python 3.8.10 (default, Jun 2 2021, 10:49:15) pip3 pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) ubuntu:20.04 V2 使用清华源 已安装基本工具: VIM - Vi IMproved 8.1 (2018 May 18, compiled Apr 15 2020 06:40:31) cmake version 3.16.3 gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) g++ (4:9.3.0-1ubuntu2). wget,git,autoconf,automake,build-essential Python 3.8.10 (default, Jun 2 2021, 10:49:15) pip3 pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) ==java-jdk1.8.0_291== 参考知识 添加/移除 sudo 权限 给某个用户添加 sudo 权限 $ sudo adduser XXXX sudo 移除某个用户sudo权限 $ sudo deluser xxxx sudo ==注意!!!== 移除sudo时, 管理用不要把唯一的管理员的sudo权限移除掉, 否则需要 root 用户重新添加 ubuntu用户组 用户和用户标识号 用户 我们登录到Linux系统，使用的登录名和密码实际上就是用户的信息标识。用户拥有账号、登录名、真实姓名、密码、主目录、默认shell等属性。每个用户实际上代表了一组权限，而这些权限分别表示可以执行不同的操作，是能够获取系统资源的权限的集合。 用户标识号 Linux实际上并不直接认识用户的账号，而是查看用户标识号。 用户标识号（整数）： 0： root，超级用户。 1-499：系统用户，保证系统服务正常运行，一般不使用。 500-60000：普通用户，可登录系统，拥有一定的权限。管理员添加的用户在此范围内。 用户名和标识号不一定一一对应，Linux允许几个登录名对应同一个用户标识号。 系统内部管理进程和文件访问权限时使用用户标识号。 账号和标识号的对应关系在/etc/passwd文件中。 /etc/passwd文件 该文件所有者和所属组为root，除了root用户外只有读取的权限。 格式：登录名：口令：用户标识号：组标识号：注释：用户主目录：Shell程序 登录名：同意系统中唯一，大小敏感。 口令：密码，root和用户可使用passwd命令修改。 用户标识号：唯一。 组标识号：每个用户可以同时属于多个组。 注释：相关信息，真实姓名、联系电话等。mail和finger等会使用这些信息。 用户主目录：用户登录后的默认工作目录。root为/root，一般用户在/home下。 Shell程序：登录后默认启动的Shell程序。 /etc/shadow文件 包含用户的密码和过期时间，只有root组可读写。 格式：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：密码禁用期：账户失效时间：保留字段 登录名：略。 加密口令：*表示账户被锁定，！表示密码被锁定。其他的前三位表示加密方式。 最后一次修改时间：最近修改密码的时间，天为单位，1970年1月1日算起。 最小时间间隔：最小修改密码的时间间隔。 最大时间间隔：最长密码有效期，到期要求修改密码。 警告时间：密码过期后多久发出警告。 密码禁用期：密码过期后仍然接受的最长期限。 账号失效时间：账户的有效期，1970年1月1日算起，空串表示永不过期。 保留字段：保留将来使用。 用户组和组标识号 用户组 用户组指，一组权限和功能相类似的用户的集合。 Linux本身预定义了许多用户组，包括root、daemon、bin、sys等，用户可根据需要自行添加用户组。 用户组拥有组名、组标识号、组成员等属性。 用户组编号 Linux内部通过组标识号来标识用户组。 用户组信息保存在 /etc/group 中。 /etc/group文件 格式：组名：口令：组标识符：成员列表 /etc/passwd文件指定的用户组在/etc/group中不存在则无法登录。 用户管理 添加用户 useradd命令 $ useradd [option] 登录名 # option参数自行查阅。 # 一般加-m创建目录。 adduser命令 $ adduser [option] user 如果没有指定–system和–group选项，则创建普通用户。 否则创建系统用户或用户组。 修改用户信息：usermod $ usermod [option] 用户名 # 具体选项信息自行查阅。 删除用户：userdel $ userdel [option] 用户名 # -f：强制删除（谨慎使用） # -r：主目录中的文件一并删除。 修改用户密码：passwd $ passwd [option] 登录名 显示用户信息 $ id [option] [用户] 用户间切换：su命令 $ su [option] [用户名] # 用户名为 - ，则切换到root用户。 受限的特权：sudo命令 sudo使得用户可以在自己的环境下，执行需要root权限的命令。 该信息保存在/etc/sudoers中。 用户组管理 添加用户组 addgroup命令 类似adduser groupadd 类似useradd 修改用户组 类似usermod，使用groupmod。 删除用户组 类似userdel，使用groupdel。 权限管理 权限组 一般创建文件的人为所有者，其所属的主组为所属组，其他用户为其他组。 基本权限类型 三种：读、写、执行。 权限及其表示值： 读：r或4 写：w或2 执行：x或1 特殊权限 setuid、setgid和黏滞位。 setuid和setgid能以文件所有者或所属组的身份运行。 黏滞位使得只有文件的所有者才可以重命名和删除文件。 访问控制列表 访问控制表ACL可以针对某个用户或者用户组单独设置访问权限。 改变文件所有者chown命令 $ chown [option]...[owner][:[group]] file... 改变文件所属组chgrp命令 用户不受文件的文件主或超级用户不能修改组。 设置权限掩码umask命令 文件的权限为666-掩码 目录的权限为777-掩码 修改文件访问权限 $ chmod [option]...mode[,mode]...file... “+”：增加权限 “-”：减少权限 “=”：设置权限 修改文件ACL：setfacl命令 $ setfacl [option] file... 查询文件的ACL $ getfacl [文件名]","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"TSW-2 列车操作手册合集","slug":"TSW-2-列车操作手册合集","date":"2021-08-29T03:27:02.000Z","updated":"2021-09-19T07:24:21.354Z","comments":true,"path":"posts/238e4ec1/","link":"","permalink":"https://www.sizaif.com/posts/238e4ec1/","excerpt":"","text":"F40PH-3C型号操作手册 the F40PH-3C is a locomotive used on the MBTA Commuter Rail. It is featured in Boston Sprinter. 快速启动 主电池打开 无线电保险丝打开 按住引擎启动开关4s 按住列车供电引擎启动4s 交流电按钮 打开 列车电力设置为 “长机罩拖车” 隔离开关设置为运行 断流阀设置为&quot;切入&quot; MU-2A阀门设置为 “导联或断开” 引擎运行设置为打开 电机磁场设置为打开 控制与燃料泵设置为打开 电空制动设置为打开 设置主钥匙插入 此时状态为: 打开车门迎客U 反向器设置为: 前牵位 ( 此时阀门要设置空挡) 设置列车单独制动为 &quot; 缓解&quot; 增加阀门上调动力 前进 列车启动 done CTC-3 型号操作手册 快速启动 发电机磁场设置为打开 引擎运行设置为打开 电空制动控制设置为打开 反向器设置为空挡 断流阀设置为客运 打开车门上客 反向器设置为: 前牵位 ( 此时阀门要设置空挡) 制动设置为缓解 增加阀门上调动力 列车启动done 德铁 403&quot;ICE3&quot;机型手册 快速启动 节流阀启动增加动力 423 机型手册 快速启动 插入反向器钥匙 反向器设置为前牵引 开启车门 施加动力开启火车 ( 主控器向前施加百分比动力/ 向后设置制动减速)","categories":[{"name":"游戏向","slug":"游戏向","permalink":"https://www.sizaif.com/navigation/categories/%E6%B8%B8%E6%88%8F%E5%90%91/"},{"name":"TSW2","slug":"游戏向/TSW2","permalink":"https://www.sizaif.com/navigation/categories/%E6%B8%B8%E6%88%8F%E5%90%91/TSW2/"}],"tags":[{"name":"TSW2","slug":"TSW2","permalink":"https://www.sizaif.com/tags/TSW2/"}],"author":"sizaif"},{"title":"解决Win平台上linux虚拟机脚本格式问题","slug":"解决Win平台上linux虚拟机脚本格式问题","date":"2021-08-24T12:26:15.000Z","updated":"2021-09-19T10:09:19.033Z","comments":true,"path":"posts/448c4b49/","link":"","permalink":"https://www.sizaif.com/posts/448c4b49/","excerpt":"","text":"解决Win平台上linux虚拟机脚本格式问题 问题描述 经常会有以下使用场景: 在windows平台上编写脚本,复制脚本到docker容器linux中运行,或者复制到linux虚拟机中运行. 尝尝会报错: $'\\r' command not found 这样的错误 原因在于: Carriage-Return 回车符\\r Line-Feed 换行符\\n windows平台使用的格式是CRLF 结尾是 \\r\\n; 而 linux 和macOS平台使用的是LF结尾是\\n ;而MAC平台使用的是CR 结尾是\\r 老的Mac系统（Mac OS, OS X）： \\r 新的Mac系统（macOS）:\\n 在2001年以前的Mac操作系统，称为Classic Mac OS，行末采用”\\r”，这一系列操作系统的最后一个版本是1999年发布的Mac OS 9； 从2001年3月发布的Mac OS 10.0开始，行末采用”\\n”，称为macOS或OS X 查看脚本格式 1.cat -A filename，如果输出结果中行末尾是^M$，则是dos格式，如果行末尾只是$，则是unix格式。 2.vim filename，编辑文件，执行“:set ff”,若执行结果为fileformat=dos则为dos格式，若执行结果为fileformat=unix则为unix格式。 3.od -t x1 filename，以16进制查看文件，若输出结果中存在“0d 0a”则为dos格式，如果只有“0a”则为unix格式。其中“0d”即为回车符“\\r”，“0a”即为换行符“\\n”。 解决方法 当然是想办法把windows平台下的脚本转换成 LF呀 如果有vim\\vi ​ vim内执行 Shift + ; :set ff = unix :wq 使用dos2unix 工具 如果用的是 git bash 那么该客户端已经自带了 dos2unix 如果不是的话前提需要先安装dos2unix http://dos2unix.sourceforge.net/ 例如: 我使用的是 CygWin64 Mintty 控制台 那么我只需要执行即可 $ apt-cyg install dos2unix dos2unix 使用方法 # 使用方法 $ dos2unix filename # 或者使用以下命令,强制转换 $ find . -type f -exec dos2unix &#123;&#125; + # -f --force Force conversion of all files. Also binary files. 使用sed 命令 $ sed -e ‘s/.$//’ dosfile > unixfile 通常情况下是完全可以实现的, 但这个方法不是100%的解决方法 git 跨平台协作开发, 经场会出现在win平台下,使用git clone 命令将项目源码下载下来后,拿到linux虚拟机中运行,出现换行符错误的问题, 原因在于win平台使用git的时候, git自动将换行符替换为\\r\\n, 这时候再拿到linux中运行当然就不行了. 还好 Git 在设计时就考虑了这一点，其提供了一个 autocrlf 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项： true: 提交时转换为 LF，检出时转换为 CRLF false: 提交检出均不转换 input: 提交时转换为LF，检出时不转换 # 提交时转换为LF，检出时转换为CRLF git config --global core.autocrlf true # 提交时转换为LF，检出时不转换 git config --global core.autocrlf input # 提交检出均不转换 git config --global core.autocrlf false 查看当前git config 配置 $ git config --list http.proxy=socks5://127.0.0.1:7890 https.proxy=socks5://127.0.0.1:7890 user.name=XXXX user.email=XXXX core.autocrlf=true 如果把 autocrlf 设置为 false 时，那另一个配置项 safecrlf 最好设置为 ture。该选项用于检查文件是否包含混合换行符，其有三个可选项 true: 拒绝提交包含混合换行符的文件 false: 允许提交包含混合换行符的文件 warn: 提交包含混合换行符的文件时给出警告 # 拒绝提交包含混合换行符的文件 git config --global core.safecrlf true # 允许提交包含混合换行符的文件 git config --global core.safecrlf false # 提交包含混合换行符的文件时给出警告 git config --global core.safecrlf warn 像比如我, 再win上开发,使用git提交到github, 经常从github上下载项目,再win上修改后,拿到linux虚拟机/docker中运行, 那我的做法就是: 代码仓库使用统一的换行符(LF) $ git config --global core.autocrlf input $ git config --global core.safecrlf true 当遇到CRLF无法提交的时候, 用doc2unix 转换一下即可","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"}],"tags":[{"name":"Win","slug":"Win","permalink":"https://www.sizaif.com/tags/Win/"},{"name":"脚本格式","slug":"脚本格式","permalink":"https://www.sizaif.com/tags/%E8%84%9A%E6%9C%AC%E6%A0%BC%E5%BC%8F/"}],"author":"sizaif"},{"title":"Hexo博客优化","slug":"hexo博客优化","date":"2021-08-14T14:22:06.000Z","updated":"2021-09-19T10:09:19.014Z","comments":true,"path":"posts/83186147/","link":"","permalink":"https://www.sizaif.com/posts/83186147/","excerpt":"","text":"hexo博客优化 本地优化 文章链接唯一 Hexo默认使用的文章永久链接格式是： year/:month/:day/:title/ 缺点: 若标题为中文标题,则分享链接时会变成%X%X%X%之类的东西,非常难受.又臭又长,而且一旦更改标题和日期,链接会失效,非常不友好 解决方法: 采用 hexo-abbrlink 插件 在博客根目录（执行hexo命令的地方）安装插件： npm install hexo-abbrlink --save 编辑站点配置文件 _config.yml 首先注释掉原先的permalink设置 配置代码 # ======================================================= # # =====================abbrlink========================== # # ======================================================= # #permalink: :year/:month/:day/:title/ # permalink_defaults: # pretty_urls: # trailing_index: false # Set to false to remove trailing 'index.html' from permalinks # trailing_html: false # Set to false to remove trailing '.html' from permalinks permalink: posts/:abbrlink/ abbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex drafts: false #(true)Process draft,(false)Do not process draft. false(default) # Generate categories from directory-tree # depth: the max_depth of directory-tree you want to generate, should > 0 auto_category: enable: true #true(default) depth: #3(default) over_write: false auto_title: false #enable auto title, it can auto fill the title by path auto_date: false #enable auto date, it can auto fill the date by time today force: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. 项目链接: hexo-abbrlinkhttps://github.com/Rozbo/hexo-abbrlink 重新部署 hexo clean &amp;&amp; hexo g 重新部署后,会在front-matter 字段中增加 abbrlink 字段 验证查看 ,本地测试查看 hexo s -g Gulp压缩资源 安装gulp及相关插件 可以直接修改 package.json 添加 gulp-replace 版本号以及gulp依赖 修改完成后, 在blog根目录下控制台 输入: npm i 重新部署package.json 以下是我的package.json 可供参考 package.json &#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"scripts\": &#123; \"rebuild\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp\", \"rebuildJsd\": \"hexo clean &amp;&amp; hexo generate --config _github.yml &amp;&amp; gulp two\", \"deployGit\": \"hexo deploy --config _github.yml\", \"deployGitHub\": \"hexo deploy --config _githubOnly.yml\", \"deployOss\": \"hexo deploy --config _tencent.yml\", \"start\": \"hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d\", \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"server\": \"hexo server\" &#125;, \"hexo\": &#123; \"version\": \"5.4.0\" &#125;, \"dependencies\": &#123; \"aplayer\": \"^1.10.1\", \"gulp-replace\": \"^1.1.3\", \"hexo\": \"^5.0.0\", \"hexo-abbrlink\": \"^2.2.1\", \"hexo-autonofollow\": \"^1.0.1\", \"hexo-deployer-git\": \"^3.0.0\", \"hexo-generator-archive\": \"^1.0.0\", \"hexo-generator-baidu-sitemap\": \"^0.1.9\", \"hexo-generator-category\": \"^1.0.0\", \"hexo-generator-index\": \"^2.0.0\", \"hexo-generator-json-content\": \"^4.2.3\", \"hexo-generator-search\": \"^2.4.3\", \"hexo-generator-sitemap\": \"^2.1.0\", \"hexo-generator-tag\": \"^1.0.0\", \"hexo-renderer-ejs\": \"^1.0.0\", \"hexo-renderer-markdown-it\": \"^5.0.0\", \"hexo-renderer-stylus\": \"^2.0.0\", \"hexo-server\": \"^2.0.0\", \"hexo-theme-stellar\": \"^1.4.1\", \"hexo-wordcount\": \"^6.0.1\", \"markdown-it-emoji\": \"^2.0.0\" &#125;, \"devDependencies\": &#123; \"gulp\": \"^4.0.2\", \"gulp-html-minifier-terser\": \"^6.0.1\", \"gulp-htmlclean\": \"^2.7.22\", \"gulp-htmlmin\": \"^5.0.1\", \"gulp-minify-css\": \"^1.2.4\", \"gulp-terser\": \"^2.0.1\" &#125; &#125; 编辑gulpfile.js blog根目录下添加gulpfile.js 文件 添加代码 其中 minify_html_jsd 对应的是使用cdn 重定向, 后面链接对应改成自己的静态文件仓库即可 pipe(replace(xxx, xxx)) 是链接重定向, 跟根据需求自定义 gulpfile.js var gulp = require('gulp'); var minifycss = require('gulp-minify-css'); var htmlmin = require('gulp-html-minifier-terser'); // var uglify = require('gulp-uglify'); var htmlclean = require('gulp-htmlclean'); var terser = require('gulp-terser'); var replace = require('gulp-replace'); // 压缩css文件 const minify_css = () => ( gulp.src(['./public/**/*.css']) .pipe(minifycss(&#123; compatibility: 'ie8' &#125;)) // .pipe(minifycss()) .pipe(gulp.dest('./public')) ); // 压缩html文件 const minify_html = () => ( gulp.src(['./public/**/*.html','!./public/&#123;lib,lib/**&#125;','!./public/**.xml']) .pipe(replace('src=\"/js/', 'src=\"https://sizaif.com/js/')) .pipe(replace('href=\"/css/\"', 'href=\"https://sizaif.com/css/')) .pipe(replace('../img/img_article', 'https://sizaif.com/img/img_article/')) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public')) ) const minify_html_jsd = () => ( gulp.src(['./public/**/*.html','!./public/&#123;lib,lib/**&#125;']) .pipe(replace('src=\"/js/', 'src=\"https://cdn.jsdelivr.net/gh/sizaif/blog-cdn@main/js/')) .pipe(replace('href=\"/css/\"', 'href=\"https://cdn.jsdelivr.net/gh/sizaif/blog-cdn@main/css/\"')) .pipe(replace('../img/img_article', 'https://cdn.jsdelivr.net/gh/sizaif/blog-cdn@main/img/img_article')) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public')) ) // 压缩js文件 const minify_js = () => ( gulp.src(['./public/**/*.js', '!./public/**/*.min.js','!./public/&#123;lib,lib/**&#125;']) .pipe(terser()) // .pipe(uglify()) .pipe(gulp.dest('./public')) ) module.exports = &#123; minify_html: minify_html, minify_css: minify_css, minify_js: minify_js, minify_html_jsd: minify_html_jsd &#125;; gulp.task('one', gulp.parallel( minify_html, minify_css, minify_js )); gulp.task('two', gulp.parallel( minify_html_jsd, minify_css, minify_js )); gulp.task('default', gulp.series('one')); 运行 使用gulp后, 发布推送(hexo d)前需要添加一个命令 # 不使用cdn $ hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d # 使用cdn重定向 $ hexo clean &amp;&amp; hexo g &amp;&amp; gulp two &amp;&amp; hexo d SEO-sitemap 安装插件 百度 $ npm install hexo-generator-baidu-sitemap --save 谷歌 $ npm install hexo-generator-sitemap --save 编辑主站_config.yml 添加代码 ## ======================================================= # ## ==三、SEO 优化二网站地图 npm install hexo-generator-sitemap --save====== # ## npm install hexo-generator-baidu-sitemap --save ## ======================================================= # sitemap: path: sitemap.xml # tag: true # category: true baidusitemap: path: baidusitemap.xml 重新部署 会在public目录下生成: sitemap.xml -&gt; 谷歌 baidusitemap.xml -&gt; 百度 $ hexo clean &amp;&amp; hexo g 然后分别去对于站点网站提交即可 百度站点管理https://ziyuan.baidu.com/site/ 谷歌站点管理https://search.google.com/search-console/about robots.txt文件 robots.txt是一个纯文本文件，在这个文件中网站管理者可以声明该网站中不想被robots访问的部分，或者指定搜索引擎只收录指定的内容。 当一个搜索机器人（有的叫搜索蜘蛛）访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，那么搜索机器人就沿着链接抓取。 另外，robots.txt必须放置在一个站点的根目录下，而且文件名必须全部小写。 在source 目录下 新建 robots.txt 域名改成自己的 robots.txt # robots.txt www.sizaif.com User-agent: * Allow: /sitemap.xml Allow: /baidusitemap.xml Allow: /category-sitemap.xml Allow: /page-sitemap.xml Allow: /post-sitemap.xml Allow: /tag-sitemap.xml Allow: /posts/ Disallow: /css Disallow: /js Disallow: /fonts Disallow: /img Disallow: /fonts Disallow: /page Disallow: /navigation Disallow: /tags Disallow: /archives Disallow: /404.html Disallow: /403.html Disallow: /update.log Disallow: /search.xml Disallow: /README.md","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Hexo","slug":"技术向/Hexo","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.sizaif.com/tags/Hexo/"}],"author":"sizaif"},{"title":"七夕-杂谈","slug":"七夕-杂谈","date":"2021-08-14T09:28:28.218Z","updated":"2021-09-19T07:24:21.714Z","comments":true,"path":"posts/52b019f9/","link":"","permalink":"https://www.sizaif.com/posts/52b019f9/","excerpt":"","text":"送给每一对甜甜蜜蜜的你们!","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.sizaif.com/navigation/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.sizaif.com/tags/%E6%9D%82%E8%B0%88/"}],"author":"sizaif"},{"title":"Mybatis Insert 插入时拿到自增的主键ID","slug":"Mybatis-Insert-插入时拿到自增的主键ID","date":"2021-08-14T09:17:51.000Z","updated":"2021-09-19T10:09:19.061Z","comments":true,"path":"posts/eabbfbf/","link":"","permalink":"https://www.sizaif.com/posts/eabbfbf/","excerpt":"","text":"useGeneratedKeys=“true” : 是否开启生成主键 keyColumn=“数据库中主键名称” eyProperty=“(实体类中主键对应的名称或者自定义名称)”&gt; 如果你传入的参数是实体类, 那么请注意keyProperty 对应的应该是实体类中的主键ID; 如果你传入的参数是map,那么就可以自定义名称. 注意:新添加主键id并不是在执行添加操作时直接返回的，而是在执行添加操作之后将新添加记录的主键id字段返回到传入的参数类中. 例如: &lt;insert id=\"addUser\" parameterType=\"map\" useGeneratedKeys=\"true\" keyColumn=\"id\" keyProperty=\"id\"> INSERT INTO saishiguanli.users (createDate, modifyDate, isEnabled, isLocked, lastLoginDate, lastLoginIp, lockDate, name, encodePassword) VALUES (#&#123;createDate&#125;,#&#123;modifyDate&#125;,#&#123;isEnabled&#125;,#&#123;isLocked&#125;,#&#123;lastLoginDate&#125;,#&#123;lastLoginIp&#125;,#&#123;lockDate&#125;,#&#123;name&#125;,#&#123;encodePassword&#125;) &lt;/insert> 调用addUser方法后 int id = Integer.parseInt(hashMap.get(\"id\").toString()); 便可以取得主键ID; 若 传入的是实体类, 那么调用方法后 int id = user.getId(); 即可","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"}],"author":"sizaif"},{"title":"Mybatis中update使用动态SQL语句","slug":"Mybatis中update使用动态SQL语句","date":"2021-08-14T09:10:44.000Z","updated":"2021-09-19T10:09:19.023Z","comments":true,"path":"posts/119fdf75/","link":"","permalink":"https://www.sizaif.com/posts/119fdf75/","excerpt":"","text":"记个笔记:mybatis遇到的坑 Mybatis 进行Update 操作时; 有的数据不一定要进行修改,因此从前台传过来的数据,某些项可能为null; 在进行sql 语句时 就会进行异常;导致操作失败; 所以进行动态SQL语句拼接: 在UserMapper.xml中 更改:Mybatis中update使用动态SQL语句 &lt;update id=\"updateUser\" parameterType=\"map\" > update saishiguanli.user &lt;trim prefix=\"set\" suffixOverrides=\",\"> &lt;if test=\"ulevel!=null\">ulevel=#&#123;ulevel&#125;,&lt;/if> &lt;if test=\"ugender!=null\">ugender=#&#123;ugender&#125;,&lt;/if> &lt;if test=\"uname!=null\">uname=#&#123;uname&#125;,&lt;/if> &lt;if test=\"upwd!=null\">upwd=#&#123;upwd&#125;,&lt;/if> &lt;if test=\"unickname!=null\">unickname=#&#123;unickname&#125;,&lt;/if> &lt;if test=\"uimage!=null\">uimage=#&#123;uimage&#125;,&lt;/if> &lt;if test=\"uphone!=null\">uphone=#&#123;uphone&#125;,&lt;/if> &lt;if test=\"ucreatetime!=null\">ucreatetime=#&#123;ucreatetime&#125;,&lt;/if> &lt;/trim> where uid = #&#123;uid&#125; &lt;/update>","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"}],"author":"sizaif"},{"title":"解决Waline使用图片上传图床跨域错误问题","slug":"解决waline使用图片上传图床跨域错误问题","date":"2021-08-13T02:07:10.000Z","updated":"2021-09-21T06:09:52.217Z","comments":true,"path":"posts/db8bf7ad/","link":"","permalink":"https://www.sizaif.com/posts/db8bf7ad/","excerpt":"","text":"@auther by sizaf 错误描述: 说明 我采用的是Volantis 作为主题 在主题_config.yml 文件中 修改waline 配置 waline: js: https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js path: # 全局评论地址 目前设置全局评论地址后visitor失效,这是waline的问题 placeholder: 允许匿名评论，评论支持贴图，大家在截图后，在评论框粘贴，自动传至图床，欢迎使用体验~ # 评论占位提示 imageHosting: https://7bu.top/api/upload # 图床api「默认使用去不图床」 # 其他配置项按照yml格式继续填写即可 除了 [el path placeholder uploadImage] 选项 meta: [nick,mail,link] # waline comment header info requiredFields: [nick,mail] serverURL: # Waline 的服务端地址「必填」 测试用地址: https://waline-ruddy.vercel.app avatar: robohash # gravatar style https://waline.js.org/client/basic.html#avatar pageSize: 10 # 评论每页显示数量 lang: zh-CN visitor: true 其中 serverURL 选项 请参考文档使用说明 waline文档https://waline.js.org/guide/get-started.html 若采用其他主题,可按照官方设置加入 uploadImage 即可, 具体参考 &lt;head> .. &lt;script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'>&lt;/script> ... &lt;/head> &lt;body> ... &lt;div id=\"waline\">&lt;/div> &lt;script> new Waline(&#123; el: '#waline', path: location.pathname, serverURL: 'https://your-domain.vercel.app' uploadImage: function(file) &#123; const formData = new FormData(); formData.append('image', file); return fetch('https://7bu.top/upload/upload.html', &#123; method: 'POST', body: formData &#125;).then(resp => resp.json()).then(resp => resp.data.url); &#125; &#125;); &lt;/script> &lt;/body> 修改 如果你使用volantis作为主题, 那么只需要修改themes\\volantis\\layout\\_third-party\\comments\\waline\\script.ejs 文件中 的uploadImage函数 将your's token value 替换为你自己的 图床 token uploadImage: function(file) &#123; const formData = new FormData(); formData.append('image', file); const token = \"your's token value\"; return fetch('&lt;%= theme.comments.waline.imageHosting %>', &#123; method: 'POST', body: formData, headers: &#123;'Authorization': token&#125; &#125;).then(resp => resp.json()).then(resp => resp.data.url); &#125;, 若采用其他主题 请修改代码 将your's token value 替换为你自己的 图床 token &lt;head> .. &lt;script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'>&lt;/script> ... &lt;/head> &lt;body> ... &lt;div id=\"waline\">&lt;/div> &lt;script> new Waline(&#123; el: '#waline', path: location.pathname, serverURL: 'https://your-domain.vercel.app' uploadImage: function(file) &#123; const formData = new FormData(); const token = \" your's token value\"; formData.append('image', file); return fetch('https://7bu.top/upload/upload.html', &#123; method: 'POST', body: formData, headers: &#123;'Authorization': token&#125; &#125;).then(resp => resp.json()).then(resp => resp.data.url); &#125; &#125;); &lt;/script> &lt;/body>","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"杂项","slug":"技术向/杂项","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://www.sizaif.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Waline","slug":"Waline","permalink":"https://www.sizaif.com/tags/Waline/"}],"author":"sizaif"},{"title":"PicGo + Gitee(码云)实现markdown图床","slug":"PicGo-Gitee-码云-实现markdown图床","date":"2021-08-12T02:27:37.000Z","updated":"2021-09-19T10:12:20.954Z","comments":true,"path":"posts/373ab937/","link":"","permalink":"https://www.sizaif.com/posts/373ab937/","excerpt":"","text":"@auther by sizaif 转载https://www.jianshu.com/p/b69950a49ae2","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"图床","slug":"技术向/图床","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://www.sizaif.com/tags/PicGo/"},{"name":"Gitee","slug":"Gitee","permalink":"https://www.sizaif.com/tags/Gitee/"}],"author":"sizaif"},{"title":"HE 在人脸识别中的应用Demo 演示文档","slug":"HE-在人脸识别中的应用demo-演示文档","date":"2021-08-12T02:08:34.000Z","updated":"2021-08-14T14:15:24.849Z","comments":true,"path":"posts/6c15e2cc/","link":"","permalink":"https://www.sizaif.com/posts/6c15e2cc/","excerpt":"","text":"@auther by sizaif HE 在人脸识别中的应用demo 演示文档 @[toc] 说明 使用的HE方案是CKKS / | Encryption parameters : | scheme: CKKS | poly_modulus_degree: 8192 | coeff_modulus size: 200 (60 + 40 + 40 + 60) bits | scale: pow(2.0,40) \\ 输入数据的长度 n = 10 , 因为没有用FaceNet数据集的缘故,演示所用的测试数据来源为简单生成,生成方式为: 编译平台: Visual Studio 2019 所需外部环境: seal.h ; examples.h ； bits/stdc++.h 项目代码上传至: github: https://github.com/sizaif/SEALExamples/tree/main 数据来源 输入的input数据和database数据来源生成代码如下: code // slot_count = poly_modulus_degree /2 => 4096 double curr_point = 0; double step_size = 1.0 / (static_cast&lt;double>(slot_count) - 1); ofstream out; out.open(\"database.txt\", ios::in | ios::out | ios::binary | ios::trunc); if (out.is_open()) &#123; int step = 0; for (size_t i = 0; i &lt; slot_count; i++) &#123; // 每10行一个数据 if(step %10 == 9) out &lt;&lt; curr_point &lt;&lt; \"\\n\"; else &#123; out &lt;&lt; curr_point &lt;&lt; \" \"; &#125; step++; curr_point += step_size; &#125; out &lt;&lt; endl; out.close(); cout &lt;&lt; \"Input vector: \" &lt;&lt; endl; &#125; 选取的input数据如下: [0.984127 0.984371 0.984615 0.98486 0.985104 0.985348 0.985592 0.985836 0.986081 0.986325] 从生成的database中最后10行中选取第6行生成 选取的database E 数据如下: data [0.974359 0.974603 0.974847 0.975092 0.975336 0.97558 0.975824 0.976068 0.976313 0.976557][0.976801 0.977045 0.977289 0.977534 0.977778 0.978022 0.978266 0.97851 0.978755 0.978999][0.979243 0.979487 0.979731 0.979976 0.98022 0.980464 0.980708 0.980952 0.981197 0.981441][0.981685 0.981929 0.982173 0.982418 0.982662 0.982906 0.98315 0.983394 0.983639 0.983883][0.984127 0.984371 0.984615 0.98486 0.985104 0.985348 0.985592 0.985836 0.986081 0.986325][0.986569 0.986813 0.987057 0.987302 0.987546 0.98779 0.988034 0.988278 0.988523 0.988767][0.989011 0.989255 0.989499 0.989744 0.989988 0.990232 0.990476 0.99072 0.990965 0.991209][0.991453 0.991697 0.991941 0.992186 0.99243 0.992674 0.992918 0.993162 0.993407 0.993651][0.993895 0.994139 0.994383 0.994628 0.994872 0.995116 0.99536 0.995604 0.995849 0.996093][0.996337 0.996581 0.996825 0.99707 0.997314 0.997558 0.997802 0.998046 0.998291 0.998535] 过程步骤 总览 首先计算 p 与 E 中的 $C_{i}$ 比较分数并用 $r_{i}$表示,求最佳的 $r_{i}$, $\\mathbf{r}{i}=\\operatorname{dist}\\left(\\mathbf{p}, \\mathbf{c}{i}\\right) \\cdot \\mathbf{k} ; k={1,0, \\ldots 0}$​ 处理完全部数据库内容后,N个单独结果的 vector $\\mathbf{R}=\\left[\\begin{array}{c}\\mathbf{r}{1} \\ \\mathbf{r}{2} \\ \\vdots \\ \\mathbf{r}{N}\\end{array}\\right]=\\left[\\begin{array}{c}\\left(\\mathbf{r}{1,1}, 0, \\ldots 0\\right) \\ \\left(\\mathbf{r}{2,1}, 0, \\ldots 0\\right) \\ \\vdots \\ \\left(\\mathbf{r}{N, 1}, 0, \\ldots 0\\right)\\end{array}\\right]$​ 每个$r_{i}$​是单独加密的, 可以随机打乱$r_{i}$​的顺序 通过将$r_{i}$​移位,变成对角矩阵 例如 $\\mathbf{R}=\\left[\\begin{array}{c} \\left(\\mathbf{r}{1,1}, 0, \\ldots 0\\right) \\ \\left(0, \\mathbf{r}{2,1}, \\ldots 0\\right) \\ \\vdots \\ \\left(0,0, \\ldots \\mathbf{r}_{N, 1}\\right) \\end{array}\\right]$​ 将对角线上vector组合成新的带有与P比较分数的vector格式 i.e. $R-&gt;\\left(\\mathbf{r}{1,1}, \\mathbf{r}{2,1}, \\ldots \\mathbf{r}_{N, 1}\\right)$​ 将上式跟预先设定的阈值${t}=(t, t, \\ldots t)$进行比较 形成新的vector d: $d = R - t$, 然后将d 传输给第三方 最终将 d 进行解密决定结果(decision),并传送给客户 $d = R - t$​​ ; $d=R-t ; \\quad$​​ decision $= \\begin{cases}\\text { accept } &amp; \\text { if } \\exists d \\in \\mathbf{d}: d&gt;0 \\ \\text { reject } &amp; \\text { if } \\forall d \\in \\mathbf{d}: d \\leq 0\\end{cases}$ 一: 将input和database中的数据分别加密获得encrypt_probe_p和 encrypt_E_matrix 1：加密得到probe_p Ciphertext get_encrypt_probe(CKKSEncoder&amp; ckks_encoder,Encryptor &amp; encryptor, vector&lt;double>v_input) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_encrypt_probe() begin------\" &lt;&lt; endl; /* * 加密获得probe_p; */ Plaintext v_plaintext; // v编码 ckks_encoder.encode(v_input, scale, v_plaintext); Ciphertext probe_p; // 加密 encryptor.encrypt(v_plaintext, probe_p); print_line(__LINE__); cout &lt;&lt; \"------get_encrypt_probe() end------\" &lt;&lt; endl; return probe_p; &#125; 将加密的probe_p解密做验证: 2：将database中的所有数据分别加密，组成矩阵E: vector&lt;Ciphertext> get_encrypt_E_matrix(CKKSEncoder&amp; ckks_encoder, Encryptor&amp; encryptor, vector&lt;vector&lt;double>>E_matrix) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_encrypt_E_matrix() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_E_matrix; for (auto it = E_matrix.begin(); it != E_matrix.end(); it++) &#123; Plaintext plain_E_ci; Ciphertext encrypt_E_ci; ckks_encoder.encode(*it, scale, plain_E_ci); encryptor.encrypt(plain_E_ci, encrypt_E_ci); encrypt_E_matrix.push_back(encrypt_E_ci); &#125; print_line(__LINE__); cout &lt;&lt; \"------get_encrypt_E_matrix() end------\" &lt;&lt; endl; return encrypt_E_matrix; &#125; 将加密的databse数据做解密验证: 输出前4行: 二: 计算 $\\mathbf{r}{i}=\\operatorname{dist}\\left(\\mathbf{p}, \\mathbf{c}{i}\\right) \\cdot \\mathbf{k}$ 分步骤: 总代码调用: code vector&lt;Ciphertext> get_dist(SEALContext&amp; context,CKKSEncoder&amp; ckks_encoder, Evaluator&amp; evaluator, vector&lt;Ciphertext> encrypt_E_matrix, Ciphertext probe_p,Encryptor &amp; encryptor ,Decryptor&amp; decryptor, RelinKeys&amp; relin_keys, GaloisKeys&amp; galois_keys) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_dist() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_R_matrix; /* * get (Ci - Pi)^2 */ cout &lt;&lt; \"sub &amp; square &amp;&amp; stored in encrypt_R_matrix: \" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_R_matrix_cache = get_sub_square(ckks_encoder, evaluator, decryptor,encrypt_E_matrix,probe_p, relin_keys); /* * get sum */ encrypt_R_matrix = get_sum_rotate(context,ckks_encoder,evaluator,encryptor, decryptor, encrypt_R_matrix_cache,galois_keys,relin_keys); print_line(__LINE__); cout &lt;&lt; \"------get_dist() end------\" &lt;&lt; endl; return encrypt_R_matrix; &#125; 1：求 ${(C_{i} - P_{i})}^{2}$ code vector&lt;Ciphertext> get_sub_square(CKKSEncoder&amp; ckks_encoder,Evaluator &amp; evaluator,Decryptor &amp; decryptor,vector&lt;Ciphertext> encrypt_E_matrix, Ciphertext probe_p,RelinKeys &amp; relin_keys) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_sub_square() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_R_matrix; for (auto it = encrypt_E_matrix.begin(); it != encrypt_E_matrix.end(); it++) &#123; Plaintext plain_sub_cache, plain_mult_cache; Ciphertext encrypt_sub_cache, encrypt_multiply_cache; vector&lt;double>result_sub_cache, result_mult_cache; evaluator.sub(probe_p, (*it), encrypt_sub_cache); evaluator.relinearize_inplace(encrypt_sub_cache, relin_keys); evaluator.square(encrypt_sub_cache, encrypt_multiply_cache); evaluator.relinearize_inplace(encrypt_multiply_cache, relin_keys); evaluator.rescale_to_next_inplace(encrypt_multiply_cache); encrypt_R_matrix.push_back(encrypt_multiply_cache); &#125; print_line(__LINE__); cout &lt;&lt; \"------get_sub_square() end------\" &lt;&lt; endl; return encrypt_R_matrix; &#125; 解码结果验证测试： ​ 1. $(C_{i} - P_{i})$结果: ${(C_{i} - P_{i})}^{2}$结果: 2: $\\sum_{i=0}{s}\\left(\\mathbf{c}_{i}-\\mathbf{p}_{i}\\right){2}$ 循环遍历encrypt_R_matrix， 将密文每次移位step步后加到encrypt_sum_cache上得到最终的结果， step从0到number-1 code vector&lt;Ciphertext> get_sum_rotate(SEALContext &amp;context,CKKSEncoder&amp; ckks_encoder, Evaluator&amp; evaluator,Encryptor &amp;encryptor ,Decryptor&amp; decryptor, vector&lt;Ciphertext>encrypt_R_matrix,GaloisKeys &amp; galois_keys,RelinKeys &amp; relin_keys) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_sum_rotate() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_RR_matrix; /* * get encryptor of vector K&#123;1,0,0,....0&#125; * begin */ size_t slot_count = ckks_encoder.slot_count(); vector&lt;double>vector_k(slot_count, 0ULL); vector_k[0] = 1ULL; //print_vector(vector_k, 3, 13); Plaintext plain_vector_k; Ciphertext encrypt_vector_k; ckks_encoder.encode(vector_k, pow(2.0, 40), plain_vector_k); encryptor.encrypt(plain_vector_k, encrypt_vector_k); evaluator.mod_switch_to_next_inplace(encrypt_vector_k); //end /* * Calculate begin */ for (auto it = encrypt_R_matrix.begin(); it != encrypt_R_matrix.end(); it++) &#123; Plaintext plain_rotated_cache, plain_sum_cache; Ciphertext encrypt_rotated_cache, encrypt_sum_cache; vector&lt;double>result_rotated_cache, result_sum_cache; encrypt_sum_cache = (*it); /* * rotated &amp; add to get sum of them */ for (auto i = 0; i &lt; number_n - 1; i++) &#123; evaluator.rotate_vector(encrypt_sum_cache, 1, galois_keys, encrypt_rotated_cache); encrypt_sum_cache = encrypt_rotated_cache; evaluator.add_inplace(encrypt_sum_cache,(*it) ); evaluator.relinearize_inplace(encrypt_sum_cache, relin_keys); &#125; evaluator.multiply_inplace(encrypt_sum_cache, encrypt_vector_k); evaluator.relinearize_inplace(encrypt_sum_cache, relin_keys); evaluator.rescale_to_next_inplace(encrypt_sum_cache); encrypt_RR_matrix.push_back(encrypt_sum_cache); &#125; /* * Calculate end; */ print_line(__LINE__); cout &lt;&lt; \"------get_sum_rotate() end------\" &lt;&lt; endl; return encrypt_RR_matrix; &#125; 解码结果验证测试(部分截取): 3: 求 $\\operatorname{dist}\\left(\\mathbf{p}, \\mathbf{c}_{i}\\right) \\cdot \\mathbf{k}$ 代码内嵌在第二步求 2: $\\sum_{i=0}{s}\\left(\\mathbf{c}_{i}-\\mathbf{p}_{i}\\right){2}$​中 evaluator.multiply_inplace(encrypt_sum_cache, encrypt_vector_k); evaluator.rescale_to_next_inplace(encrypt_sum_cache); encrypt_RR_matrix.push_back(encrypt_sum_cache); 解码结果验证: 三: 将得到 R 进行移位叠加操作: code vector&lt;Ciphertext> get_shifting_ri(SEALContext&amp; context,CKKSEncoder&amp; ckks_encoder,Evaluator&amp; evaluator,vector&lt;Ciphertext> encrypt_R_matrix, GaloisKeys&amp; galois_keys, Decryptor&amp; decryptor) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_shifting_ri() begin------\" &lt;&lt; endl; vector&lt;Ciphertext> encrypt_RR_matrix; Plaintext plain_shift_cache; vector&lt;double>result_shift_cache; int step = 0; for (auto it = encrypt_R_matrix.begin(); it != encrypt_R_matrix.end(); it++) &#123; Ciphertext after_shift; // 右移 evaluator.rotate_vector((*it),step, galois_keys,after_shift); step--; encrypt_RR_matrix.push_back(after_shift); &#125; print_line(__LINE__); cout &lt;&lt; \"------get_shifting_ri() end------\" &lt;&lt; endl; return encrypt_RR_matrix; &#125; 解码结果验证测试； 输出前10列前10行， 保留13位小数 四: 将得到 $R-&gt;\\left(\\mathbf{r}{1,1}, \\mathbf{r}{2,1}, \\ldots \\mathbf{r}_{N, 1}\\right)$: 通过移位操作得到对角矩阵后，将所有的$C_{i}$​ 累加起来得到$R-&gt;\\left(\\mathbf{r}{1,1}, \\mathbf{r}{2,1}, \\ldots \\mathbf{r}_{N, 1}\\right)$: code Ciphertext get_combined_R(SEALContext&amp; context,CKKSEncoder&amp; ckks_encoder,Evaluator&amp; evaluator, vector&lt;Ciphertext> encrypt_R_matrix, Encryptor&amp; encryptor, Decryptor&amp; decryptor, RelinKeys&amp; relin_keys) &#123; print_line(__LINE__); cout &lt;&lt; \"------get_combined_R() begin------\" &lt;&lt; endl; Ciphertext encrypt_R_sum_cache; cout &lt;&lt; \" combined together: \" &lt;&lt; endl; int step = 0; for (auto it = encrypt_R_matrix.begin(); it != encrypt_R_matrix.end(); it++) &#123; if (step == 0) &#123; encrypt_R_sum_cache = (*it); step++; continue; &#125; else &#123; parms_id_type last_parms_id = (*it).parms_id(); evaluator.add_inplace(encrypt_R_sum_cache, (*it)); evaluator.relinearize_inplace(encrypt_R_sum_cache,relin_keys); step++; &#125; &#125; print_line(__LINE__); cout &lt;&lt; \"------get_combined_R() end------\" &lt;&lt; endl; return encrypt_R_sum_cache; &#125; 解密结果测试: 最终结果展示 ==注意！== (因为没有用FaceNet缘故,这里给定的阈值 t 不得知，故程序只运行到将R做完对角化后并加在一起变成一个 $R-&gt;(r1,1, r2,1, . . . rN,1).$形式 若给定的设定的t已知; 则只需要做如下操作判定结果: code // d = R - t Ciphertext encrypt_T,encrypt_d; evaluator.sub(mapping_R,encrypt_T,encrypt_d); // *d = Dec(d) Plaintext plain_dd_cache; vector&lt;double>result_dd_cache; decryptor.decrypt(encrypt_d, plain_dd_cache); ckks_encoder.decode(plain_dd_cache, result_dd_cache); // judge ∃d ∈ d∗: d > 0 ? accept : reject bool ok = 0; auto len = result_dd_cache.size(); for (auto i = 0; i &lt; len; i++) &#123; if (result_dd_cache[i] > 0) &#123; ok = 1; break; &#125; &#125; string ans = ok ? \"accept\" : \"reject\"; cout &lt;&lt; ans &lt;&lt; endl; //输出最后结果","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"Mybatis  XXX.ReflectionException_ There Is No Getter for Name XXX问题","slug":"Mybatis-XXX-ReflectionException-There-is-no-getter-for-name-XXX问题","date":"2021-08-11T14:22:32.000Z","updated":"2021-09-19T10:13:17.198Z","comments":true,"path":"posts/12adf317/","link":"","permalink":"https://www.sizaif.com/posts/12adf317/","excerpt":"","text":"[TOC] @auther by sizaif 解决方法 首先,这个肯定是因为数据库表中的字段名,和实体类中的字段名映射失败引起的; 1: 查看 是否拼写错误 &lt;!--映射表--> &lt;resultMap id=\"UsersMap\" type=\"com.sizaif.emsdemo.pojo.User.Users\"> &lt;!--column数据库中的字段，property实体类中的属性--> &lt;result column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/> &lt;result column=\"createDate\" property=\"createDate\" jdbcType=\"VARCHAR\" /> &lt;result column=\"modifyDate\" property=\"modifyDate\" jdbcType=\"VARCHAR\" /> &lt;result column=\"isEnabled\" property=\"isEnabled\" jdbcType=\"INTEGER\"/> &lt;result column=\"isLocked\" property=\"isLocked\" jdbcType=\"INTEGER\"/> &lt;result column=\"lastLoginDate\" property=\"lastLoginDate\" jdbcType=\"VARCHAR\" /> &lt;result column=\"lastLoginIp\" property=\"lastLoginIp\" jdbcType=\"VARCHAR\" /> &lt;result column=\"lockDate\" property=\"lockDate\" jdbcType=\"VARCHAR\" /> &lt;result column=\"uname\" property=\"name\" jdbcType=\"VARCHAR\"/> &lt;result column=\"encodePassword\" property=\"password\" jdbcType=\"VARCHAR\"/> &lt;result column=\"role\" property=\"role\" jdbcType=\"VARCHAR\"/> &lt;/resultMap> 2: 查看 sql动态插入或更新语句中字段是否拼写错误与实体类中字段不符** &lt;if test=\"XXX实体类字段名 != null\"> XXX数据库字段名, &lt;/if>","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"}],"author":"sizaif"},{"title":"Layui Tree 获取复选框选中节点的Id","slug":"layui-tree-获取复选框选中节点的id","date":"2021-08-11T14:11:34.000Z","updated":"2021-09-19T10:13:44.563Z","comments":true,"path":"posts/b7de2574/","link":"","permalink":"https://www.sizaif.com/posts/b7de2574/","excerpt":"","text":"[TOC] @auther by sizaif 说明 官方文档提供的代码只能获取到根节点的id,没有进行树遍历,无法获取到子树的id. Code 官方文档提供的 tree.render(&#123; elem: '#test' ,data: [] //数据源 ,id: 'demoId' //定义索引 &#125;); //获得选中的节点 var checkData = tree.getChecked('demoId'); 我的代码 var treecheckdata = tree.getChecked('demoId'); var nodeIds = new Array(); nodeIds = getCheckedId(treecheckdata); // 测试 var permList = nodeIds; console.log(\"permList:\"+permList); // 获取选中节点的id function getCheckedId(jsonObj) &#123; var id = \"\"; $.each(jsonObj, function (index, item) &#123; if (id != \"\") &#123; id = id + \",\" + item.id; &#125; else &#123; id = item.id; &#125; var i = getCheckedId(item.children); if (i != \"\") &#123; id = id + \",\" + i; &#125; &#125;); return id; &#125; 效果图","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Js","slug":"技术向/Js","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Js/"}],"tags":[{"name":"Js","slug":"Js","permalink":"https://www.sizaif.com/tags/Js/"},{"name":"Layui","slug":"Layui","permalink":"https://www.sizaif.com/tags/Layui/"}],"author":"sizaif"},{"title":"Layui Table 解决从后台传入数据为二维数组模式,即带有子类的数据格式","slug":"layui-table-解决从后台传入数据为二维数组模式-即带有子类的数据格式","date":"2021-08-11T14:11:12.000Z","updated":"2021-09-19T10:13:50.573Z","comments":true,"path":"posts/2b51004/","link":"","permalink":"https://www.sizaif.com/posts/2b51004/","excerpt":"","text":"[TOC] @auther by sizaif 后台传入的格式 前台处理 code ,response:&#123; statusName: 'code' //数据状态的字段名称，默认：code ,statusCode: 200 //成功的状态码，默认：0 ,countName: 'totals' //数据总数的字段名称，默认：count ,dataName: 'list' //数据列表的字段名称，默认：data &#125; ,parseData: function(res)&#123; //res 即为原始返回的数据 console.log(res); return &#123; \"code\":res.code, //解析接口状态 \"msg\": res.message, //解析提示文本 \"totals\": res.totals, //解析数据长度 \"list\": res.list //解析数据列表 &#125;; &#125; ,cols: [[ //表头 &#123;field: 'users', title: '上次登录IP',sort: true,templet:function(d)&#123;return d.users.lastLoginIp&#125; &#125; ,&#123;field: 'users', title: '角色',sort: true,templet:function(d)&#123;return d.users.role&#125;&#125; ]] 效果","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Js","slug":"技术向/Js","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Js/"}],"tags":[{"name":"Js","slug":"Js","permalink":"https://www.sizaif.com/tags/Js/"},{"name":"Layui","slug":"Layui","permalink":"https://www.sizaif.com/tags/Layui/"}],"author":"sizaif"},{"title":"Mybatis 单表自关联 实现树结构的几种方式","slug":"Mybatis-单表自关联-实现树结构的几种方式","date":"2021-08-11T14:10:32.000Z","updated":"2021-09-19T10:13:24.205Z","comments":true,"path":"posts/843fdcdc/","link":"","permalink":"https://www.sizaif.com/posts/843fdcdc/","excerpt":"","text":"@auther by sizaif @TOC 结构 Bean code @JsonIdentityInfo( generator = ObjectIdGenerators.IntSequenceGenerator.class) public class PermissionVO implements Serializable&#123; private static final long serialVersionUID = -2783081162690878303L; private Integer id; private String name; private Integer pid; private Integer istype; private String code; private String page; private boolean checked; private boolean open; private List&lt;PermissionVO> children; 法一:使用mybatis映射实现 mabatis.xml配置 code &lt;!--=Start findPerms 查找权限树列表 结果集映射--> &lt;resultMap id=\"findPermissionMap\" type=\"com.sizaif.emsdemo.dto.PermissionVO\"> &lt;id property=\"id\" column=\"id\"/> &lt;result property=\"name\" column=\"name\"/> &lt;result property=\"pid\" column=\"pid\"/> &lt;result property=\"istype\" column=\"istype\"/> &lt;result property=\"code\" column=\"code\"/> &lt;result property=\"page\" column=\"page\"/> &lt;collection property=\"children\" column=\"id\" ofType=\"com.sizaif.emsdemo.dto.PermissionVO\" select=\"findChildPerm\"/> &lt;/resultMap> &lt;!--=End findPerms 查找权限树列表--> &lt;!-- pID 对应 PermissionVO 中 pID--> &lt;sql id=\"PermColumn\" > id, name,pid,istype, code,page &lt;/sql> &lt;!--=Start findPerms 查找权限树列表--> &lt;select id=\"findPerms\" resultMap=\"findPermissionMap\"> SELECT &lt;include refid=\"PermColumn\" /> FROM permission WHERE pid = 0 OR pid is NULL &lt;/select> &lt;!--=End findPerms 查找权限树列表--> &lt;!--=Start findChildPerm 查找所有子节点权限--> &lt;select id=\"findChildPerm\" resultMap=\"findPermissionMap\"> select &lt;include refid=\"PermColumn\" /> from permission where pid = #&#123;pid&#125; &lt;/select> &lt;!--=End findChildPerm 查找所有子节点权限--> service层调用 @Override public List&lt;PermissionVO> findPerms() &#123; return permissionsMapper.findPerms(); &#125; controller List&lt;PermissionVO> pvos = authService.findPerms(); 法二:通过递归实现 mybatis.xml配置 code &lt;resultMap id=\"BaseResultMap\" type=\"com.sizaif.emsdemo.dto.PermissionVO\"> &lt;id property=\"id\" column=\"id\"/> &lt;result property=\"name\" column=\"name\"/> &lt;result property=\"pid\" column=\"pid\"/> &lt;result property=\"istype\" column=\"istype\"/> &lt;result property=\"code\" column=\"code\"/> &lt;result property=\"page\" column=\"page\"/> &lt;/resultMap> &lt;select id=\"getChildren\" resultMap=\"BaseResultMap\"> select id, pid, name, istype, code,page from permission where pid = #&#123;id&#125; &lt;/select> service @Override public List&lt;PermissionVO> getChildPerms(Integer id) &#123; return permissionsMapper.getChildren(id); &#125; controller code public PermissionVO initPermission1()&#123; PermissionVO permissionvo=new PermissionVO (); try&#123; permissionvo.setId(0);//这个地方应该通过数据库查询出根节点，因为根节点id在数据库是0， queryChildPermissions(permissionvo);//递归得到全部节点 &#125;catch (Exception e)&#123; throw e; &#125; return permissionvo; &#125; private void queryChildPermissions (PermissionVO permissionvo)&#123; List&lt;PermissionVO> children= authService.getChildPerms(permissionvo.getId());//通过id查询子集合 permissionvo.setChildren(children);//将查询出来的子节点集合放入到permissionvo集合中 for(PermissionVO innerChildren:children)&#123; //遍历出子集合的子集合 queryChildPermissions(innerChildren); //放入到子节点的子集合中 &#125; &#125; 法三: 一次查出全部记录，通过嵌套循环遍历结果 xml code &lt;resultMap id=\"BaseResultMap\" type=\"com.sizaif.emsdemo.dto.PermissionVO\"> &lt;id property=\"id\" column=\"id\"/> &lt;result property=\"name\" column=\"name\"/> &lt;result property=\"pid\" column=\"pid\"/> &lt;result property=\"istype\" column=\"istype\"/> &lt;result property=\"code\" column=\"code\"/> &lt;result property=\"page\" column=\"page\"/> &lt;/resultMap> &lt;select id=\"selectAll\" resultMap=\"BaseResultMap\"> select id, pid, name, istype,code,page from permission &lt;/select> service: @Override public List&lt;PermissionVO> selectAll() &#123; return permissionsMapper.selectAll(); &#125; controller: code public PermissionVO initPermissionVO()&#123; PermissionVO permissionvo = new PermissionVO (); List&lt;PermissionVO> lists= authService.selectAll();//查询所有节点 try&#123; for(PermissionVO ps:lists)&#123;//遍历节点 PermissionVO child = ps; if( ps.getPid().equals(0) || ps.getPid() == null)&#123;//获取根节点,Integer类型是包装类，判断对象引用 permissionvo = ps;//根节点 &#125;else&#123; for (PermissionVO innerpermissionvo:lists)&#123; if(child.getPid() == innerpermissionvo.getId())&#123;//如果节点的的pid和集合中某个节点的id一致 PermissionVO parent=innerpermissionvo;//将这个节点命名为父节点 parent.getChildren().add(child);//然后把child放入到它的父亲集合中 break; &#125; &#125; &#125; &#125; &#125;catch (Exception e)&#123; throw e; &#125; return permissionvo; &#125; 法四:一次查出所有数据,通过Map集合实现树结构 xml 与service 与法三一致, controller: code public PermissionVO initPermission()&#123; PermissionVO permissionvo=new PermissionVO (); List&lt;PermissionVO> lists = authService.selectAll();//查询所有节点 Map&lt;Integer,PermissionVO> map = new HashMap&lt;Integer,PermissionVO>();//将所有节点存入到map集合 try&#123; for(PermissionVO ps:lists) &#123; map.put(ps.getId(),ps);//将所有id做为key，Permissionvo对象做值，存入到map集合 &#125; for(PermissionVO ps:lists)&#123;//遍历所有节点 PermissionVO child = ps; if (child.getPid().equals(0)||child.getPid()==null)&#123; permissionvo = ps;//取出根节点 &#125;else&#123; PermissionVO parent = map.get(child.getPid());//通过子节点的pid获取父节点 parent.getChildren().add(child);//将子节点放入父节点中 &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return permissionvo; &#125; 四种方式查出来的结果是一样的,但效率方面法四最快","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"}],"author":"sizaif"},{"title":"linux安装java1.8 Jdk并配置环境变量","slug":"linux安装java1-8-jdk并配置环境变量","date":"2021-08-11T14:06:40.000Z","updated":"2021-09-19T10:13:35.085Z","comments":true,"path":"posts/f03f62f2/","link":"","permalink":"https://www.sizaif.com/posts/f03f62f2/","excerpt":"","text":"@auther by sizaif @TOC 下载jdk 百度网盘链接:提取码: krfa 使用fileZilla将jdk传输到linux上 安装 rpm -ivh jdk-8u251-linux-x64.rpm 配置环境变量 vim /etc/profile export JAVA_HOME=/usr/java/jdk1.8.0_251-amd64 export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 更新环境变量 source /etc/profile 验证: java -version","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"},{"name":"Linux","slug":"技术向/Linux","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Linux/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Jdk","slug":"Jdk","permalink":"https://www.sizaif.com/tags/Jdk/"},{"name":"Linux","slug":"Linux","permalink":"https://www.sizaif.com/tags/Linux/"}],"author":"sizaif"},{"title":"使用Docker部署SpringBoot项目全流程记录,超详细!","slug":"使用Docker部署SpringBoot项目全流程记录-超详细","date":"2021-08-11T14:05:33.000Z","updated":"2021-09-19T10:14:19.194Z","comments":true,"path":"posts/dfba8e73/","link":"","permalink":"https://www.sizaif.com/posts/dfba8e73/","excerpt":"","text":"@auther by sizaif @TOC 引言 我的linux环境为: centos:7 服务器在国外,所以有一些操作像阿里云的端口安全组设置就不需要操作 需要的软件 xshell(用来连接linux服务器) xftp或fileZilla用来给linux服务器上传文件 sqlyog(或者navicat)在服务器上解析.sql脚本 maven(idea自带) 用来打包 安装Docker 官网对系统的要求 OS requirements To install Docker Engine, you need a maintained version of CentOS 7. Archived versions aren’t supported or tested. The centos-extras repository must be enabled. This repository is enabled by default, but if you have disabled it, you need to re-enable it. The overlay2 storage driver is recommended. 要求版本Centos7, 其版本不支持或未测试 经过我测试,的确在安装时会遇到依赖的错误所以干脆将Centos6 换成Centos7 安装和设置仓库 官方教程 sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 这个仓库是官方的,如果太慢的换,换成阿里云镜像: 需要配置文件 可以自行百度 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装最新版的docker sudo yum install docker-ce docker-ce-cli containerd.io 若要安装特定版本 $ yum list docker-ce --showduplicates | sort -r docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stable docker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stable docker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stable docker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 例如要按照 docker-ce.x86_64 18.06.1.ce-3.el7 &lt;VERSION_STRING&gt; docker-ce-18.06.1 sudo yum install docker-ce-&lt;VERSION_STRING> docker-ce-cli-&lt;VERSION_STRING> containerd.io 开启docker sudo systemctl start docker 跑一个docker版的helloworld，类似于java的hello，测试是否安装成功 sudo docker run hello-world 安装mysql 从docker hub上查找mysql镜像 docker search mysql 从docker hub上拉取mysql,我拉取的mysql版本是mysql5.7 docker pull mysql:5.7 docker volume create mysql_data 创建数据挂载点（即存储数据的地方，这样即便mysql容器删除了，数据还是在） docker volume create mysql_data 运行mysql，开放的端口是3306，密码是root， -d是后台运行 docker run --name mysql -p 3306:3306 -v mysql_data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 docker ps 查看容器创建成功 进入mysql 的容器内 docker exec -it 容器的id /bin/bash 进入mysql, 当可以进入时,说明mysql 没问题了, 通过docker restart 镜像名 可以重启镜像 docker restart mysql 使用navicat 远程连接数据库 运行本地的.sql 文件, 将远程数据库中增加数据 将springboot项目打成jar包 注意将applicayion.yml中密码改成你服务器上mysql的密码 打包后在target下会生成一个jar包 编写Dockfile文件 在 /home 目录下创建docker文件夹 mkdir /home/docker 使用xftp上传jar包 编写Dockerfile文件 vim Dockerfile 完整命令, vim的使用方法：点击i开始编写，编写完后点击esc，点击冒号，输入wq保存 FROM java:8ADD emsdemo-0.0.2-SNAPSHOT.jar /emsdemo.jarEXPOSE 8081ENTRYPOINT [\"java\",\"-jar\",\"/emsdemo.jar\"] #注意，docker命令全部大写，这是规定。 # From 关键字表示，jar包依赖的环境。java:8 相当于jdk1.8 FROM java:8 #ADD命令 # emsdemo-0.0.2-SNAPSHOT.jar：这是你上传jar包的名称。 # /emsdemo.jar：这是自定义的名称。但是注意要有之前的/ ADD emsdemo-0.0.2-SNAPSHOT.jar /emsdemo.jar #MAINTAINER 作者名称。可以删除不写。 MAINTAINER Sizaif #EXPOSE 项目暴露的端口号 EXPOSE 8080 #/blog.jar此处的名称要和ADD命令后面的一样。 ENTRYPOINT [\"java\",\"-jar\",\"/emsdemo.jar\"] 在docker文件夹下执行如下命令 docker build -t emsdemo:1.0 . 运行镜像 docker run -it --net=host --name emsdemo -d -p 80:8081 emsdemo:1.0 至此全部完成. 在浏览器访问就可以了","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Springboot","slug":"技术向/Springboot","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Springboot/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.sizaif.com/tags/Springboot/"}],"author":"sizaif"},{"title":"在windows上安装Microsoft SEAL","slug":"在windows上安装Microsoft-SEAL","date":"2021-08-11T14:04:10.000Z","updated":"2021-09-19T10:13:59.342Z","comments":true,"path":"posts/6b27b8ff/","link":"","permalink":"https://www.sizaif.com/posts/6b27b8ff/","excerpt":"","text":"@auther by sizaif 在windows上安装Microsoft SEAL Note！说明 安装的版本为3.6 需要环境 Visual Studio 2019 with C++ CMake Tools for Windows 1. git 项目文件 git clone https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;SEAL.git 2. 以管理员打开VS2019打开SEAL文件夹 打开后，VS会自动运行cmake配置 Visual Studio will detect that this is a CMake-based project and will enable the menu command Project / CMake settings for SEAL. This will open the CMake settings editor that provides a user interface where you can create different configurations and set different CMake options. 3. VS里打开终端powershell 因为VS2019是以管理员打开的，所以打开的终端也是带有管理员权限的 4. 在终端中依次输入 cmake -S . -B build cmake --build build cmake --install build 或者采用 #Generate and build for x64 in Release mode cmake -S . -B build -G &quot;Visual Studio 16 2019&quot; -A x64 cmake --build build --config Release cmake --install build 如果成功，则默认安装的C:/Program Files(x86)/SEAL/目录下 或者直接打开 x64 Native Tools 进入到你的从github上下载的SEAL文件夹位置 依次输入以下命令 cmake -S . -B build -G Ninja cmake --build build cmake --install build 如果不出问题出现下面图片,则安装完成","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"},{"name":"Win","slug":"Win","permalink":"https://www.sizaif.com/tags/Win/"}],"author":"sizaif"},{"title":"线性表(链表)题目算法题目整理(附代码)","slug":"线性表-链表-题目算法题目整理-附代码","date":"2021-08-11T14:01:59.000Z","updated":"2021-09-19T10:14:15.029Z","comments":true,"path":"posts/41ebddd6/","link":"","permalink":"https://www.sizaif.com/posts/41ebddd6/","excerpt":"","text":"@auther by sizaif 说明： 部分题目为王道题目整理，(ps.王道上思路没问题，在实现代码上略有些问题) 因个人代码风格与王道略有不同，部分细节代码也不尽相同 个人整理by sizaif @TOC 链表： //单链表结构 typedef struct link&#123; int data; link *next; &#125;node,*linklist; 1) 输入一组整型元素序列，使用尾插法(头插法)建立一个带有头结点(不带头结点)的单链表。 code /** * 建立带头结点的单链表 * @param L [description] */ void Creat_list_Head(linklist &amp;L) &#123; L = new node(); linklist p,s=L; L->next=NULL; int x; /*while(cin>>x,x>0)// 头插 &#123; p= new node(); p->data =x; p->next=L->next; L->next=p; &#125;*/ while(cin>>x,x>0)//尾插 &#123; p=new node(); p->data=x; s->next=p; s=p; &#125; &#125; void Creat_list_withoutHead(linklist &amp;L)&#123; L = NULL; linklist p,s; int x; /* while(cin>>x,x>0)// 头插 &#123; p= new node(); p->data =x; p->next=L; L=p; &#125; */ while(cin>>x,x>0)&#123; // 尾插 p = new node(); p->data = x; p->next = NULL; if(L==NULL) L = p; // 第一个结点 else&#123; s = L; while(s->next)&#123; // 遍历到最后一个结点 s = s->next; &#125; s->next = p; &#125; &#125; &#125; 2) 在该单链表的第i个元素前插入一个整数。(从0开始) code ++/** * 在 单链表 第x个位置 前插入y * @param L [description] * @param x [description] * @param y [description] * @return [description] */ void Add_before_X(linklist &amp;L,int x,int y) &#123; linklist p,s; p=L->next; int j=0; while(p&amp;&amp;j&lt;x-1) &#123; p=p->next;j++; &#125; if(!p||j>x-1)&#123;cout&lt;&lt;\"error\"&lt;&lt;endl;return;&#125; s=new node(); s->data=y; s->next=p->next; p->next=s; &#125; 3) 删除该单链表中的第i个元素，其值通过参数将其返回(从0开始)。 code ++/** * 删除单链表中第i个元素 的结点 * @param L [description] * @param i [description] */ void Delet_x(linklist &amp;L,int &amp;i) &#123; linklist s,p; p=L->next; int j=0; while(p&amp;&amp;j&lt;i-1) &#123; p=p->next; j++; &#125; i = p->data; s = p->next; p->next=s->next; &#125; 4) 建立两个按值递增有序的带头结点的单链表，将他们合并成一个按值递减有序的单链表。 code ++/** * 思路： 归并， 头插法 */ linklist Union(linklist la,linklist lb)&#123; linklist p,q,r,rear,t; p = la->next,q = lb->next; la->next = NULL; r = la; // r重构la while( p &amp;&amp; q)&#123; if( p->data &lt; q->data)&#123; rear = p->next; p->next = r->next; r->next = p; p = rear; &#125;else if( p->data > q->data)&#123; rear = q->next; q->next = r->next; r->next = q; q = rear; &#125; else &#123; // 当两个值相同时,(按题目要求两个都保留, 另外一个free掉) rear = q->next; t = p ->next; p->next = r->next; r->next = p; q->next = r->next; r->next = q; // free(q); q = rear; p = t; &#125; &#125; while(p)&#123; // 因为是倒叙, 所以必须 逐步遍历头插剩余部分 rear = p->next; p->next = r->next; r->next = p; p = rear; &#125; while(q)&#123; rear = q->next; q->next = r->next; r->next = q; q = rear; &#125; return la; &#125; plus-两个单调递增有序的单链表A B 合并成一个单调递增有序的单链表C code ++/** * 两个单调递增有序的单链表A B 合并成一个单调递增有序的单链表C * @param L [description] * @param B [description] */ void Merage_A_B(linklist &amp;A,linklist &amp;B,linklist &amp;C) &#123; linklist pa,pb,pc; pa = A->next; pb = B->next; pc = new node(); pc ->next =NULL; while(pa&amp;&amp;pb) &#123; if(pa->data &lt;= pb->data)&#123; pc->next = pa; pc = pa; pa = pa->next; &#125;else&#123; pc ->next = pb; pc = pb; pb = pb->next; &#125; &#125; // 尾插 pc ->next = pa? pa:pb; &#125; 5) 试编写算法将带头结点的单链表就地逆置，所谓“就地”是指辅助空间复杂度为O(1)。 (计.期末.10.1) 头插重新建表 指针反转 顺序存储 数组 code ++//法一：头插法从新建表 void reverse(linklist &amp;L)&#123; linklist p,rear; // rear 为p的后继 防止断链 p = L->next; L->next = NULL; // 头结点的Next 置为null while(p)&#123; rear = p->next; // 头插法 p->next = L->next; L->next = p; p = rear; &#125; &#125; //法二：指针反转 void reverse(linklist &amp;L)&#123; LinkList temp,p,q; temp = NULL; p = L->next; q = L->next->next; while(q!=NULL)&#123; temp = q->next; // 暂存q-Next q->next = p; // 指针逆置 p = q; // 往后移 q = temp; &#125; L->next->next=NULL; // 第一个结点变成最后一个结点 L->next = p; // 最后一个结点变成第一个结点 &#125; //法三： 顺序存储 数组 void reverse(int A[],int n)&#123; for(int i = 0 ; i &lt; n/2 ; i++)&#123; temp = A[i]; A[i] = A[n-i-1]; A[n-i-1] = temp; &#125; &#125; 6) 将一个头指针为head且不带头节点的单链表改造为一个含头节点且头指针为head的单循环链表 (计.期末.09.1) code ++//没有单循环-> head->next = head; 改造为带头结点的 void fun(LinkList &amp;head)&#123; LinkList p; p = new LinkNode(); if(head == NULL)&#123; head = p; p->next = p; // 单循环 &#125;else&#123; p->next = head; // 创造头结点 // 单循环列表 Linklist t = head; while(t->next != NULL)&#123; t = t->next; &#125; t->next = p; // 最后一个结点指向头结点 head = p; // 将p 赋给 head 变成head链表 &#125; &#125; 7) 假设有两个按元素值递增次序排列的线性表，均不带头结点以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值递减(非递减)次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表 (计.期末.08.2) !!! code ++linklist merge_without_Head(linklist la,linklist lb)&#123; linklist lc = NULL,lce = NULL; while(la &amp;&amp; lb) &#123; if( la->data &lt;= lb->data)&#123; if(!lc) lc = la; else &#123; lce->next = la; &#125; lce = la; la = la->next; &#125;else&#123; if(!lc) lc = lb; else &#123; lce->next = lb; &#125; lce = lb; lb = lb->next; &#125; &#125; if(lc)&#123; if(la) lce ->next = la; else lce ->next = lb; &#125;else &#123; if(la ) lc = la; else lc = lb; &#125; return lc; &#125; 8) 给定一个带表头结点的单链表A分解为两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变 code ++void div(linklist &amp;A,linklist &amp;B)&#123; linklist p,pc,pb,temp,Lc; p = A->next; Lc = new node(); Lc->next = NULL; pc = Lc; pb = B; int i = 1; while(p)&#123; temp = p->next; // 保存后继防止断链 if(i%2==1)&#123; //尾插 p->next = pc->next; pc->next = p; pc = p; &#125;else &#123; //尾插 p->next = pb->next; pb->next = p; pb = p; &#125; p = temp; i++; &#125; A = LC; &#125; 9) 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点(统计值等于x的数目) int CountX(Lnode * HL, ElemType x) code ++void del(LinkList &amp;L,ElemType x)&#123; LinkList temp; // 做释放用 if(L==NULL) return; // 结束条件 if(L->data == x)&#123; temp = L; L = L ->next; free(t); del(L,x); &#125;else&#123; del(L->next,x); &#125; &#125; // 递归统计 int ct = 0; void count(LinkList &amp;L,ElemType x)&#123; if(L == NULL) return; if(L->data == x) ct++; count(L->next,x); &#125; 10) 在带头结点的单链表L中，删除所有值为x的结点，并释放空间，假设值为x的结点不唯一，试编写算法以实现上述操作。 code ++void del_x(linklist &amp;L,int x)&#123; linklist p,temp,pre; p = L->next,pre = L; // pre 防止断链 while(p)&#123; if(p->data == x)&#123; temp = p; p = p->next; pre ->next = p; free(temp); &#125;else&#123; // 同时后移 pre = p; p = p->next; &#125; &#125; &#125; 11) 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值(头插法建表，遍历) code ++//法一： 一边遍历一边头插法建立新表 linklist create_head(linklist &amp;L)&#123; liklist newL,p,q; newL = new node(); newL->next = NULL; p = L->next; while(p)&#123; q = new node(); q->data = p->data; q->next = newL->next; newL->next = q; &#125; return newL; &#125; void Visit(linklist L) &#123; linklist p; p=L->next; while(p) &#123; printf(\"%d \",p->data); p=p->next; &#125; cout&lt;&lt;endl; &#125; 法二： // 采用递归输出 栈的思想 void R_p(linklist L)&#123; if(L->next != NULL)&#123; R_p(L->next); &#125; cout&lt;&lt;L->data&lt;&lt;\" \"; &#125; 12) 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小值结点时唯一的） code ++void delete_MinX(linklist &amp;L)&#123; linklist pre,p,minp,minpre; pre = L; p = L->next;// pre 指向前驱 minp = p,minpre = pre; while(p)&#123; // 遍历寻找最小值 if(p->data &lt;= minp->data)&#123; minp = p; minpre = pre; &#125; pre = p; p = p ->next; &#125; // 删除minp 结点 minpre->next = minp->next; free(minp); &#125; 13) 有一个带头结点的单链表L，设计一个算法使其元素递增有序 code ++// 空间换时间O(n^2) 考的概率不大 void sort(linklist &amp;L)&#123; linklist p,pre,rear; p = L->next; rear = p->next; // rear 保留p后面的链表保证不断链 p->next = NULL; // 让 L 只有一个结点， 重构 L p = rear; // 遍历剩下的内容链表 while(p)&#123; rear = p->next; pre = L; while(pre->next!= NULL &amp;&amp; pre->next->data &lt; p->data)&#123; // 在新L中找到p->data应该的位置 pre = pre->next; &#125; p->next = pre->next; // 尾插法 把 p 插入到新L 中 pre -> next = p;// 尾插法 把 p 插入到 新L 中 p = rear; // 继续遍历 旧L 剩下的内容 &#125; &#125; 14) 设在一个带表结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值（作为函数参数给出）之间的元素的元素（若存在） 数字之间，字母之间等问题 code ++void delete_between(linklist &amp;L,ElemType x,ElemType y)&#123; linklist p,pre,temp; p = L->next; pre = L; while(p)&#123; if(p->data >= x &amp;&amp; p->data &lt;= y)&#123; // 如果介于之间 // 删除 pre->next = p->next; free(p); p = pre->next; &#125;else&#123; // 否则继续遍历 pre = p; p = p->next; &#125; &#125; &#125; ## 15) **给定两个单链表，编写算法找出两个链表的公共结点。** 掌握解题思想，先走k步，然后一同走， code ++// 公共结点指， 两个链表从某一结点开始， next都指向同一个节点 Y型 // 长的先走k步,然后一同走,第一个相同的结点即为公共结点初始点 linklist Common(linklist A,linklist B)&#123; linklist pa,pb; int lena = 0 ,lenb = 0,k; pa = A->next; pb = B->next; // 求lena lenb while(pa)&#123; lena++;pa=pa->next; &#125; while(pb)&#123; lenb++;pb=pb->next; &#125; // 长链赋给 pa 断链 赋给 pb if(lena>lenb) &#123; k = lena-lenb; pa = A->next; pb = B->next; &#125;else&#123; k = lenb-lena; pa = B->next; pb = A->next; &#125; // 先走k步 while(k--) pa = pa->next; // 同时走，第一个相同的结点即为公共链的起点 while(pa)&#123; if( pa->data == pb->data)&#123; return pa; &#125;else &#123; pa = pa->next; pb = pb->next; &#125; &#125; return NULL; &#125; 16) 给定一个带表头结点的单链表，设head为头指针，结点的结构为（data，next），data为整形元素，next为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间 (注意)：不允许使用数组作为辅助空间） code ++// 每次寻找最小的结点输出 O(n^2) // pre记录的是最小值的前驱，pre->next 既为最小值结点 // p 相等于记录的是最小值结点 // 每次比较的是 p->next->data 与 pre->next->data； 即 最小值后一个结点与最小值结点 void fun(linklist &amp;Head)&#123; while(Head->next!=NULL)&#123; linklist pre,p,temp; pre = Head;p = pre->next; // 寻找最小值结点 while(p->next!=NULL)&#123; // pre->next为最小值结点， p->next为最小值结点后继一个结点 if(p->next->data &lt; pre->next->data )&#123; pre = p; //updata &#125; p = p->next; &#125; cout&lt;&lt;pre->next->data&lt;&lt;endl;//输出最小结点值 // 释放空间，free，并保证不断链 p = pre->next; // pre->next = p->next;//保正不断链 free(p); &#125; free(Head); &#125; 17) 设C={a1,b1,a2,b2…,an,bn}为线性表，采用带头结点的hc单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A={a1,a2,…,an} B={bn,…,b2,b1} code ++// 思想： A存放的是奇数位置，尾插法 ； B存放的是偶数位置，头插法 void fun2(linklist &amp;L)&#123; linklist la,lb,pl,pa,pb,temp; la = new node();lb = new node(); la->next = NULL,lb->next = NULL; pa = la;pb = lb; pl = L->next; int i = 0; while(pl)&#123; i++; temp = pl->next; // 保存后继结点，防止断链 if(i%2==1)&#123; // A采用尾插法 pl->next = NULL; // 很重要,保证尾必为null pa->next = pl; pa = pl; &#125;else&#123; // B采用头插法 pl->next = pb->next; pb->next = pl; &#125; pl = temp; &#125; Visit(la); Visit(lb); &#125; 18) 在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素。例如（7,10,10,21,30,42,42,42,51,70）将变作（7,10,21,30,42,51,70） code ++// 递增有序， 相同的挨着， 一个pre 一个 p 比较p->next是否和pre->next 相同 // 相同删除 p结点 O(N) void delete_same(linklist &amp;L)&#123; linklist pre,p,temp; pre = L;p = pre->next; while(p->next!=NULL)&#123; temp = p->next; // 防止断链 if(p->next->data == pre->next->data)&#123; pre->next = p->next; free(p); &#125;else&#123; pre = p; &#125; p = temp; &#125; &#125; 19) 设A和B是两个单链表（带头结点），其中元素递增有序，设计一个算法从A和B中公共元素产生单链表C，要求不破坏A B 的结点 code ++//有序 C中元素即是A的也是B的 尾插建链表即可 void fun3(linklist &amp;A,linklist &amp;B)&#123; linklist C,pa,pb,pc,temp; C = new node(); C->next = NULL; pc = C; pa = A->next,pb = B->next; while(pa &amp;&amp; pb)&#123; // 小折后移 if( pa->data &lt; pb->data)&#123; pa = pa->next; &#125;else if( pa->data > pb->data)&#123; pb = pb->next; &#125;else &#123; // 相同值 temp = new node(); temp->data = pa->data; pc->next = temp; /* 如果这样写就会出现图2的情况 pc->next = pa; pc = pa; */ pc = temp; // 同时后移 pa = pa->next; pb = pb->next; &#125; &#125; Visit(C); &#125; 20) 已知两个链表A和B分别表示两个集合，其元素递增排列。绘制函数，求A与B的交集，并存放于A链表中。 code ++// 有序， 相同存入，AB同时后移， 不同，小者后移 void fun4(linklist &amp;A,linklist &amp;B)&#123; linklist pa,pb,pre,temp; pa = A->next;pb = B->next; pre = A; // pre 指向A 重构A链表 while(pa&amp;&amp;pb)&#123; // 小者后移 if( pa->data &lt; pb->data)&#123; pa = pa ->next; &#125;else if(pa->data > pb->data)&#123; pb = pb->next; &#125;else&#123; // 相等时存入， temp = new node(); temp->data = pa->data; pre->next = temp; pre = temp; pa = pa->next; pb = pb->next; &#125; &#125; &#125; 21) 头指针分别为la,lb的带头结点的单链表中，结点按元素递增有序排列，将la和lb两个链表合并成按元素递增有序的单链表，要求不另外开辟空间，la作为合并后的单链表的头结点(951.Y19) code ++// 归并 原理与上题一致 linklist Union(linklist la,linklist lb)&#123; linklist p,q,r,s; p = la->next,q = lb->next; r = la; // r重构la while( p &amp;&amp; q)&#123; if( p->data &lt; q->data)&#123; r->next = p; r = p; p = p->next; &#125;else if( p->data > q->data)&#123; r->next = q; r = q; q = q->next; &#125; else &#123; r->next = p; r = p; p = p->next; s = q->next; free(q); q = s; &#125; if(p) r->next = p; else if(q) r->next = q; &#125; return la; &#125; 22) 两个整数序列A=a1,a2,a3,…,am和B=b1,b2,b3,…,bn已经存入两个单链表中，设计一个算法，判断序列B是否是序列A的连续子序列 code ++/* * 模式匹配 链表实现 一般算法 O(n^2) * 带头结点, 当相同时，同时后移，， 当不相同时，B从头开始，A后移一个 * 判断条件： 如果B跑完说明匹配完成，否则不存在 */ int Pattern(linklist A,linklist B)&#123; linklist pa,pb,pre; pa = A->next,pb = B->next; pre = A->next; while(pa&amp;&amp;pb)&#123; // 相同，同时后移 if(pa->data == pb->data)&#123; pa = pa->next; pb = pb->next; &#125;else&#123; // 不相同 A后移 pre = pre->next; pa = pre; // A后移一个结点后从新匹配， pb = B->next; // B从头开始 &#125; &#125; return pb == NULL? 1:0; // 如果pb 跑完说明匹配完成存在 &#125; 23) 设计一个算法用于判断带头结点的循环双链表是否对称 code ++/* * 对称指 设各元素值 a1,a2,...,an, 则有 ai=an-i+1 ， * 即指： a1= an ， a2= an-1 。。。。。。。 * p 从头， q 从尾 当两个相同时，p后移，q前移，一旦不同则break， * 结束条件 p==q |｜p->next = q; */ int flag1(linklist L)&#123; linklist p,q; p = L->next; p = L->prior; int flag = 1; // 初始默认对称 while(p!=q &amp;&amp; p->next != q )&#123; if( p->data == q->data)&#123; p = p->next; q = q->prior; &#125;else &#123; flag = 0; break; &#125; &#125; return flag; &#125; 24) 有两个循环单链表，链表头指针分别为h1和h2，编写一个函数将链表h2链接到链表h1之后，要求链接后的链表仍保持循环链表形式。 code ++/** * */ void fun5(linklist &amp;h1,linklist &amp;h2)&#123; linklist p,q; p = h1,q = h2; while(p->next != h1)&#123; p = p->next; &#125; while(q->next != h2)&#123; q = q->next; &#125; p->next = h2; q->next = h1; &#125; 25) 设有一个带头结点的循环单链表，其结点值均为正整数。设计一个算法，反复找出单链表中结点值最小的结点并输出，然后将该结点从中删除，直到单链表为空位置，再删除表头结点 code ++/** * 同第16方法一致，这里为循环电单链表，判空条件需改变 */ void Del_all(linklist &amp;L)&#123; linklist p,pre,minp,minpre; // 没循环一次L减少一个结点，当L->next为L时，说明全部删完 while(L->next! = L)&#123; p = L->next;pre = L; minp = p, minpre = pre; // 找到最小结点 while(p->next != L)&#123; // 循环单链表 // 找到最小结点 if( p->data &lt; minp->data)&#123; minp = p; minpre = pre; &#125;else&#123; pre = p; p = p->next; &#125; &#125; //free minp cout&lt;&lt;minp->data&lt;&lt;endl; minpre->next = minp->next; // 删除节点保证不断链 free(minp); &#125; free(L); &#125; 26) 已知带头结点单链表，头指针list，不改变链表的前提下设计高效的算法，查找链表中倒数第k个位置上的节点的值(408.Y09) code ++/** * 掌握思想很重要，O(n)内实现 * 两个指针p,q， p先走k步，然后p,q一起走，当p到时，q即为倒数第k个位置 * 有可能会出现 k 大于表长的情况,需要判断 */ int fun6(linklist list,int k)&#123; linklist p,q; p = list->next; q = list->next; int i = 1; while(p)&#123; // p 走k步 if(i &lt;= k) &#123; i++; &#125; else&#123; // p,q 同时走 q = q->next; &#125; p = p->next; &#125; // k > n if( i &lt; k)&#123; return 0; &#125; cout&lt;&lt;q->data&lt;&lt;endl; // 此时q->data即为倒数第k个位置 return 1; &#125; 27) 假定采用带头结点的单链表保存单词,当两个单词有相同的后缀时,可共享相同的后缀存储空间,例如,“ loading”和&quot; being”的存储映像如下图所示(408,Y12) 设str1和str2分别指向两个单词所在单链表的头结点,链表结点结构为 data next请设计一个时间上尽可能高效的算法,找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符主所在结点的位置p)。要求 code ++/** * 求公共后缀, 求strlen(str1),strlen(str2); * 求差k， 大者先走k步， 然后同时走，第一个相等的即为公共后缀起点 */ typedef struct link&#123; char data; link *next; &#125;node,*linklist; linklist Common2(linklist str1,linklist str2)&#123; linklist p,q,s,l; p = str1->next,q = str2->next; int len1 = 0,len2 = 0,k; while(p)&#123; p = p->next,len1++;&#125; // 求str1长度 while(q)&#123; q = q->next,len2++;&#125; // 求str2长度 // 让 s指向短链 ；l指向长链 if(len1 &lt; len2)&#123; k = len2 - len1; s = str1->next; l = str2->next; &#125; else&#123; k = len1 - len2; s = str2->next; l = str1->next; &#125; while(k--)&#123; // 或者 for(int i = 0 ;i &lt; k ;i++) l = l->next; &#125; while(s&amp;&amp;l)&#123; if( s->data == l->data)&#123; return s; // 返回s的起始位置,此时s->data即为第一个相同元素(不带头结点) /* 此时返回的是带头结点的 linklist temp = new node(); temp->next = s; return temp; */ &#125;else&#123; s = s->next; l = l->next; &#125; &#125; return new node(); &#125; 28) 用单链表保存m个整数,结点的结构为data,link,|data|≤n(n为正整数)。现要求设计一个时间复杂度尽可能高效的算法,对于链表中data的绝对值相等的结点,仅保留第一次出现的结点而删除其余绝对值相等的结点。例如,若给定的单链表head如下:(408,Y15) code ++/** * 删除重复结点,无序 * 建立一个map索引,存放data,如果不存在则,链表跳过，否则删除这个结点， * 这里求的是|data| 所以索引用数组即可 * 时间O(m),空间O(n) * */ void fun6(linklist &amp;Head,int n)&#123; linklist p,pre; int vis[n+1]; // 初始化vis 标记为0; memset(vis,0,sizeof(vis)); p = Head->next;pre = Head; while(p)&#123; // 第一次存在，跳过(保留) if(!vis[abs(p->data)])&#123; vis[abs(p->data)] = 1; pre = p; p = p->next; &#125;else&#123; //重复 pre->next = p->next; free(p); //释放 p = pre->next; // 删除p后,保证不断链 &#125; &#125; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"算法","slug":"技术向/算法","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"技术向/C","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://www.sizaif.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"sizaif"},{"title":"循环右移K位问题的思考，几种方法的解决","slug":"循环右移K位问题的思考，几种方法的解决","date":"2021-08-11T14:01:57.000Z","updated":"2021-09-19T10:14:05.924Z","comments":true,"path":"posts/c1919217/","link":"","permalink":"https://www.sizaif.com/posts/c1919217/","excerpt":"","text":"@auther by sizaif 循环右移K位问题 @TOC 试用顺序存储结构设计一个算法，仅用一个辅助结点，实现将线性表中的结点循环右移k位的运算，并分析，算法的时间复杂度． 方法一: mod移位思想 图一： /** * 思路: * 运用mod的思想, 将n复制成2n的数组 如图一所示; 那么循环有移 逃不出2n内 * 右移后的结果为： (i+k) 缩到n内的话 就是 (i+k)%n * 实际上只需要用另外一个数组B[] 来存取 原数组A[] 的内容 即 B[i] = A[(i+n-k)%n]; * 但是 这样的话 空间复杂度就为 O(n), 时间复杂度为 O(n); */ for(int i = 0; i&lt; n ;i++) &#123; b[ i ] = a[ (i + n - k)%n]; &#125; 方法一plus： 会出现如下的情况： 改进-最大公约数GCD /** * 将方法加以改进 * 将其按照 k 步进行分组， 类似于希尔排序的思想， 每间隔k的位置构成一组，那么我们 * 的所谓右移只是在这每一组中组内移动，类似下图 * 那么我们只需要确定我们要循环几次就可以找到答案呢？ * 答案是确定的只需要找到他们的 gcd ， * 然后记录下开始位置，采用 反求x的方法 即 （x+k)%n = t, t,n,k已知 求未知数x * x = (t+n-k)%n; 当 x == 开始位置时停止,进入下一组 * 时间复杂度O(n) , 空间复杂度O(1) */ int Gcd(int a,int b)&#123; return b==0?a:Gcd(b,a%b); // 辗转相除法求GCD &#125; void fun(int a[],int n,int k)&#123; int gcd = Gcd(n,k); int t,temp,j; for(int i = 0 ;i &lt; gcd; i++) &#123; temp = a[i]; // 记录开始位置 t = i; while(1)&#123; j = ( t + n - k )%n; if( j == i) break; // 循环到自己跳出 a[t] = a[j]; t = j; &#125; a[t] = temp; &#125; &#125; ==验证：== 方法二：倒叙移位 /** ``````````````````````分割线`````````````````````````````` * 将空间复杂度降到O(1) * 所以考虑只用一个辅助结点的优化方法 * * 第一种 循环k次， 从后面开始移动， 空间复杂度为O(1) ,但时间复杂度为 O(kn) * */ for(int i = 0; i &lt; k; i++)&#123; int temp = a[n - 1]; for(int j = n-1; j > 0; j --)&#123; a[j] = a[j-1]; &#125; a[0] = temp; &#125; 方法三：递归调用 /** ``````````````````````分割线`````````````````````````````` * 将空间复杂度降到O(1) * 所以考虑只用一个辅助结点的优化方法 * * 第二种 采用递归反转的方式 空间复杂度为O(1) ,时间复杂度为 O(n) * 先递归反转前 （n-k)位 在反转后 k位 最后 全部反转 */ void reverse(int a[],int l,int r)&#123; for(; l &lt; r; l++,r--) &#123; int temp = a[l]; a[l] = a[r]; a[r] = temp; &#125; &#125; int main()&#123; reverse(a,0,n-k-1); reverse(a,n-k,n-1); reverse(a,0,n-1); return 0; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"算法","slug":"技术向/算法","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"技术向/C","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://www.sizaif.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"sizaif"},{"title":"小米青春版路由器解锁root与SSH方法","slug":"小米青春版路由器解锁root与SSH方法","date":"2021-08-11T14:01:56.000Z","updated":"2021-08-14T14:15:24.810Z","comments":true,"path":"posts/e5a81842/","link":"","permalink":"https://www.sizaif.com/posts/e5a81842/","excerpt":"","text":"@auther by sizaif @TOC 前期准备 小米路由器 x1; 宽带线x1(连接路由器和电脑), 思路 因为小米青春版路由器没有USB插口,只能通过先刷开发版,再通过开发版来开启ROOT和SSH 下载开发版本ROM包 版本(miwifi_r1cl_all_59371_2.1.26.bin) 更高版本已经修复了此方法,所以只能是此版本 下载地址1: 百度W盘: e2p6 登录后台手动升级系统 后台地址: 192.168.1.1 进入后台后,系统升级,手动选择,选择对应的ROM包,等待5-8分钟左右,路由器会自动升级,重启 本地以太网设置手动IP地址为192.168.31.2 进入后台192.168.31.1进行引导 此过程中会设置Wifi名称密码,以及管理员密码, 注意!: 管理员密码很重要,后面会用到 地址栏开启ROOT和ssh 进入后台后,浏览器地址内会出现 http://192.168.31.1/cgi-bin/luci/;stok=09a506ee0b8e14d4acf3004a504eba4d/web/home#router 这样的信息, 我们将URL中 /web/home#router 修改为/api/xqsystem/set_name_password?oldPwd=前面设置的管理员密码&amp;newPwd=新的管理员密码 注意:新密码与旧密码不能一致 回车后: 如果成功则返回{“code”:0}, 如果是其他参数,请检查软件包是否为:59371_2.1.26 测试 电脑连接路由器的情况下,控制台: ssh root@192.168.31.1 第一次登录会提示存储密钥,yes即可","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"路由器","slug":"技术向/路由器","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://www.sizaif.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"author":"sizaif"},{"title":"小米青春版使用OpenWrt实现无线中继功能","slug":"小米青春版使用OpenWrt实现无线中继功能","date":"2021-08-11T14:01:54.000Z","updated":"2021-08-14T14:15:24.808Z","comments":true,"path":"posts/57997d7/","link":"","permalink":"https://www.sizaif.com/posts/57997d7/","excerpt":"","text":"@auther by sizaif @TOC 简介 因为小米路由器自带的后台无线功能太鸡肋了, 无法实现自定义设置DCHP,默认为DCHP分配IP,但是分配的IP地址和主路由器在同一个字段,当设备多时会造成IP冲突现象.所以将机器刷机成Openwrt后实现需要的功能 小米青春版OpenWrt刷机 一解锁SSH与Root 参考文章链接:小米青春版路由器解锁root与SSH方法 刷入OpenWrt包 使用有线连接电脑和路由器 下载地址: 1: 重命名包名为 1.bin 2: 将下载的文件拷贝到路由器中 /tmp目录下 使用CMD控制台命令: (为了方便,可以把文件放到我的文档里, ip地址应该为192.168.31.1, 如果第一次刷完机) 1: scp 1.bin root@192.168.31.1:/tmp/ 3: 刷机 进入路由器内部/tmp/目录下: ssh root@192.168.31.1 开始刷机 cd /tmp/ mtd -r write 1.bin firmware 等待一会后路由器会重启 刷机完成 浏览器进入路由器后台","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"路由器","slug":"技术向/路由器","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"路由器","slug":"路由器","permalink":"https://www.sizaif.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"author":"sizaif"},{"title":"二叉树题目算法题目整理(附代码)","slug":"二叉树题目算法题目整理-附代码","date":"2021-08-11T14:01:48.000Z","updated":"2021-09-19T10:14:26.591Z","comments":true,"path":"posts/cfa0d73d/","link":"","permalink":"https://www.sizaif.com/posts/cfa0d73d/","excerpt":"","text":"@auther by sizaif 说明： 由个人整理，部分题目是王道的题目,已经经常会考的点。 因个人代码风格,已经stack和queue的代码实现不同,代码略有不同之处， 但总体思想是正确的 有错误之处,欢迎指出 by sizaif @TOC 二叉树 code ++/** * 树结构 */ typedef struct Node&#123; char x; struct Node *lson,*rson; &#125;Tree,*BiTree; typedef struct Queue&#123; //自己构造队列 BiTree *x; int front; int rear; void Initqueue() &#123; front=rear=0; x =(BiTree *)malloc(MAX*sizeof(Tree)); &#125; void POP() &#123; front=(front+1)%MAX; &#125; int length() &#123; return (rear-front +MAX)%MAX; &#125; bool emptys() &#123; if(front==rear) return 1; return 0; &#125; void Push_back(BiTree T) &#123; if((rear+1)%MAX==front) return; x[rear]=T; rear=(rear+1)%MAX; &#125; BiTree Getfront() &#123; if(front==rear) return NULL; BiTree T; T = x[front]; return T; &#125; &#125;queues; typedef struct Stack&#123; // 自己构造栈 BiTree *tt; int top; int size; void InitStack() &#123; tt= ( BiTree *)malloc(n*sizeof(Tree)); top=0; size=n; &#125; bool emptys() &#123; if(top==0) return true; return false; &#125; void Push_back(BiTree num) &#123; tt[top++]=num; &#125; void Pop() &#123; if(top==0)return; top--; //num=x[--top]; &#125; BiTree Gettop() &#123; if(top==0) return NULL; return tt[top-1];// top &#125; &#125;stacks; 1) 采用下列方法之一建立二叉树的二叉链表： a) 输入完全二叉树的先序序列，用#代表虚结点（空指针），如ABD###CE##F##，建立二叉树的二叉链表。 code ++/** * 先序建立 * @param T [description] */ void build_frist(BiTree &amp;T) &#123; char ch; scanf(\"%c\",&amp;ch); if(ch=='#') T=NULL; else &#123; T= new Tree ; T->x=ch; build_frist(T->lson); build_frist(T->rson); &#125; &#125; b) 已知二叉树的先序遍历序列和中序遍历序列。 code ++/** * [pre_mid_build 先序+中序建立二叉树] * @param Fi [先序] * @param In [中序] * @param l1 [先序左端下标] * @param h1 [先序右端下标] * @param l2 [中序左端下标] * @param h2 [中序右端下标] * 初始 l1 = l2 = 0 , h1 = h2 = n; */ BiTree pre_mid_build(BiTree Fi[],BiTree In[],int l1,int h1,int l2,int h2) &#123; BiTree T = new Tree; T->data = Fi[l1]; for(int i = l2;In[i]!=Fi[l1] ; i++); int llen = i - l2; int rlen = h2 - i; if(llen) T->lchild = pre_mid_build(Fi,In,l1+1,l1+llen,l2,l2+llen-1); else T->lchild = NULL; if(rlen) T->rchild = pre_mid_build(Fi,In,h1-rlen+1,h1,h2-rlen+1,h2); else T->rchild = NULL; return T; &#125; /** * 已知先序和中序 建立二叉树 * @param T [description] * @param Fi [description] * @param In [description] * @param n [description] */ void build(BiTree &amp;T,char *Fi,char *In,int n) &#123; if(n&lt;1) &#123; T=NULL; return; &#125; int i=0,l1=0,l2=0,p=0,m=0; char lson[120],rson[120]; char str1[120],str2[120]; mem(lson,0); mem(rson,0); T= new Tree; T->x=Fi[0]; while(In[i]!=Fi[0]) i++; l1=i; l2=n-i-1; int temp=i; for(int j=1;j&lt;=temp;j++) lson[j-1]=Fi[j]; for(int j=temp+1;j&lt;n;j++) &#123; rson[j-temp-1]=Fi[j]; str2[j-temp-1]=In[j]; &#125; for(int j=0;j&lt;temp;j++) str1[j]=In[j]; if(!lson[0]) T->lson=NULL; else build(T->lson,lson,str1,l1); if(!rson[0]) T->rson=NULL; else build(T->rson,rson,str2,l2); &#125; void frist_and_mid() &#123; cout&lt;&lt;\"*****************************\"&lt;&lt;endl; BiTree T2; char str1[120],str2[120],str3[120]; printf(\"input of the first :\\n\"); scanf(\"%s\",str1); printf(\"input of the mid :\\n\"); scanf(\"%s\",str2); int len=strlen(str1); build(T2,str1,str2,len); printf(\"构造的二叉树 后序遍历为: \\n\"); query(T2,3); cout&lt;&lt;\"\\n*****************************\"&lt;&lt;endl; &#125; c) 已知二叉树的中序遍历序列和后序遍历序列，建立二叉树的二叉链表。 ++ 2) 写出对用二叉链表存储的二叉树进行先序、中序和后序遍历的递归算法 code ++/** * 三种递归 1先序 2中序与 3后序 * @param T [description] * @param oper [description] */ void query(BiTree T,int oper) &#123; if(T) &#123; if(oper==1) printf(\"%c \",T->x); query(T->lson,oper); if(oper==2) printf(\"%c \",T->x); query(T->rson,oper); if(oper==3) printf(\"%c \",T->x); &#125; &#125; 3) 写出对用二叉链表存储的二叉树进行先序遍历的非递归算法。 code ++/** * 非递归先序 * @param T [description] */ void query_frist(BiTree T) &#123; stacks S; S.InitStack(); S.Push_back(T); while(!S.emptys()) &#123; while(S.Gettop()!=NULL) &#123; printf(\"%c \",S.Gettop()->x); S.Push_back(S.Gettop()->lson); &#125; S.Pop(); if(!S.emptys()) &#123; BiTree Temp; Temp=S.Gettop(); S.Pop(); S.Push_back(Temp->rson); &#125; &#125; &#125; 4) 写出对用二叉链表存储的二叉树中序遍历的非递归算法。 code ++/** * 非递归中序 * @param T [description] */ void query_mid(BiTree T) &#123; stacks S; S.InitStack(); S.Push_back(T); while(!S.emptys()) &#123; while(S.Gettop()!=NULL) &#123; S.Push_back(S.Gettop()->lson); &#125; S.Pop(); if(!S.emptys()) &#123; BiTree Temp; Temp=S.Gettop(); printf(\"%c \",Temp->x); S.Pop(); S.Push_back(Temp->rson); &#125; &#125; &#125; 5) 写出对用二叉链表存储的二叉树后序遍历的非递归算法。 code ++/** * 非递归后序 * @param T [description] */ void query_last(BiTree T) &#123; stacks S; S.InitStack(); S.Push_back(T); while(!S.emptys()) &#123; while(S.Gettop()!=NULL) &#123; S.Push_back(S.Gettop()->lson); &#125; S.Pop(); if(!S.emptys()) &#123; if(S.Gettop()->rson) S.Push_back(S.Gettop()->rson); else &#123; BiTree Temp; Temp=S.Gettop(); printf(\"%c \",Temp->x); S.Pop(); while(S.Gettop()!=NULL&amp;&amp;!S.emptys()&amp;&amp;S.Gettop()->rson==Temp) &#123; printf(\"%c \",S.Gettop()->x); Temp=S.Gettop(); S.Pop(); &#125; if(!S.emptys()) &#123; S.Push_back(S.Gettop()->rson); &#125; &#125; &#125; &#125; &#125; /** * [PostOrder 后序遍历二叉树非递归] * @param T [Bitree] */ void PostOrder(BiTree T) &#123; InitStack(S); BiTree p = T; BiTree r = NULL; while(p || !IsEmpty(S))&#123; if(p) // 走到最左边 &#123; Push(S,p); p = p->lchild; &#125; else &#123; GetTop(S,p); if(p->rchild &amp;&amp; p->rchild != r) // 右子树存在且未被访问 &#123; p = p->rchild; // 转向右 Push(S,p);// 入栈 p = p->lchild; // 转向左 &#125;else&#123; Pop(S,p); visit(p->data); r= p ; p = NULL; &#125; &#125; &#125; &#125; 6) 写出对用二叉链表存储的二叉树进行层次遍历算法。 code ++/** * [Invertlevel 层次遍历,自下而上,自左到右] * @param T [BiTree] * 二叉树自下而上,自左到右 * 正常层次遍历, 出队时入栈 * 最后依次出栈为结果 */ void Invertlevel(BiTree T) &#123; Stack&lt;int> S; Queue&lt;int> Q; BiTree p; if(T) &#123; InitQueue(Q); InitStack(S); EnQueue(Q,T); while(!IsEmpty(Q)) &#123; DeQueue(Q,p); Push(S,p); // 出队,入栈 if(p->lchild) EnQueue(Q,p->lchild); if(p->rchild) EnQueue(Q,p->rchild); &#125; while(!IsEmpty(S)) &#123; Pop(S,p); visit(p->data); // 自下而上,自左到右 &#125; &#125; &#125; 7) 递归实现求二叉树的所有叶子数。 code ++/** * 求二叉树的所有叶子数] * @param T [description] */ void query_leaf(BiTree T)&#123; if(!T) return 0; if(T->lson == NULL &amp;&amp; T->rson == NULL) return 1; return query_leaf(T->lson)+query_leaf(T->rson); &#125; 8) 递归实现求二叉树的所有结点总数。 ++int query_node(BiTree T)// 节点总个数 &#123; if(!T) return NULL; if(T->lson == NULL &amp;&amp; T->rson == NULL) return 1; return query_node(T->lson) + query_node(T->rson) + 1; &#125; 8+) 求二叉树第k层的结点个数 code ++/** * 求二叉树第 k 层的结点个数 * 思想: 如图 * @param T [description] * @param k [第k层] * @return [description] */ int query_levelk(BiTree T,k)&#123; if(!T) return 0; if(k &lt;= 0) return 0; if(k &lt;= 1) return 1; return query_levelk(T->lson,k-1) + query_levelk(T->rsom,k-1); &#125; 9) 判断完全二叉树 code ++/** * 判断完全二叉树 * @param T [description] * @return [description] */ bool judge(Bitree &amp;T) &#123; //1 2 4 8 -1 -1 9 -1 -1 5 10 -1 -1 -1 3 6 -1 -1 7 -1 -1 queue&lt;Bitree>Q; Bitree pre; Q.push(T); while(Q.front() != NULL) &#123; pre = Q.front(); Q.pop(); Q.push(pre->lson); Q.push(pre->rson); &#125; while(!Q.empty()) &#123; pre = Q.front(); Q.pop(); if(NULL != pre) return false; &#125; return true; &#125; 10) 递归实现求 二叉树高度(深度) code ++/** * 二叉树高度 * @param T [description] * @return [description] */ int deep_tree(Bitree &amp;T) &#123; if(!T) return 0; int left = deep_tree(T->lson); int rig = deep_tree(T->rson); return left > rig ? (left+1):(rig+1); &#125; 11) 非递归求二叉树高度(深度)(利用层次遍历) code ++/** * [BtDepth 非递归求二叉树高度] * @param T [BiTree] * 数组模拟队列,level 记录层数, * 每次层次遍历出队列时,与last指针比较,若两者相同,则层数+1; */ void BtDepth(BiTree T) &#123; if(!T) return 0; int front = -1 , rear = -1; int last = 0 , level = 0; BiTree Q[MAXN]; Q[++rear] = T; BiTree p; while(front &lt;= rear) &#123; p = Q[++front]; if(p->lchild) Q[++rear] = p->lchild; if(p->rchild) Q[++rear] = p->rchild; if(front == last)&#123; // 该层最右结点 level++; last = rear; // 更新 &#125; &#125; &#125; 11+) 孩子兄弟表示法求树的深度 code ++/** * [Height_CS 孩子兄弟表示法求树的深度] * @param T [description] * @return [description] */ int Height_CS(CSTree T) &#123; int hc,hs; if(T == NULL) return 0; else &#123; hc = Height_CS(T->fichild); // 第一子树高 hs = Height_CS(T->nextchild); // 兄弟树高 return hc+1 > hs ? hc+1 : hs; &#125; &#125; 12) 判断平衡二叉数是否平衡 code ++/** * [judge_AVL 判断二叉排序树,是否平衡] * @param T [description] * @param balance [description] * @param h [description] * balanc = 1 平衡, 0 不平衡 * 空树 , 仅有根节点, 平衡 */ void judge_AVL(BiTree T,int &amp;balance ,int &amp;h) &#123; int bl = 0, br = 0, hl = 0 , hr = 0; if(T == NULL) // 空树 ,高度为 0 &#123; h = 0; balance = 1; &#125; else if(T->lchild == NULL &amp;&amp; T->rchild == NULL) // 仅有根节点, 高度为1 &#123; h = 1, balance = 1 ; &#125; else &#123; judge_AVL(T->lchild,bl,h1); judge_AVL(T->rchild,br,h2); h = (hl> hr ? hl:hr) +1; if(abs(hl-hr) &lt; 2) // 高度差 小于2 balance = bl &amp;&amp; br; //逻辑与 当左右都平衡时, 平衡 else balance = 0; &#125; &#125; 13) 递归实现求二叉树双分支节点树 code &#x2F;** * [DsonNode 递归实现求二叉树双分支节点树] * @param T [二叉链表] * @return [节点数] *&#x2F; int DsonNode(BiTree T) &#123; if(T&#x3D;&#x3D;NULL) return 0; else if(T-&gt;lchild !&#x3D;NULL &amp;&amp; T-&gt;rchild !&#x3D;NULL ) &#x2F;&#x2F; 左右孩子都有 return DsonNode(T-&gt;lchild) + DsonNode(T-&gt;rchild) +1; else return DsonNode(T-&gt;lchild) + DsonNode(T-&gt;rchild); &#125; 14) 递归实现左右孩子互换 code ++/** * [Swap_child 递归实现左右孩子互换] * @param T [description] * 先换T结点 左子树左右孩子 * 再换右子树, * 最后节点的孩子互换 */ void Swap_child(Bitree T) &#123; if(T) &#123; Swap_child(T->lchild); // 先左子树 Swap_child(T->rchild); // 右子树 Bitree temp = T->lchild; // 左右孩子互换 T->lchild = T->rchild; T->lchild = temp; &#125; &#125; 15) 删除二叉树中每个元素值 为x的结点 code ++/** * [Search 删除二叉树中每个元素值 为x的结点] * 并删去以他为根的子树 * @param T [description] * @param x [description] * 后序遍历二叉树, 层次遍历找到结点的父节点 */ void Search(BiTree T,ElemType x)&#123; BiTree Q[]; if(T) &#123; if(T->data == x) &#123; DeleteXTree(T); exit(0); &#125; InitQueue Q; EnQueue(Q,T); while(!IsEmpty(Q)) &#123; DeQueue(Q,p); if(p->lchild)&#123; // 左非空 if(p->lchild->data == x) // 左子树符合, 删除左子树 &#123; DeleteXTree(p->lchild); p->lchild = NULL; &#125; else // 父节点左子树置为空 EnQueue(Q,p->lchild); //左子女入队列 &#125; if(p->rchild) // 右子树符合, 删除右子树 &#123; if(p->rchild->data == x) &#123; DeleteXTree(p->rchild); p->rchild = NULL; &#125; else EnQueue(Q,p->rchild); // 右子女入队列 &#125; &#125; &#125; &#125; 16) 求先序遍历中第k个结点的值 code ++/** * [PreNode 求先序遍历中第k个结点的值] * @param Bt [description] * @param k [description] * @return [description] */ int count = 1; ElemType PreNode(BiTree T, int k) &#123; if(T == NULL) return '#'; if( count == k) return T->data; count++; ch = PreNode(T->lchild,k); // 左子树返回该值 if(ch != '#') return ch; ch = PreNode(T->rchild,k); // 右子树递归查找 return ch; &#125; 17) 求代权路径长度和 code ++/** * [Wpl_preOreder 求代权路径长度和] * @param T [description] * @param deep [description] * @return [description] * 2014 408 真题 , 王道127页 */ int Wpl(BiTree T) &#123; return Wpl_preOreder(T,0); &#125; int wpl = 0; int Wpl_preOreder(BiTree T,int deep) &#123; if(T->lchild == NULL &amp;&amp; T->rchild == NULL) // 叶节点 返回 wp wpl += deep * T->data; if(T->lchild != NULL) Wpl_preOreder(T->lchild,deep+1); if(T->rchild != NULL) Wpl_preOreder(T->rchild,deep+1); return wpl; &#125; 18) 求非空二叉树的宽度 code ++/** * [BTWidth 求非空二叉树的宽度] * @param T [description] * @return [description] * 层次遍历求所有点的层次,将所有节点和对应层次放在一个队列中 * 扫描队列,求最大层次节点总数 */ typedef struct&#123; BiTree data[MAXN];// 存放指针 int level[MAXN];//层次 int front,rear; &#125;Que; int BTWidth(BiTree T) &#123; BiTree p; Que.front = Que.rear = -1; Que.rear ++; Que.data[Que.rear] = T; // 入队 Que.level[Que.rear] = 1;// 层次为1; int k,Max,n; while(Que.front &lt; Que.rear) &#123; Que.front ++; // 出队 p = Que.data[Que.front]; k = Que.level[Que.front]; if(p->lchlid != NULL) // 左孩子进队列 &#123; Que.rear++; Que.data[rear] = p->lchlid; Que.level[rear] = k + 1; &#125; if(p->rchild!=NULL) // 右孩子进队列 &#123; Que.rear++; Que.data[rear] = p->rchlid; Que.level[rear] = k + 1; &#125; &#125; Max = -1, k = 1; int i = 0; while( i &lt; Que.rear) &#123; n = 0; while(i&lt;Que.rear &amp;&amp; Que.level[i] == k) &#123; // 统计第k曾节点数 n++; i++; &#125; k = Que.level[i]; if( n > Max) Max = n; &#125; return Max; &#125; 19) 判断两颗二叉树是否结构相同 code ++/** * [判断两个二叉树结构是否相等] * @param T1 [description] * @param T2 [description] * @return [description] */ int isEqual(BiTree T1,BiTree T2)&#123; if( !T1 &amp;&amp; !T2) return 1; if( !T1 || !T2) return 0; return isEqual( T1->lson,T2->lson) &amp;&amp; isEqual(T1->rson,T2->rson); &#125; 20) 求两个结点的最低(近)公共祖先结点 code ++/** * [求两个结点的最低公共祖先结点] * @param T [description] * @param A [description] * @param B [description] * @return [description] */ BiTree lowAnc(BiTree T,BiTree A,BiTree B)&#123; if( !T) return NULL; if( T == A || T == B) return T; // 说明在某左子树或右子树中找到目标结点 BiTree left = lowAnc(T->lson,A,B); BiTree right = lowAnc(T->rson,A,B); // 当在左子树和右子树中都找到A,B 说明是最近的公共祖先 if( left != NULL &amp;&amp; right != NULL) return T; //对一个底层向上更新的根结点来说，只在左子树或右子树找到了目标结点，则返回找到的结点。 return !left ? right:left; &#125; 20+) 求任意两结点距离 code ++/** * [求两个结点的最低公共祖先结点] * @param T [description] * @param A [description] * @param B [description] * @return [description] */ BiTree lowAnc(BiTree T,BiTree A,BiTree B)&#123; if( !T) return NULL; if( T == A || T == B) return T; // 说明在某左子树或右子树中找到目标结点 BiTree left = lowAnc(T->lson,A,B); BiTree right = lowAnc(T->rson,A,B); if( left != NULL &amp;&amp; right != NULL) // 当在左子树和右子树中都找到A,B 说明是最近的公共祖先 return T; return !left ? right:left; //对一个底层向上更新的根结点来说，只在左子树或右子树找到了目标结点，则返回找到的结点。 &#125; /** * [求最近公共祖先到目标p的距离] * @param T [description] * @param p [description] * @return [description] */ int CalDistance(BiTree T,BiTree p)&#123; if( !T ) return -1; if( T == p) return 0; // 先在左子树找 int res = CalDistance(T->lson,p); // 如果未找到,在右子树中找 if( res == -1) res = CalDistance(T->rson,p); // 找到, 距离+1 if( res != -1) return res + 1; // 如果带权值, 这里改成+权值 return -1; &#125; /** * [求树中A-B的距离] * @param T [description] * @param A [description] * @param B [description] * @return [description] */ int Dis_A_B(BiTree T,BiTree A,BiTree B)&#123; //找到最低公共祖先结点 BiTree lowanc = lowAnc(T,A,B); // 求最近最近公共祖先结点到两目标结点的距离之和 return CalDistance(lowanc,A) + CalDistance(lowanc,B); &#125; 20++) 找出二叉树中某个结点的所有祖先结点 code ++/** * 找出二叉树中某个结点的所有祖先结点 * @param T [description] * @param A [description] * @return [description] */ int FindAllAnc(BiTree T, BiTree A)&#123; // 未找到 if( !T ) return 0; // 找到目标结点 if( T == A) return 1; // 如果在左子树或右子树中找到输出此祖先结点 if( FindAllAnc(T->lson,A) || FindAllAnc(T->rson,A) ) &#123; // 或者其他操作 cout&lt;&lt;T->data&lt;&lt;endl; return 1; &#125; return 0; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"算法","slug":"技术向/算法","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"技术向/C","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://www.sizaif.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"sizaif"},{"title":"SpringBoot项目打包并发布到linux线上详细记录全过程,详细!","slug":"SpringBoot项目打包并发布到linux线上详细记录全过程-详细","date":"2021-08-11T14:01:46.000Z","updated":"2021-09-19T10:13:00.745Z","comments":true,"path":"posts/48019f05/","link":"","permalink":"https://www.sizaif.com/posts/48019f05/","excerpt":"","text":"@auther by sizaif @TOC 前期准备 一台线上linux服务器.阿里云,腾讯云,华为云或者国外的vps都可以 ssh工具,像xshell,putty sftp传输工具,像filezilla. 传输jar包文件 java jdk linux 安装包, 官网即可下载 使用Maven打包项目 处理静态文件以及端口号 如果引入了外部文件,像upload上传图片的功能, 需要设置目录为linux目录 一般在windows上开发,windows和linux不一样 application.yml配置 MVCconfig 写个java iimplements WebMvcConfigurer // 接入虚拟路径（解决重启服务器才显示图片的问题） // 拦截本地路径 @Value(\"$&#123;web.upload-path&#125;\") private String path; @Override public void addResourceHandlers(ResourceHandlerRegistry registry)&#123; // addResourceHandler: （ 存储图片的虚拟路径，在 static 目录下的 picture 文件夹，用于存储上传图片） // addResourceLocations: （ file: + 存储图片的路径） registry.addResourceHandler(\"/images/**\").addResourceLocations(\"file:\"+path); &#125; 打包 步骤: 忽略掉test测试,防止发布到线上出现各种问题 成功后会在target目录下生成 版本号与pom.xml 中version有关 安装JDK 参考文章: linux安装java1.8 jdk并配置环境变量 像阿里云和腾讯云需要配置安全组, 参考连接:阿里云安全组配置方法 将jar包传输到linux服务器上 java运行jar包 为了方便,写一个start.sh脚本 方便日后更新版本执行 vim start.sh nohup java -jar emsdemo-0.1.8-SNAPSHOT.jar >springboot.log 2>&amp;1 &amp; chmod +x start.sh 运行 并查看运行日志 ./start.sh cat springboot.log 然后在浏览器输入你的ip:端口号就可以访问了 额外:使用域名访问 如果我想通过域名直接访问项目,不想用ip+ 端口号的方式 ==国内的服务器域名绑定需要备案,国外不用== 思路: ==默认域名绑定80端口,所以使用nginx 端口转发功能== 安装nginx 如果不想手动安装,安装宝塔,用宝塔安装和配置 宝塔安装:linux安装宝塔 配置nginx server &#123; listen 80; #server_name phpmyadmin; #index index.html index.htm index.php; #root &#x2F;www&#x2F;server&#x2F;phpmyadmin; #error_page 404 &#x2F;404.html; #include enable-php.conf; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;sizaif.com:8080; &#125; &#125; 然后relod nginx 过一会通过域名就可以访问了 效果","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"},{"name":"Springboot","slug":"技术向/Springboot","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Springboot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.sizaif.com/tags/Springboot/"}],"author":"sizaif"},{"title":"SpringBoot项目图片文件的上传与显示","slug":"SpringBoot项目图片文件的上传与显示","date":"2021-08-11T14:01:44.000Z","updated":"2021-09-19T10:12:51.828Z","comments":true,"path":"posts/38a7ff2/","link":"","permalink":"https://www.sizaif.com/posts/38a7ff2/","excerpt":"","text":"@auther by sizaif 需求分析 在个人信息页面点击图片上传,上传文件到后台后,并修改图片的名称,设置为 唯一的名称,并同步跟新图片名称到数据库中 数据库设计 我的数据库中: Users存放用户名和密码, Member 存放用户详细信息(包括图片) 配置application.yml 设置自定义的文件上传目录: # 自定义文件上传路径 web: # Linux # upload-path: /root/emsdemo/image # Windows 10 upload-path: C:/Users/SIZ/Desktop/bishe/image/ 后台代码 控制代码 code @Value(\"$&#123;web.upload-path&#125;\") private String path; @PostMapping(\"/users/doUpload/&#123;uid&#125;\") public String UploadImage(@PathVariable(\"uid\") Integer id,@RequestParam(\"imgfile\")MultipartFile file,HttpServletRequest httpServletRequest)&#123; /** * header_img_url是从数据库里捞的，要和你本地或者线上的专门放图片的文件夹里的文件去匹配， * 如果一开始我捞了数据库的头像，发现这个已经存在文件夹里了，那我需要换头像的时候， * 就需要找文件夹里有没有和这一模一样的文件，很明显是有的，因为不管换不换头像之前， * 我这个头像一定是保存在数据库字段里面，并且也在文件夹里面，此时我要更换头像了， * 那我肯定要把文件的这个头像文件删掉并把新上传的头像文件加进来，不存历史记录， * 防止越来越多的头像占内存，并且，我要把这条记录插到数据库里面，，相当于更新了头像。 */ // 获取当前用户 Subject currentUser = SecurityUtils.getSubject(); Users curru = (Users) currentUser.getPrincipal(); System.out.println(\"currenttUser.ID--> \" + curru.getId()); /** * 根据User.id 拿到member 全部信息 */ Member member = memberService.QueryOneMemberInfoByID(curru.getId()); /** * 获取数据库中当前用户的照片 * 若存在则删除,替换 */ File sqlfile = new File(member.getImage()); Boolean isExits = sqlfile.exists(); if(isExits)&#123; sqlfile.delete(); &#125; //得到将要上传的文件名 String fileName = file.getOriginalFilename(); //设置文件上传，并且设置了新的唯一名字XXXXX.jpg String newFileName = FileUtils.upload(file, path, fileName); /** * 连接数据库进行进行更新 */ HashMap&lt;String, Object> memberMap = new HashMap&lt;>(); memberMap.put(\"image\",newFileName); memberMap.put(\"id\",id); SystemResult systemResult = memberService.UpdateMemberInfo(memberMap); if(systemResult.getStatus()!=200)&#123; // 失败 System.out.println(systemResult.getMsg()); &#125;else &#123; // 成功 /** * 更新到IndexDto 中 */ Member afterUpdateImageMember = memberService.QueryOneMemberInfoByID(curru.getId()); IndexDto indexDto = new IndexDto(); UsersServiceAppoint.WriteUsersInfoToDto(indexDto,curru,afterUpdateImageMember); Session session = currentUser.getSession(); HttpSession httpSession = httpServletRequest.getSession(); httpSession.setAttribute(\"IndexDto\",indexDto); session.setAttribute(\"IndexDto\",indexDto); System.out.println(\"进行了图片上传功能,并更新到数据库\"); System.out.println(systemResult.getMsg()); &#125; /** * 重定向到--->个人信息页面 */ return \"redirect:/users/toProfilesPage/\"+ id; &#125; &#125; FileUtils代码 code package com.sizaif.emsdemo.utils; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.IOException; import java.util.UUID; public class FileUtils &#123; /** * 唯一识别的UUID * @return */ public static String getUUID()&#123; return UUID.randomUUID().toString().replace(\"-\", \"\"); &#125; /** * 获取文件后缀 * @param fileName * @return */ public static String getSuffix(String fileName)&#123; return fileName.substring(fileName.lastIndexOf(\".\")); &#125; /** * 和随机的UUID生成新的文件名 * @param fileOriginName * @return */ public static String getFileName(String fileOriginName)&#123; return getUUID() + getSuffix(fileOriginName); &#125; /** * 保存文件到本地,并返回新的唯一文件名 * @param file 文件 * @param path 文件存放路径 * @param fileName 文件名字 * @return */ public static String upload(MultipartFile file, String path, String fileName)&#123; String newFileName = getFileName(fileName); // 生成新的文件名 String realPath = path + \"/\" + newFileName; File dest = new File(realPath); //判断文件父目录是否存在 if(!dest.getParentFile().exists())&#123; dest.getParentFile().mkdir(); &#125; try &#123; //保存文件 file.transferTo(dest); return newFileName; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; &#125; MVCConfig设置 code 新建MyMvcConfig.java @Configuration @Component public class MyMvcConfig implements WebMvcConfigurer &#123; // 接入虚拟路径（解决重启服务器才显示图片的问题） // 拦截本地路径 // 前端代码只需要设置成到/images/目录下拿图片, // 便可以自动到自己设置的path目录下拿图片 @Value(\"$&#123;web.upload-path&#125;\") private String path; @Override public void addResourceHandlers(ResourceHandlerRegistry registry)&#123; // addResourceHandler: （ 存储图片的虚拟路径，在 static 目录下的 picture 文件夹，用于存储上传图片） // addResourceLocations: （ file: + 存储图片的路径） registry.addResourceHandler(\"/images/**\").addResourceLocations(\"file:\" +path ); &#125; &#125; 前端代码 上传代码 &lt;form enctype=\"multipart/form-data\" method=\"post\" th:action=\"@&#123;/users/doUpload/&#125; + $&#123;ProfilesInfo.getId()&#125;\"> &lt;input class=\"btn btn-success \" name=\"imgfile\" type=\"file\">&lt;i class=\"fa fa-image m-right-xs\">&lt;/i>修改照片&lt;/input> &lt;input type=\"submit\" class=\"tn btn-success\" value=\"上传\"> &lt;/form> 显示代码 ${ProfilesInfo.getImage()} 拿到的是数据库中图片的名字 &lt;img class=\"img-responsive avatar-view\" th:src=\"@&#123;/images/&#125;+$&#123;ProfilesInfo.getImage()&#125;\" alt=\"Avatar\" title=\"Change the avatar\" onclick=\"F_Open_dialog()\">","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"},{"name":"Springboot","slug":"技术向/Springboot","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Springboot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.sizaif.com/tags/Springboot/"}],"author":"sizaif"},{"title":"SEAL学习第四天-Ckks_basics","slug":"SEAL学习第四天-ckks-basics","date":"2021-08-11T14:01:42.000Z","updated":"2021-08-14T14:15:24.769Z","comments":true,"path":"posts/51f3b771/","link":"","permalink":"https://www.sizaif.com/posts/51f3b771/","excerpt":"","text":"@auther by sizaif SEAL 学习第四天： ckks_basics @[toc] 简介说明 通常一个好的策略是为CKKS选择参数方案如下: (1) 选择一个60位素数作为coeff_modulus中的第一个素数.这将解密时给出最高的精度; (2) 选择另一个60位素数作为coeff_modulus的最后一个元素，,同时这将被用作特殊的素数，应该与其他质数中最大的一样打； (3) 选择中间素数彼此接近 我们使用CoeffModulus::Create来生成适当大小的素数。请注意我们的coeff_modulus是200位的总和，这低于 poly_modulus_degree: CoeffModulus::MaxBitCount(8192)返回218。 scale 比例增大输入的浮点系数数据 即使在纯文本元素的CKKS方案基本上是多项式的整数系数 x^n 编码的位精度;自然会影响精度结果。 所以设置一个放大比例系数是很有必要的。 有了scale 必然有rescale rescale 通常在乘法后执行 目的: 乘法后： scale = scale + scale = 2*scale 即 $ \\Delta^{2}\\to \\Delta $ 函数调用 参数类型 解释说明 evaluator.rescale_to_next_inplace(Ciphertext) Ciphertext 重新调整scale比例系数接近于初始设置的值，接近但不是等于 double scale = pow(2.0, 40); int 定义一个2^40 的scale 比例系数 Encoding &amp; Decoding 计算 对于多项式 不同的计算顺序消耗的噪声预算以及性能不同 在这个样例中: 求 $F(x) = \\pi * x^{3} + 0.4 * x +1$ Plaintext plain_coeff3, plain_coeff1, plain_coeff0; // 编码 encoder.encode(3.14159265, scale, plain_coeff3);// PI encoder.encode(0.4, scale, plain_coeff1); // 0.4 encoder.encode(1.0, scale, plain_coeff0); // 1 // x^2 evaluator.square(x1_encrypted, x3_encrypted); // x3_encrypted = x1_encrypted * x1_encrypted evaluator.relinearize_inplace(x3_encrypted, relin_keys); evaluator.rescale_to_next_inplace(x3_encrypted); // 重新调整scale 规模 // PI * x evaluator.multiply_plain(x1_encrypted, plain_coeff3, x1_encrypted_coeff3);// x1_encrypted_coeff3 = x1_encrypted * plain_coeff3 evaluator.rescale_to_next_inplace(x1_encrypted_coeff3); // 0.4*x evaluator.multiply_plain_inplace(x1_encrypted, plain_coeff1); evaluator.rescale_to_next_inplace(x1_encrypted); 然后就可以三项之和；然而,有一个严重的问题是: ​ 这三个术语使用的加密参数都是不同是由于模数从缩放转换而来。 ​ 而加密的加法和减法要求输入的level为相同并且加密参数(parms_id)匹配。 ​ 如果有不匹配时，求值器将抛出异常。 我们验证可以发现三者的level是不一样的 在这个样例中 level的变化过程 - Product x^2 has scale 2^80 and is at level 2; - Product PI*x has scale 2^80 and is at level 2; - We rescaled both down to scale 2^80/P_2 and level 1; - Product PI*x^3 has scale (2^80/P_2)^2; - We rescaled it down to scale (2^80/P_2)^2/P_1 and level 0; - Product 0.4*x has scale 2^80; - We rescaled it down to scale 2^80/P_2 and level 1; - The contant term 1 has scale 2^40 and is at level 2. 三者的scale 虽然接近，但也是不一样的 这里有几种方法来解决这个scale问题 既然P_2和P_1非常接近2 ^ 40,我们可以简单欺骗 Microsoft SEAL，把scale 设置成一样的，因为以及非常接近2^40 // 重新设置两者的scale x3_encrypted.scale() = pow(2.0, 40); x1_encrypted.scale() = pow(2.0, 40); 另一种方法就是将1 编码成 2^80/P_2 在做一个 multiply_plain 将level降到与0.4*x 保持一致 解决掉上面的问题后我们还有加密参数不匹配的问题。这是很容易的通过使用modulus switching (no rescaling) 来解决 CKKS支持modulus switching就像BFV格式一样、 cout &lt;&lt; \"Normalize encryption parameters to the lowest level.\" &lt;&lt; endl; parms_id_type last_parms_id = x3_encrypted.parms_id(); evaluator.mod_switch_to_inplace(x1_encrypted, last_parms_id); evaluator.mod_switch_to_inplace(plain_coeff0, last_parms_id); 到现在这三种密文现在都是兼容的，可以进行add运算了 cout &lt;&lt; \"Compute PI*x^3 + 0.4*x + 1.\" &lt;&lt; endl; Ciphertext encrypted_result; evaluator.add(x3_encrypted, x1_encrypted, encrypted_result); evaluator.add_plain_inplace(encrypted_result, plain_coeff0); 结果验证: 输出一个真的，然后将加密的解密解码，做对比验证 code Plaintext plain_result; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode PI*x^3 + 0.4x + 1.\" &lt;&lt; endl; cout &lt;&lt; \" + Expected result:\" &lt;&lt; endl; vector&lt;double> true_result; for (size_t i = 0; i &lt; input.size(); i++) &#123; double x = input[i]; true_result.push_back((3.14159265 * x * x + 0.4) * x + 1); &#125; print_vector(true_result, 3, 7); /* Decrypt, decode, and print the result. */ decryptor.decrypt(encrypted_result, plain_result); vector&lt;double> result; encoder.decode(plain_result, result); cout &lt;&lt; \" + Computed result ...... Correct.\" &lt;&lt; endl; print_vector(result, 3, 7); 源代码 code #include &quot;examples.h&quot; using namespace std; using namespace seal; void example_ckks_basics() &#123; print_example_banner(&quot;Example: CKKS Basics&quot;); &#x2F;* In this example we demonstrate evaluating a polynomial function PI*x^3 + 0.4*x + 1 on encrypted floating-point input data x for a set of 4096 equidistant points in the interval [0, 1]. This example demonstrates many of the main features of the CKKS scheme, but also the challenges in using it. We start by setting up the CKKS scheme. *&#x2F; EncryptionParameters parms(scheme_type::ckks); size_t poly_modulus_degree &#x3D; 8192; &#x2F;&#x2F;long long unsigned int parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 60, 40, 40, 60 &#125;)); &#x2F;* * 我们选择初始比例为2^40 * this leaves us 60-40&#x3D;20 bits of precision before the decimal point, and enough (roughly 10-20 bits) of precision after the decimal point. Since our intermediate primes are 40 bits (in fact, they are very close to 2^40), we can achieve scale stabilization as described above. *&#x2F; double scale &#x3D; pow(2.0, 40); SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; KeyGenerator keygen(context); auto secret_key &#x3D; keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); GaloisKeys galois_keys; keygen.create_galois_keys(galois_keys); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); CKKSEncoder encoder(context); size_t slot_count &#x3D; encoder.slot_count(); cout &lt;&lt; &quot;Number of slots: &quot; &lt;&lt; slot_count &lt;&lt; endl; vector&lt;double&gt; input; input.reserve(slot_count); &#x2F;&#x2F; 申请空间 double curr_point &#x3D; 0; &#x2F;&#x2F;static_cast&lt;double&gt; 将size_t 转成成double 在运算 double step_size &#x3D; 1.0 &#x2F; (static_cast&lt;double&gt;(slot_count) - 1); &#x2F;&#x2F; for (size_t i &#x3D; 0; i &lt; slot_count; i++) &#123; input.push_back(curr_point); curr_point +&#x3D; step_size; &#125; cout &lt;&lt; &quot;Input vector: &quot; &lt;&lt; endl; print_vector(input,3,7); &#x2F;&#x2F; 打印vector 前3 项后3项, 保留小数点后7位 cout &lt;&lt; &quot;Evaluating polynomial PI*x^3 + 0.4x + 1 ...&quot; &lt;&lt; endl; Plaintext plain_coeff3, plain_coeff1, plain_coeff0; &#x2F;&#x2F; 编码 encoder.encode(3.14159265, scale, plain_coeff3); encoder.encode(0.4, scale, plain_coeff1); encoder.encode(1.0, scale, plain_coeff0); Plaintext x_plain; print_line(__LINE__); cout &lt;&lt; &quot;Encode input vectors.&quot; &lt;&lt; endl; encoder.encode(input, scale, x_plain); &#x2F;&#x2F; 加密 Ciphertext x1_encrypted; encryptor.encrypt(x_plain, x1_encrypted); &#x2F;* * 为了计算x^3，我们首先计算x^2并重新线性化。然而，scale已经现在变成了2的80次方。 *&#x2F; &#x2F;&#x2F; x^2 Ciphertext x3_encrypted; print_line(__LINE__); cout &lt;&lt; &quot;Compute x^2 and relinearize:&quot; &lt;&lt; endl; evaluator.square(x1_encrypted, x3_encrypted); &#x2F;&#x2F; x3_encrypted &#x3D; x1_encrypted * x1_encrypted evaluator.relinearize_inplace(x3_encrypted, relin_keys); cout &lt;&lt; &quot; + Scale of x^2 before rescale: &quot; &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;* * 现在重新调节;rescale * 除了modulus switch 方法外，scale 减少的系数等于被转移的质数（40位质数） * 因此, 新的比例尺应该接近2^40。然而，scale !&#x3D; 2^40 :这是因为40位素数只是接近2^40。 * *&#x2F; print_line(__LINE__); cout &lt;&lt; &quot;Rescale x^2.&quot; &lt;&lt; endl; evaluator.rescale_to_next_inplace(x3_encrypted); &#x2F;&#x2F; 重新调整scale 规模 cout &lt;&lt; &quot; + Scale of x^2 after rescale: &quot; &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;* * 现在x3_encrypted与x1_encrypted处于不同的级别 * 这阻止了我们 x3_encrypted*x1_encrypted 来计算x^3 * 因此通过modulus switch 链 将x1_encrypted 切换到与x3_encrypted 同一级别, * 但又需要计算PI* x^3 所以 我们先计算 PI*x 然后调整scale 从2^80 -&gt; 2^40 * 然后在计算 Pi*x * x^2 * *&#x2F; print_line(__LINE__); &#x2F;&#x2F; PI * x cout &lt;&lt; &quot;Compute and rescale PI*x.&quot; &lt;&lt; endl; Ciphertext x1_encrypted_coeff3; evaluator.multiply_plain(x1_encrypted, plain_coeff3, x1_encrypted_coeff3);&#x2F;&#x2F; x1_encrypted_coeff3 &#x3D; x1_encrypted * plain_coeff3 cout &lt;&lt; &quot; + Scale of PI*x before rescale: &quot; &lt;&lt; log2(x1_encrypted_coeff3.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; evaluator.rescale_to_next_inplace(x1_encrypted_coeff3); cout &lt;&lt; &quot; + Scale of PI*x after rescale: &quot; &lt;&lt; log2(x1_encrypted_coeff3.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;&#x2F;(PI*x)*x^2. print_line(__LINE__); cout &lt;&lt; &quot;Compute, relinearize, and rescale (PI*x)*x^2.&quot; &lt;&lt; endl; evaluator.multiply_inplace(x3_encrypted, x1_encrypted_coeff3); evaluator.relinearize_inplace(x3_encrypted, relin_keys); cout &lt;&lt; &quot; + Scale of PI*x^3 before rescale: &quot; &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; evaluator.rescale_to_next_inplace(x3_encrypted); cout &lt;&lt; &quot; + Scale of PI*x^3 after rescale: &quot; &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;&#x2F; 0.4*x print_line(__LINE__); cout &lt;&lt; &quot;Compute and rescale 0.4*x.&quot; &lt;&lt; endl; evaluator.multiply_plain_inplace(x1_encrypted, plain_coeff1); cout &lt;&lt; &quot; + Scale of 0.4*x before rescale: &quot; &lt;&lt; log2(x1_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; evaluator.rescale_to_next_inplace(x1_encrypted); cout &lt;&lt; &quot; + Scale of 0.4*x after rescale: &quot; &lt;&lt; log2(x1_encrypted.scale()) &lt;&lt; &quot; bits&quot; &lt;&lt; endl; &#x2F;* * 现在我们希望计算这三项的和。然而,有一个严重的问题是: 这三个术语使用的加密参数都是不同是由于模数从缩放转换而来。 加密的加法和减法要求输入的刻度为相同， 并且加密参数(parms_id)匹配。如果有不匹配时，求值器将抛出异常。 *&#x2F; cout &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; &quot;Parameters used by all three terms are different.&quot; &lt;&lt; endl; cout &lt;&lt; &quot; + Modulus chain index for x3_encrypted: &quot; &lt;&lt; context.get_context_data(x3_encrypted.parms_id())-&gt;chain_index() &lt;&lt; endl; cout &lt;&lt; &quot; + Modulus chain index for x1_encrypted: &quot; &lt;&lt; context.get_context_data(x1_encrypted.parms_id())-&gt;chain_index() &lt;&lt; endl; cout &lt;&lt; &quot; + Modulus chain index for plain_coeff0: &quot; &lt;&lt; context.get_context_data(plain_coeff0.parms_id())-&gt;chain_index() &lt;&lt; endl; cout &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; &quot;The exact scales of all three terms are different:&quot; &lt;&lt; endl; ios old_fmt(nullptr); old_fmt.copyfmt(cout); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cout &lt;&lt; &quot; + Exact scale in PI*x^3: &quot; &lt;&lt; x3_encrypted.scale() &lt;&lt; endl; cout &lt;&lt; &quot; + Exact scale in 0.4*x: &quot; &lt;&lt; x1_encrypted.scale() &lt;&lt; endl; cout &lt;&lt; &quot; + Exact scale in 1: &quot; &lt;&lt; plain_coeff0.scale() &lt;&lt; endl; cout &lt;&lt; endl; cout.copyfmt(old_fmt); print_line(__LINE__); cout &lt;&lt; &quot;Normalize scales to 2^40.&quot; &lt;&lt; endl; x3_encrypted.scale() &#x3D; pow(2.0, 40); x1_encrypted.scale() &#x3D; pow(2.0, 40); &#x2F;* * 我们还有加密参数不匹配的问题。这是很容易的通过使用modulus switching (no rescaling) 来解决 *&#x2F; print_line(__LINE__); cout &lt;&lt; &quot;Normalize encryption parameters to the lowest level.&quot; &lt;&lt; endl; parms_id_type last_parms_id &#x3D; x3_encrypted.parms_id(); evaluator.mod_switch_to_inplace(x1_encrypted, last_parms_id); evaluator.mod_switch_to_inplace(plain_coeff0, last_parms_id); &#x2F;* 到现在这三种密文现在都是兼容的，可以进行add运算了 *&#x2F; print_line(__LINE__); cout &lt;&lt; &quot;Compute PI*x^3 + 0.4*x + 1.&quot; &lt;&lt; endl; Ciphertext encrypted_result; evaluator.add(x3_encrypted, x1_encrypted, encrypted_result); evaluator.add_plain_inplace(encrypted_result, plain_coeff0); Plaintext plain_result; print_line(__LINE__); cout &lt;&lt; &quot;Decrypt and decode PI*x^3 + 0.4x + 1.&quot; &lt;&lt; endl; cout &lt;&lt; &quot; + Expected result:&quot; &lt;&lt; endl; vector&lt;double&gt; true_result; for (size_t i &#x3D; 0; i &lt; input.size(); i++) &#123; double x &#x3D; input[i]; true_result.push_back((3.14159265 * x * x + 0.4) * x + 1); &#125; print_vector(true_result, 3, 7); &#x2F;* Decrypt, decode, and print the result. *&#x2F; decryptor.decrypt(encrypted_result, plain_result); vector&lt;double&gt; result; encoder.decode(plain_result, result); cout &lt;&lt; &quot; + Computed result ...... Correct.&quot; &lt;&lt; endl; print_vector(result, 3, 7); return; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"SEAL学习第五天-Rotaion","slug":"SEAL学习第五天-rotaion","date":"2021-08-11T14:01:40.000Z","updated":"2021-08-14T14:15:24.772Z","comments":true,"path":"posts/1aba18cf/","link":"","permalink":"https://www.sizaif.com/posts/1aba18cf/","excerpt":"","text":"@auther by sizaif SEAL 学习第五天：rotaion @[toc] BFV /* * 旋转还需要另一种类型的特殊键 Galois keys */ GaloisKeys galois_keys; keygen.create_galois_keys(galois_keys); 两种基本操作 函数调用 参数 解释说明 evaluator.rotate_rows_inplace(encrypted_matrix, 3, galois_keys); Ciphertext，steps，GaloisKeys 将矩阵向左(steps 为正)循环移动3步 evaluator.rotate_columns_inplace(encrypted_matrix, galois_keys); Ciphertext，GaloisKeys 将矩阵行旋转 ==旋转不消耗任何噪音预算== 旋转列 steps 为正 向左移动 steps 为负 向右移动 print_line(__LINE__); cout &lt;&lt; \"Rotate rows 3 steps left.\" &lt;&lt; endl; evaluator.rotate_rows_inplace(encrypted_matrix, 3, galois_keys); Plaintext plain_result; cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); 旋转行 print_line(__LINE__); cout &lt;&lt; \"Rotate columns.\" &lt;&lt; endl; evaluator.rotate_columns_inplace(encrypted_matrix, galois_keys); cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); CKKS 函数调用 参数 解释说明 evaluator.rotate_vector(encrypted, 2, galois_keys, rotated); Ciphertext，steps，GaloisKeys，Ciphertext 将encrypted左(steps为正)循环移动后，输出到rotated code Ciphertext rotated; print_line(__LINE__); cout &lt;&lt; \"Rotate 2 steps left.\" &lt;&lt; endl; evaluator.rotate_vector(encrypted, 2, galois_keys, rotated); cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(rotated, plain); vector&lt;double> result; ckks_encoder.decode(plain, result); print_vector(result, 3, 7); print_line(__LINE__); cout &lt;&lt; \"Rotate 2 steps right.\" &lt;&lt; endl; evaluator.rotate_vector(encrypted, -2, galois_keys, rotated); cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(rotated, plain); ckks_encoder.decode(plain, result); print_vector(result, 3, 7); 源代码 code #include \"examples.h\" using namespace std; using namespace seal; void example_rotation_bfv() &#123; print_example_banner(\"Example: Rotation / Rotation in BFV\"); EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; KeyGenerator keygen(context); SecretKey secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_key; keygen.create_relin_keys(relin_key); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); BatchEncoder batch_encoder(context); size_t slot_count = batch_encoder.slot_count(); size_t row_size = slot_count / 2; cout &lt;&lt; \"Plaintext matrix row size: \" &lt;&lt; row_size &lt;&lt; endl; vector&lt;uint64_t> pod_matrix(slot_count, 0ULL); pod_matrix[0] = 0ULL; pod_matrix[1] = 1ULL; pod_matrix[2] = 2ULL; pod_matrix[3] = 3ULL; pod_matrix[row_size] = 4ULL; pod_matrix[row_size + 1] = 5ULL; pod_matrix[row_size + 2] = 6ULL; pod_matrix[row_size + 3] = 7ULL; cout &lt;&lt; \"Input plaintext matrix:\" &lt;&lt; endl; print_matrix(pod_matrix, row_size); Plaintext plain_matrix; print_line(__LINE__); cout &lt;&lt; \"Encode and encrypt.\" &lt;&lt; endl; batch_encoder.encode(pod_matrix, plain_matrix); Ciphertext encrypted_matrix; encryptor.encrypt(plain_matrix, encrypted_matrix); cout &lt;&lt; \" + Noise budget in fresh encryption: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; endl; /* * 旋转还需要另一种类型的特殊键 Galois keys */ GaloisKeys galois_keys; keygen.create_galois_keys(galois_keys); /* 现在将矩阵行向左循环移动3步, 解密、解码和打印 */ print_line(__LINE__); cout &lt;&lt; \"Rotate rows 3 steps left.\" &lt;&lt; endl; evaluator.rotate_rows_inplace(encrypted_matrix, 3, galois_keys); Plaintext plain_result; cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); /* 我们也可以旋转列, i.e., 交换行. */ print_line(__LINE__); cout &lt;&lt; \"Rotate columns.\" &lt;&lt; endl; evaluator.rotate_columns_inplace(encrypted_matrix, galois_keys); cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); /* 最后，我们将这些行向右旋转4步, decrypt, decode, and print. */ print_line(__LINE__); cout &lt;&lt; \"Rotate rows 4 steps right.\" &lt;&lt; endl; evaluator.rotate_rows_inplace(encrypted_matrix, -4, galois_keys); cout &lt;&lt; \" + Noise budget after rotation: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_matrix); print_matrix(pod_matrix, row_size); &#125; void example_rotation_ckks() &#123; print_example_banner(\"Example: Rotation / Rotation in CKKS\"); /* Rotations in the CKKS scheme work very similarly to rotations in BFV. */ EncryptionParameters parms(scheme_type::ckks); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 40, 40, 40, 40, 40 &#125;)); SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; KeyGenerator keygen(context); SecretKey secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); GaloisKeys galois_keys; keygen.create_galois_keys(galois_keys); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); CKKSEncoder ckks_encoder(context); size_t slot_count = ckks_encoder.slot_count(); cout &lt;&lt; \"Number of slots: \" &lt;&lt; slot_count &lt;&lt; endl; vector&lt;double> input; input.reserve(slot_count); double curr_point = 0; double step_size = 1.0 / (static_cast&lt;double>(slot_count) - 1); for (size_t i = 0; i &lt; slot_count; i++, curr_point += step_size) &#123; input.push_back(curr_point); &#125; cout &lt;&lt; \"Input vector:\" &lt;&lt; endl; print_vector(input, 3, 7); auto scale = pow(2.0, 50); print_line(__LINE__); cout &lt;&lt; \"Encode and encrypt.\" &lt;&lt; endl; Plaintext plain; ckks_encoder.encode(input, scale, plain); Ciphertext encrypted; encryptor.encrypt(plain, encrypted); Ciphertext rotated; print_line(__LINE__); cout &lt;&lt; \"Rotate 2 steps left.\" &lt;&lt; endl; evaluator.rotate_vector(encrypted, 2, galois_keys, rotated); cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(rotated, plain); vector&lt;double> result; ckks_encoder.decode(plain, result); print_vector(result, 3, 7); print_line(__LINE__); cout &lt;&lt; \"Rotate 2 steps right.\" &lt;&lt; endl; evaluator.rotate_vector(encrypted, -2, galois_keys, rotated); cout &lt;&lt; \" + Decrypt and decode ...... Correct.\" &lt;&lt; endl; decryptor.decrypt(rotated, plain); ckks_encoder.decode(plain, result); print_vector(result, 3, 7); &#125; void example_rotation() &#123; print_example_banner(\"Example: Rotation\"); /* Run all rotation examples. */ example_rotation_bfv(); example_rotation_ckks(); &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"SEAL学习第二天-Encoder处理","slug":"SEAL学习第二天-encoder处理","date":"2021-08-11T14:01:38.000Z","updated":"2021-08-14T14:15:24.842Z","comments":true,"path":"posts/286653df/","link":"","permalink":"https://www.sizaif.com/posts/286653df/","excerpt":"","text":"@auther by sizaif SEAL 学习第二天 encoders @[toc] ​ BatchEncoder [BatchEncoder] (For BFV scheme only) 在“1 _bfv_basics。我们展示了如何使用BFV方案执行一个非常简单的计算。计算以明文模为参数，仅利用一个BFV明文多项式的系数。这种方法有两个值得注意的问题: (1)实际应用中一般采用整数或实数算法，而不是模运算; (2)我们只使用了明文多项式的一个系数。这是非常浪费的，因为明文多项式很大，而且在任何情况下都将全部加密。 对于(1) 若增大plain_modulus ，虽然可行，但同时增加了 噪声预算的消耗(当噪声预算消耗到0时，计算结果是不正确的，所以我们要随时关注噪声预算)， 将数据编码为明文(plaintext) 进行encoder 允许更多的计算而没有数据类型溢出，还可以允许使用完整的明文多项式。 调用 参数 解释说明 BatchEncoder batch_encoder(context); SEALContext 声明一个批处理类 batch_encoder.encode(pod_matrix, plain_matrix); VectorPlaintext 将一个vector批量编码成成明文Plaintext batch_encoder.decode(plain_matrix, pod_result); Plaintext,Vector 将一个明文Plaintext处理解码成vector /* 设N为poly_modulus_degree，T为plain_modulus。批处理允许BFV明文多项式被视为2×(N/2)矩阵，每个元素都是一个模T整数。在矩阵视图中，加密操作在加密矩阵上逐个执行element-wise，允许用户在完全向量化计算中获得几个数量级的速度提升。因此，除了最简单的计算之外，批处理应该是首选的方法。使用BFV时，如果使用得当，实现的性能将超过使用IntegerEncoder完成的任何工作。 */ EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); 要启用批处理，我们需要将plain_modulus设置为一个素数，等于1模2* poly_modulus_degrees。Microsoft SEAL提供了一个助手 找到这样一个质数的方法。在这个例子中，我们创建了一个20位素数支持批处理。 通过CoeffModulus::BFVDefault(poly_modulus_degree) 产出一个素数 parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); SEALContext context(parms);// 声明完context后类，后就可以开始使用了 // 检测是否成功启用 auto qualifiers = context.first_context_data()->qualifiers(); cout &lt;&lt; \"Batching enabled: \" &lt;&lt; boolalpha &lt;&lt; qualifiers.using_batching &lt;&lt; endl; 批处理‘slots’的总数等于poly_modulus_degree, N，这些’slots’被组织成2×(N/2)矩阵，可以被加密和计算。每个slot含一个整数 MOD plain_modulus。 2×(N/2) size_t slot_count = batch_encoder.slot_count(); size_t row_size = slot_count / 2; cout &lt;&lt; \"Plaintext matrix slot_count size: \" &lt;&lt; slot_count &lt;&lt; endl; cout &lt;&lt; \"Plaintext matrix row size: \" &lt;&lt; row_size &lt;&lt; endl; /* * 声明一个vector，长度为slot_count， 默为 0 * 形式为： 2*(slot_count/2) 的二维矩阵 * [0...............row_size] * [row_size......slot_count] */ vector&lt;uint64_t> pod_matrix(slot_count, 0ULL); //赋值 pod_matrix[0] = 0ULL; pod_matrix[1] = 1ULL; pod_matrix[2] = 2ULL; pod_matrix[3] = 3ULL; pod_matrix[row_size] = 4ULL; pod_matrix[row_size + 1] = 5ULL; pod_matrix[row_size + 2] = 6ULL; pod_matrix[row_size + 3] = 7ULL; cout &lt;&lt; \"Input plaintext matrix:\" &lt;&lt; endl; /* * 这个print_matrix不会打印矩阵的每一列,只打印每一行的前5个和最后5个 * [ 0, 1, 2, 3, 0, 0, ..., 0 ] * [ 4, 5, 6, 7, 0, 0, ..., 0 ] */ print_matrix(pod_matrix, row_size); encode 从给定的矩阵创建一个明文,&quot;批量处理&quot;一个给定的矩阵 Mod (plaintext modulus) 然后将结果存储到 plaintext类，输入的vecotr的大小 &lt;= 多项式模的次数(poly_modulus_degree) batch_encoder.encode(pod_matrix, plain_matrix); 简单样例验证 生成矩阵A和矩阵B 矩阵A形式: [ 0, 1, 2, 3, 0, 0, ..., 0 ] [ 4, 5, 6, 7, 0, 0, ..., 0 ] 矩阵B形式： [ 1, 2, 1, 2, 1, 2, ..., 2 ] [ 1, 2, 1, 2, 1, 2, ..., 2 ] 求 (A+B)^2 并验证结果 code vector&lt;uint64_t> pod_matrix(slot_count, 0ULL); // pod_matrix[0] = 0ULL; pod_matrix[1] = 1ULL; pod_matrix[2] = 2ULL; pod_matrix[3] = 3ULL; pod_matrix[row_size] = 4ULL; pod_matrix[row_size + 1] = 5ULL; pod_matrix[row_size + 2] = 6ULL; pod_matrix[row_size + 3] = 7ULL; /* 首先，我们使用BatchEncoder将矩阵编码成一个明文多项式。 */ Plaintext plain_matrix; print_line(__LINE__); cout &lt;&lt; \"Encode plaintext matrix:\" &lt;&lt; endl; /* 从给定的矩阵创建一个明文,\"批量处理\"一个给定的矩阵 Mod (plaintext modulus) 然后将结果存储到 plaintext类，输入的vecotr的大小 &lt;= 多项式模的次数(poly_modulus_degree) */ batch_encoder.encode(pod_matrix, plain_matrix); /* 接下来，我们加密已编码的明文。 */ Ciphertext encrypted_matrix; print_line(__LINE__); cout &lt;&lt; \"Encrypt plain_matrix to encrypted_matrix.\" &lt;&lt; endl; encryptor.encrypt(plain_matrix, encrypted_matrix); cout &lt;&lt; \" + Noise budget in encrypted_matrix: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 对密文的操作导致在所有8192(poly_modulus_degree)个slot(矩阵元素)中同时执行同态操作。为了说明这一点，我们构造了另一个明文矩阵： [ 1, 2, 1, 2, 1, 2, ..., 2 ] [ 1, 2, 1, 2, 1, 2, ..., 2 ] 然后把它编码成明文。 */ vector&lt;uint64_t> pod_matrix2; for (size_t i = 0; i &lt; slot_count; i++) &#123; pod_matrix2.push_back((i &amp; size_t(0x1)) + 1); &#125; Plaintext plain_matrix2; batch_encoder.encode(pod_matrix2, plain_matrix2); cout &lt;&lt; endl; cout &lt;&lt; \"Second input plaintext matrix:\" &lt;&lt; endl; print_matrix(pod_matrix2, row_size); /* 现在我们将第二个(明文)矩阵添加到加密矩阵中，并求sum^2。 */ print_line(__LINE__); cout &lt;&lt; \"Sum, square, and relinearize.\" &lt;&lt; endl; evaluator.add_plain_inplace(encrypted_matrix, plain_matrix2); // encrypted_matrix = ncrypted_matrix + plain_matrix2 evaluator.square_inplace(encrypted_matrix);// encrypted_matrix = encrypted_matrix * encrypted_matrix; evaluator.relinearize_inplace(encrypted_matrix, relin_keys); // 序列化 /* 查看剩余噪音预算 */ cout &lt;&lt; \" + Noise budget in result: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; /* 我们将加密的 数据进行解密并解码并验证结果 */ Plaintext plain_result; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode result.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_result); print_matrix(pod_result, row_size); // 验证结果 总结： 当所需的加密计算高度可并行化时，批处理允许我们有效地使用全明文多项式。但是，它并没有解决这个文件开头提到的另一个问题:每个槽只包含一个整数模的明文模量，除非明文模量非常大，否则我们可以很快遇到数据类型溢出，并在需要整数计算时会得到意外的结果。注意，溢出并不能以加密的形式检测到。CKKS方案(以及CKKSEncoder)解决了数据类型溢出问题，但代价是只产生近似的结果。 CKKSEncoder [CKKSEncoder] (For CKKS scheme only) 实数或复数形式 (1) CKKS不使用plain_modulus加密参数; (2) 当使用CKKS方案时,选择coeff_modulus是非常重要的 声明方式 同bfv一致， EncryptionParameters parms(scheme_type::ckks);// 使用ckks size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 40, 40, 40, 40, 40 &#125;));// 产生5个40位的素数的数组 CKKS 中 slot数目 = poly_modulus_degree / 2 每个slot编码为一个实数或复数。 而在BFV中 slot = poly_modulus_degree 并且被处理成 一个2X(N/2)的矩阵 size_t slot_count &#x3D; encoder.slot_count(); 要创建CKKS纯文本，我们需要一个特殊的编码器: BatchEncoder不适用于CKKS CKKSEncoder 的方式是将实数或复数的向量编码为Plaintext objects 然后对object就可以加密了 函数调用 参数类型 解释说明 CKKSEncoder encoder(context); SEALContext 声明一个CKKS编码器 encoder.encode(input, scale, plain); Vector,scale,Plaintext 将vector 按照scale定义的编码精度的尺度参数 编码成 Plaintext encoder.decode(plain, output); Plaintext，Vector 将明文Plaintext解密成Vector 编码与解码 Plaintext plain; double scale = pow(2.0, 30); print_line(__LINE__); cout &lt;&lt; \"Encode input vector. and the size of scale: \"&lt;&lt; scale &lt;&lt; endl; encoder.encode(input, scale, plain); // 将vector 按照scale定义的编码精度的尺度参数 编码成 Plaintext /* 我们可以立即解码以检查编码的正确性。 */ vector&lt;double> output; cout &lt;&lt; \" + Decode input vector ...... Correct.\" &lt;&lt; endl; encoder.decode(plain, output); // 解码 print_vector(output); 做个简单样例验证， 将输入的vector加密后 求平方 并 序列化后 解码验证结果 code /* The vector is encrypted the same was as in BFV. 简单样例: 将输入的 vector 加密后 求平方 并 序列化 */ Ciphertext encrypted; print_line(__LINE__); cout &lt;&lt; \"Encrypt input vector, square, and relinearize.\" &lt;&lt; endl; encryptor.encrypt(plain, encrypted); // 加密 Plaintext -> Ciphertext // 计算 evaluator.square_inplace(encrypted); // encrypted = encrypted * encrypted evaluator.relinearize_inplace(encrypted, relin_keys); // 序列化 cout &lt;&lt; \" + Scale in squared input: \" &lt;&lt; encrypted.scale() &lt;&lt; \" (\" &lt;&lt; log2(encrypted.scale()) &lt;&lt; \" bits)\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode.\" &lt;&lt; endl; decryptor.decrypt(encrypted, plain); // 解密 encoder.decode(plain, output); // 解码 cout &lt;&lt; \" + Result vector ...... Correct.\" &lt;&lt; endl; print_vector(output); // 结果 验证结果正确 全部源代码 code #include \"examples.h\" using namespace std; using namespace seal; void example_batch_encoder() &#123; print_example_banner(\"Example: Encoders / Batch Encoder\"); /* [BatchEncoder] (For BFV scheme only) Let N 表示 poly_modulus_degree ; T 表示 plain_modulus. Batching allows the BFV plaintext polynomials to be viewed as 2-by-(N/2) matrices, with each element an integer modulo T. 在矩阵视图中，加密操作法案在加密的矩阵上, allowing the user to obtain speeds-ups of several orders of magnitude in fully vectorizable computations. Thus, in all but the simplest computations, batching should be the preferred method to use with BFV, and when used properly will result in implementations outperforming anything done without batching. */ EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); //PlainModulus::Batching(poly_modulus_degree, 20) 产生20位的素数 SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; // 检测是否成功启用 auto qualifiers = context.first_context_data()->qualifiers(); cout &lt;&lt; \"Batching enabled: \" &lt;&lt; boolalpha &lt;&lt; qualifiers.using_batching &lt;&lt; endl; KeyGenerator keygen(context); SecretKey secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); BatchEncoder batch_encoder(context); size_t slot_count = batch_encoder.slot_count(); size_t row_size = slot_count / 2; cout &lt;&lt; \"Plaintext matrix slot_count size: \" &lt;&lt; slot_count &lt;&lt; endl; cout &lt;&lt; \"Plaintext matrix row size: \" &lt;&lt; row_size &lt;&lt; endl; /* * 声明一个vector，长度为slot_count， 默为 0 * 形式为： 2*(slot_count/2) 的二维矩阵 * [0...............row_size] * [row_size......slot_count] */ vector&lt;uint64_t> pod_matrix(slot_count, 0ULL); // pod_matrix[0] = 0ULL; pod_matrix[1] = 1ULL; pod_matrix[2] = 2ULL; pod_matrix[3] = 3ULL; pod_matrix[row_size] = 4ULL; pod_matrix[row_size + 1] = 5ULL; pod_matrix[row_size + 2] = 6ULL; pod_matrix[row_size + 3] = 7ULL; cout &lt;&lt; \"Input plaintext matrix:\" &lt;&lt; endl; /* * 这个print_matrix不会打印矩阵的每一列,只打印每一行的前5个和最后5个 * [ 0, 1, 2, 3, 0, 0, ..., 0 ] * [ 4, 5, 6, 7, 0, 0, ..., 0 ] */ print_matrix(pod_matrix, row_size); /* 首先，我们使用BatchEncoder将矩阵编码成一个明文多项式。 */ Plaintext plain_matrix; print_line(__LINE__); cout &lt;&lt; \"Encode plaintext matrix:\" &lt;&lt; endl; /* 从给定的矩阵创建一个明文,\"批量处理\"一个给定的矩阵 Mod (plaintext modulus) 然后将结果存储到 plaintext类，输入的vecotr的大小 &lt;= 多项式模的次数(poly_modulus_degree) */ batch_encoder.encode(pod_matrix, plain_matrix); /* 我们可以立即解码以验证编码的正确性. 但注意，还未进行加密或解密 */ vector&lt;uint64_t> pod_result; cout &lt;&lt; \" + Decode plaintext matrix ...... Correct.\" &lt;&lt; endl; batch_encoder.decode(plain_matrix, pod_result); print_matrix(pod_result, row_size); /* 接下来，我们加密已编码的明文。 */ Ciphertext encrypted_matrix; print_line(__LINE__); cout &lt;&lt; \"Encrypt plain_matrix to encrypted_matrix.\" &lt;&lt; endl; encryptor.encrypt(plain_matrix, encrypted_matrix); cout &lt;&lt; \" + Noise budget in encrypted_matrix: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 对密文的操作导致在所有8192(poly_modulus_degree)个slot(矩阵元素)中同时执行同态操作。为了说明这一点，我们构造了另一个明文矩阵： [ 1, 2, 1, 2, 1, 2, ..., 2 ] [ 1, 2, 1, 2, 1, 2, ..., 2 ] 然后把它编码成明文。 */ vector&lt;uint64_t> pod_matrix2; for (size_t i = 0; i &lt; slot_count; i++) &#123; pod_matrix2.push_back((i &amp; size_t(0x1)) + 1); &#125; Plaintext plain_matrix2; batch_encoder.encode(pod_matrix2, plain_matrix2); cout &lt;&lt; endl; cout &lt;&lt; \"Second input plaintext matrix:\" &lt;&lt; endl; print_matrix(pod_matrix2, row_size); /* 现在我们将第二个(明文)矩阵添加到加密矩阵中，并求sum^2。 */ print_line(__LINE__); cout &lt;&lt; \"Sum, square, and relinearize.\" &lt;&lt; endl; evaluator.add_plain_inplace(encrypted_matrix, plain_matrix2); // encrypted_matrix = ncrypted_matrix + plain_matrix2 evaluator.square_inplace(encrypted_matrix);// encrypted_matrix = encrypted_matrix * encrypted_matrix; evaluator.relinearize_inplace(encrypted_matrix, relin_keys); // 序列化 /* 查看剩余噪音预算 */ cout &lt;&lt; \" + Noise budget in result: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_matrix) &lt;&lt; \" bits\" &lt;&lt; endl; /* 我们将加密的 数据进行解密并解码并验证结果 */ Plaintext plain_result; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode result.\" &lt;&lt; endl; decryptor.decrypt(encrypted_matrix, plain_result); batch_encoder.decode(plain_result, pod_result); cout &lt;&lt; \" + Result plaintext matrix ...... Correct.\" &lt;&lt; endl; print_matrix(pod_result, row_size); /* 当所需的加密计算高度可并行化时，批处理允许我们有效地使用全明文多项式。 但是，它并没有解决这个文件开头提到的另一个问题: 每个槽只包含一个整数模的明文模量，除非明文模量非常大， 否则我们可以很快遇到数据类型溢出，并在需要整数计算时会得到意外的结果。 注意，溢出并不能以加密的形式检测到。CKKS方案(以及CKKSEncoder)解决了数据类型溢出问题， 但代价是只产生近似的结果。 */ &#125; void example_ckks_encoder() &#123; print_example_banner(\"Example: Encoders / CKKS Encoder\"); EncryptionParameters parms(scheme_type::ckks);// 使用ckks size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 40, 40, 40, 40, 40 &#125;));// 产生5个40位的素数的数组 // 同BFV一致，声明 SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; // 密钥产生的方式和 bfv 是一样的 KeyGenerator keygen(context); auto secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); // 加密器，解密器，计算器 Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); /* * 要创建CKKS纯文本，我们需要一个特殊的编码器: BatchEncoder不适用于CKKS CKKSEncoder 的方式是将实数或复数的向量编码为Plaintext objects 然后对object就可以加密了 看起来很像BatchEncoder为BFV方案所做的，但理论上它的背后是完全不同的。 */ CKKSEncoder encoder(context); /* * CKKS 中 slot数目 = poly_modulus_degree / 2 每个slot编码为一个实数或复数。 * 而在BFV中 slot = poly_modulus_degree 并且被处理成 一个2X(N/2)的矩阵 */ size_t slot_count = encoder.slot_count(); cout &lt;&lt; \"Number of slots: \" &lt;&lt; slot_count &lt;&lt; endl; vector&lt;double> input&#123; 0.0, 1.1, 2.2, 3.3 &#125;; cout &lt;&lt; \"Input vector: \" &lt;&lt; endl; print_vector(input); /* * 现在我们用CKKSEncoder进行编码。输入的浮点系数将通过参数“scale”放大 * 这是必要的，因为即使是在纯文本元素的CKKS方案,基本上是多项式整数系数。 * 在CKKS中，消息是存 MOD coeff_modulus,(而在BFV中是 存储 MOD plain_modulus) * 因此，缩放后的消息不能太接近总大小coeff_modulus。 * */ Plaintext plain; double scale = pow(2.0, 30); print_line(__LINE__); cout &lt;&lt; \"Encode input vector. and the size of scale: \"&lt;&lt; scale &lt;&lt; endl; encoder.encode(input, scale, plain); // 将vector 按照scale定义的编码精度的尺度参数 编码成 Plaintext /* 我们可以立即解码以检查编码的正确性。 */ vector&lt;double> output; cout &lt;&lt; \" + Decode input vector ...... Correct.\" &lt;&lt; endl; encoder.decode(plain, output); // 解码 print_vector(output); /* The vector is encrypted the same was as in BFV. 简单样例: 将输入的 vector 加密后 求平方 并 序列化 */ Ciphertext encrypted; print_line(__LINE__); cout &lt;&lt; \"Encrypt input vector, square, and relinearize.\" &lt;&lt; endl; encryptor.encrypt(plain, encrypted); // 加密 Plaintext -> Ciphertext // 计算 evaluator.square_inplace(encrypted); // encrypted = encrypted * encrypted evaluator.relinearize_inplace(encrypted, relin_keys); // 序列化 cout &lt;&lt; \" + Scale in squared input: \" &lt;&lt; encrypted.scale() &lt;&lt; \" (\" &lt;&lt; log2(encrypted.scale()) &lt;&lt; \" bits)\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Decrypt and decode.\" &lt;&lt; endl; decryptor.decrypt(encrypted, plain); // 解密 encoder.decode(plain, output); // 解码 cout &lt;&lt; \" + Result vector ...... Correct.\" &lt;&lt; endl; print_vector(output); // 结果 /* * CKKS方案允许减少加密计算之间的规模。这是CKKS非常强大和关键的基本特性灵活。 * 我们将在' 3_levels中详细讨论它。cpp'和稍后“4 _ckks_basics.cpp”。 */ &#125; void example_encoders() &#123; print_example_banner(\"Example: Encoders\"); /* Run all encoder examples. */ //example_batch_encoder(); example_ckks_encoder(); &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"SEAL学习第三天-Levels","slug":"SEAL学习第三天-levels","date":"2021-08-11T14:01:36.000Z","updated":"2021-08-14T14:15:24.840Z","comments":true,"path":"posts/51e56618/","link":"","permalink":"https://www.sizaif.com/posts/51e56618/","excerpt":"","text":"@auther by sizaif SEAL 学习第三天：levels @[toc] 简介 今天学习描述在BFV和CKKS和在Microsoft SEAL中表示它们的相关对象 在Microsoft SEAL中，一组加密参数(不包括随机数生成器)由参数的256位散列唯一标识。这个散列称为’ parms_id’，可以在任何时候方便地访问和打印。一旦任何参数发生变化，散列就会发生变化。 当从给定的EncryptionParameters实例创建SEALContext时，微软SEAL会自动创建一个所谓的“模数切换链”，它是从原始集合衍生出来的其他加密参数链。模量交换链中的参数除系数模量沿链向下逐渐减小外，其余参数均与原参数相同。更准确地说，链中的每个参数集都试图从前一个集合中移除最后一个系数模素数;这会一直持续到参数集不再有效为止。(例如:plain_modulus大于剩余的coeff_modulus)。很容易遍历整个链并访问所有参数集。此外，链中设置的每个参数都有一个“链索引”，指示其在链中的位置，因此最后一组参数的索引为0。我们说，一组加密参数，或者一个携带这些加密参数的对象，在链中的级别高于另一组参数，如果它的链索引较大，也就是说，它在链中较早。 链中的每一组参数都涉及到执行的唯一预计算。当创建SEALContext并存储在SEALContext::ContextData中时对象。这个链基本上是SEALContext::ContextData的链表对象，并且可以在任何时候通过SEALContext轻松访问。每一个节点可以通过其特定加密参数的parms_id来标识(poly_modulus_degree保持不变，coeff_modulus变化)。 EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree &#x3D; 8192; parms.set_poly_modulus_degree(poly_modulus_degree); 在这个例子中，我们使用了一个自定义的coeff_modulus， c由5个质数组成的50, 30, 30, 50, 50 位素数. CoeffModulus::MaxBitCount(poly_modulus_degree) returns 218 (greater than 50+30+30+50+50=210). 由于模量切换链，5个素数的顺序是重要的。最后一个质数有特殊的含义，我们称之为“特殊质数”。 因此,第一个参数设置在模切换链只有一个涉及到特殊的prime 创建所有密钥对象，如SecretKey在这个最高的层次。所有数据对象，如密文，只能在较低的水平。 这个特殊质数应该与在coeff_modulus中的其他素数的最大质数一样大 在SEAL中有一个重要的level的概念，根据示例代码里的注释，可以理解为SEAL根据默认的参数创建了一个modulus switching chain ，在同一个链上的加密实例除了coefficient modulus 其他都相同。下面示例代码给的一个解释： special prime +---------+ | v coeff_modulus: &#123; 50, 30, 30, 50, 50 &#125; +---+ Level 4 (all keys; `key level') | | coeff_modulus: &#123; 50, 30, 30, 50 &#125; +---+ Level 3 (highest `data level') | | coeff_modulus: &#123; 50, 30, 30 &#125; +---+ Level 2 | | coeff_modulus: &#123; 50, 30 &#125; +---+ Level 1 | | coeff_modulus: &#123; 50 &#125; +---+ Level 0 (lowest level) 有方便的访问方法 SEALContext::ContextData SEALContext::key_context_data(): access to key level ContextData SEALContext::first_context_data(): access to highest data level ContextData SEALContext::last_context_data(): access to lowest level ContextData 这是通过set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 50, 30, 30, 50, 50 &#125;)) 方法设置的 打印信息查看 验证keys级别。 KeyGenerator keygen(context); auto secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); print_line(__LINE__); cout &lt;&lt; \"Print the parameter IDs of generated elements.\" &lt;&lt; endl; cout &lt;&lt; \" + public_key: \" &lt;&lt; public_key.parms_id() &lt;&lt; endl; cout &lt;&lt; \" + secret_key: \" &lt;&lt; secret_key.parms_id() &lt;&lt; endl; cout &lt;&lt; \" + relin_keys: \" &lt;&lt; relin_keys.parms_id() &lt;&lt; endl; 验证密文Ciphertext级别 Plaintext plain(\"1x^3 + 2x^2 + 3x^1 + 4\"); Ciphertext encrypted; encryptor.encrypt(plain, encrypted); cout &lt;&lt; \" + plain: \" &lt;&lt; plain.parms_id() &lt;&lt; \" (not set in BFV)\" &lt;&lt; endl; cout &lt;&lt; \" + encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl &lt;&lt; endl; “Modulus switching” “Modulus switching”是一种降低密文参数的技术在链中 Evaluator::mod_switch_to_next总是切换到 下一级链，而Evaluator::mod_switch_to切换到在对应于给定parms_id的链上设置的参数。然而,它 是不可能在链条向上切换的。 验证: code print_line(__LINE__); cout &lt;&lt; \"Perform modulus switching on encrypted and print.\" &lt;&lt; endl; context_data = context.first_context_data(); cout &lt;&lt; \"---->\"; while (context_data->next_context_data()) &#123; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id of encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl; cout &lt;&lt; \" Noise budget at this level: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; evaluator.mod_switch_to_next_inplace(encrypted); context_data = context_data->next_context_data(); &#125; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id of encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl; cout &lt;&lt; \" Noise budget at this level: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; cout &lt;&lt; \" End of chain reached\" &lt;&lt; endl &lt;&lt; endl; 源代码 code #include \"examples.h\" #include \"seal/seal.h\" using namespace std; using namespace seal; void example_levels() &#123; print_example_banner(\"Example: Levels\"); EncryptionParameters parms(scheme_type::bfv); size_t poly_modulus_degree = 8192; parms.set_poly_modulus_degree(poly_modulus_degree); /* 在这个例子中，我们使用了一个自定义的coeff_modulus， c由5个质数组成的50, 30, 30, 50, 50 位素数. CoeffModulus::MaxBitCount(poly_modulus_degree) returns 218 (greater than 50+30+30+50+50=210). 由于模量切换链，5个素数的顺序是重要的。最后一个质数有特殊的含义，我们称之为“特殊质数”。 因此,第一个参数设置在模切换链只有一个涉及到特殊的prime 创建所有密钥对象，如SecretKey在这个最高的层次。所有数据对象，如密文，只能在较低的水平。 这个特殊质数应该与在coeff_modulus中的其他素数的最大质数一样大 special prime +---------+ | v coeff_modulus: &#123; 50, 30, 30, 50, 50 &#125; +---+ Level 4 (all keys; `key level') | | coeff_modulus: &#123; 50, 30, 30, 50 &#125; +---+ Level 3 (highest `data level') | | coeff_modulus: &#123; 50, 30, 30 &#125; +---+ Level 2 | | coeff_modulus: &#123; 50, 30 &#125; +---+ Level 1 | | coeff_modulus: &#123; 50 &#125; +---+ Level 0 (lowest level) */ parms.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; 50, 30, 30, 50, 50 &#125;)); /* 在这个例子中，plain_modulus没有发挥太大的作用;我们选择一些合理的价值 */ parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20)); SEALContext context(parms); print_parameters(context); cout &lt;&lt; endl; /* * 有方便的访问方法 SEALContext::ContextData SEALContext::key_context_data(): access to key level ContextData SEALContext::first_context_data(): access to highest data level ContextData SEALContext::last_context_data(): access to lowest level ContextData */ //遍历该链并打印每组参数的parms_id。 //首先打印关键级别参数信息 print_line(__LINE__); cout &lt;&lt; \"Print the modulus switching chain.\" &lt;&lt; endl; auto context_data = context.key_context_data(); cout &lt;&lt; \"----> Level (chain index): \" &lt;&lt; context_data->chain_index(); cout &lt;&lt; \" ...... key_context_data()\" &lt;&lt; endl; cout &lt;&lt; \" parms_id: \" &lt;&lt; context_data->parms_id() &lt;&lt; endl; cout &lt;&lt; \" coeff_modulus primes: \"; cout &lt;&lt; hex; for (const auto&amp; prime : context_data->parms().coeff_modulus()) &#123; cout &lt;&lt; prime.value() &lt;&lt; \" \"; &#125; cout &lt;&lt; dec &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; //接下来迭代其余的 context_data = context.first_context_data(); while (context_data) &#123; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index(); if (context_data->parms_id() == context.first_parms_id()) &#123; cout &lt;&lt; \" ...... first_context_data()\" &lt;&lt; endl; &#125; else if (context_data->parms_id() == context.last_parms_id()) &#123; cout &lt;&lt; \" ...... last_context_data()\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; endl; &#125; cout &lt;&lt; \" parms_id: \" &lt;&lt; context_data->parms_id() &lt;&lt; endl; cout &lt;&lt; \" coeff_modulus primes: \"; cout &lt;&lt; hex; // 16进制输出 for (const auto&amp; prime : context_data->parms().coeff_modulus()) &#123; cout &lt;&lt; prime.value() &lt;&lt; \" \"; &#125; cout &lt;&lt; dec &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; /* Step forward in the chain. */ context_data = context_data->next_context_data(); &#125; cout &lt;&lt; \" End of chain reached\" &lt;&lt; endl &lt;&lt; endl; //我们创建一些keys并检查它们是否确实出现在最高层。 KeyGenerator keygen(context); auto secret_key = keygen.secret_key(); PublicKey public_key; keygen.create_public_key(public_key); RelinKeys relin_keys; keygen.create_relin_keys(relin_keys); print_line(__LINE__); cout &lt;&lt; \"Print the parameter IDs of generated elements.\" &lt;&lt; endl; cout &lt;&lt; \" + public_key: \" &lt;&lt; public_key.parms_id() &lt;&lt; endl; cout &lt;&lt; \" + secret_key: \" &lt;&lt; secret_key.parms_id() &lt;&lt; endl; cout &lt;&lt; \" + relin_keys: \" &lt;&lt; relin_keys.parms_id() &lt;&lt; endl; Encryptor encryptor(context, public_key); Evaluator evaluator(context); Decryptor decryptor(context, secret_key); /* * 在BFV方案中，明文不携带parms_id，而密文携带parms_id。 请注意新加密的密文如何在最高数据级别。 */ Plaintext plain(\"1x^3 + 2x^2 + 3x^1 + 4\"); Ciphertext encrypted; encryptor.encrypt(plain, encrypted); cout &lt;&lt; \" + plain: \" &lt;&lt; plain.parms_id() &lt;&lt; \" (not set in BFV)\" &lt;&lt; endl; cout &lt;&lt; \" + encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl &lt;&lt; endl; /* * “Modulus switching”是一种降低密文参数的技术在链中 Evaluator::mod_switch_to_next总是切换到 下一级链，而Evaluator::mod_switch_to切换到在对应于给定parms_id的链上设置的参数。然而,它 是不可能在链条向上切换的。 */ print_line(__LINE__); cout &lt;&lt; \"Perform modulus switching on encrypted and print.\" &lt;&lt; endl; context_data = context.first_context_data(); cout &lt;&lt; \"---->\"; while (context_data->next_context_data()) &#123; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id of encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl; cout &lt;&lt; \" Noise budget at this level: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; evaluator.mod_switch_to_next_inplace(encrypted); context_data = context_data->next_context_data(); &#125; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id of encrypted: \" &lt;&lt; encrypted.parms_id() &lt;&lt; endl; cout &lt;&lt; \" Noise budget at this level: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; cout &lt;&lt; \" End of chain reached\" &lt;&lt; endl &lt;&lt; endl; /* 在这一点上，很难看到这样做有任何好处:我们损失了巨大噪音预算(即计算能力)没有任何回报。 解密仍能工作。 然而，有一个隐藏的好处:密文的大小取决于系数模数中素数数的线性关系。 因此,如果有不需要或不打算对给定的对象执行任何进一步的计算密文， 我们不妨把它切换到最小的(最后的)集合参数，然后将其发送回密钥持有者解密。 此外，噪音损失预算实际上根本不是一个问题 */ print_line(__LINE__); cout &lt;&lt; \"Decrypt still works after modulus switching.\" &lt;&lt; endl; decryptor.decrypt(encrypted, plain); cout &lt;&lt; \" + Decryption of encrypted: \" &lt;&lt; plain.to_string(); cout &lt;&lt; \" ...... Correct.\" &lt;&lt; endl &lt;&lt; endl; /* * 因此,如果有不需要或不打算对给定的对象执行任何进一步的计算密文， * 我们不妨把它切换到最小的(最后的)集合参数，然后将其发送回密钥持有者解密。 * 此外，噪音损失预算实际上根本不是一个问题 * 首先，我们重新创建原始密文并执行一些计算。 * */ cout &lt;&lt; \"Computation is more efficient with modulus switching.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Compute the 8th power.\" &lt;&lt; endl; encryptor.encrypt(plain, encrypted); cout &lt;&lt; \" + Noise budget fresh: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; evaluator.square_inplace(encrypted); evaluator.relinearize_inplace(encrypted, relin_keys); cout &lt;&lt; \" + Noise budget of the 2nd power: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; evaluator.square_inplace(encrypted); evaluator.relinearize_inplace(encrypted, relin_keys); cout &lt;&lt; \" + Noise budget of the 4th power: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; /* 在这种情况下 modulus switching 对噪声预算完全没有影响。 */ evaluator.mod_switch_to_next_inplace(encrypted); cout &lt;&lt; \" + Noise budget after modulus switching: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 这意味着降低一些系数是没有任何害处的在做了足够的计算之后。 * 在某些情况下，人们可能稍微早一点切换到一个较低的级别，实际上牺牲了一些过程中的噪音预算 * 以用更小的参数来获得计算性能 * 我们从打印出来的数据中可以看到，当噪音预算降到25位左右时，下一个modulus switch应该理想地完成。 */ evaluator.square_inplace(encrypted); evaluator.relinearize_inplace(encrypted, relin_keys); cout &lt;&lt; \" + Noise budget of the 8th power: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; evaluator.mod_switch_to_next_inplace(encrypted); cout &lt;&lt; \" + Noise budget after modulus switching: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 此时，密文仍能正确解密，体积很小，而且计算效率也尽可能高。 * 注意，解密器可以用来解密在modulus switching链中任意层次一个密文 */ decryptor.decrypt(encrypted, plain); cout &lt;&lt; \" + Decryption of the 8th power (hexadecimal) ...... Correct.\" &lt;&lt; endl; cout &lt;&lt; \" \" &lt;&lt; plain.to_string() &lt;&lt; endl &lt;&lt; endl; /* * 在BFV中不需要modulus switching * 在某些情况下，用户可能会不想创建modulus switching链， * 只实现最高的两个level（key level and highest data level) * 这可以通过将bool值' false'传递给SEALContext的构造函数来实现。 */ context = SEALContext(parms, false); /* * 我们可以检查确实只创建了模数交换链最高的两层 */ cout &lt;&lt; \"Optionally disable modulus switching chain expansion.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Print the modulus switching chain.\" &lt;&lt; endl; cout &lt;&lt; \"---->\"; for (context_data = context.key_context_data(); context_data; context_data = context_data->next_context_data()) &#123; cout &lt;&lt; \" Level (chain index): \" &lt;&lt; context_data->chain_index() &lt;&lt; endl; cout &lt;&lt; \" parms_id: \" &lt;&lt; context_data->parms_id() &lt;&lt; endl; cout &lt;&lt; \" coeff_modulus primes: \"; cout &lt;&lt; hex; for (const auto&amp; prime : context_data->parms().coeff_modulus()) &#123; cout &lt;&lt; prime.value() &lt;&lt; \" \"; &#125; cout &lt;&lt; dec &lt;&lt; endl; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \" \\\\-->\"; &#125; cout &lt;&lt; \" End of chain reached\" &lt;&lt; endl &lt;&lt; endl; return; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"SEAL学习第一天-Bfv_basics使用用法","slug":"SEAL学习第一天-bfv-basics使用用法","date":"2021-08-11T14:01:34.000Z","updated":"2021-08-14T14:15:24.837Z","comments":true,"path":"posts/9959b7cc/","link":"","permalink":"https://www.sizaif.com/posts/9959b7cc/","excerpt":"","text":"@auther by sizaif SEAL学习第一天： bfv_basics使用用法 @TOC bfv_basics 一 parms类 创建一个HE方案类 parms类需要的3个参数 poly_modulus_degree (degree of polynomial modulus 多项式模的次数); coeff_modulus ([ciphertext] coefficient modulus 系数模); plain_modulus (plaintext modulus; only for the BFV scheme). MOD X, 将结果MOD到X内 用法 参数 解释说明 EncryptionParameters parms(); scheme_type::bfv 创建一个HE以BFV方案类 size_t poly_modulus_degree = 4096; integear [size_t poly_modulus_degree](###size_t poly_modulus_degree) parms.set_poly_modulus_degree(); poly_modulus_degree parms.set_coeff_modulus()； CoeffModulus::BFVDefault(poly_modulus_degree) poly_modulus_degree parms.set_plain_modulus(1024); integear MOD context.parameter_error_message() 输出报错信息 SEALContext context(parms); 创建SEALContext类 EncryptionParameters parms(scheme_type::bfv); The BFV scheme cannot perform arbitrary computations on encrypted data. Instead, each ciphertext has a specific quantity called the `invariant noise budget' -- or `noise budget' for short -- measured in bits. The noise budget in a freshly encrypted ciphertext (initial noise budget) is determined by the encryption parameters. Homomorphic operations consume the noise budget at a rate also determined by the encryption parameters. In BFV the two basic operations allowed on encrypted data are additions and multiplications, of which additions can generally be thought of as being nearly free in terms of noise budget consumption compared to multiplications. Since noise budget consumption compounds in sequential multiplications, the most significant factor in choosing appropriate encryption parameters is the multiplicative depth of the arithmetic circuit that the user wants to evaluate on encrypted data. Once the noise budget of a ciphertext reaches zero it becomes too corrupted to be decrypted. Thus, it is essential to choose the parameters to be large enough to support the desired computation; otherwise the result is impossible to make sense of even with the secret key. 基本运算: 加法 和乘法 In BFV the two basic operations allowed on encrypted data are additions and multiplications 基本运算: 加法 和乘法 size_t poly_modulus_degree = 4096; size_t poly_modulus_degree 多项式模”的次数,2的倍数;1024, 2048, 4096, 8192, 16384, 32768, parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); coeff_modulus code [ciphertext] `coefficient modulus’ (coeff_modulus) [密文]‘系数模量’ (coeff_modulus)Microsoft SEAL comes with helper functions for selecting the coeff_modulus.For new users the easiest way is to simply use简单调用:CoeffModulus::BFVDefault(poly_modulus_degree),返回vector类型which returns std::vector consisting of a generally good choicefor the given poly_modulus_degree.模长度对应素数长度±---------------------------------------------------+| poly_modulus_degree | max coeff_modulus bit-length |±--------------------±-----------------------------+| 1024 | 27 || 2048 | 54 || 4096 | 109 || 8192 | 218 || 16384 | 438 || 32768 | 881 |±--------------------±-----------------------------+ parms.set_plain_modulus(1024); MOD ~ log2(coeff_modulus/plain_modulus) (bits) 噪声预算计算方式: and the noise budget consumption in a homomorphic multiplication is of the form log2(plain_modulus) + (other terms). 明文模量是BFV格式特有的，使用CKKS格式时不能设置明文模量。 既然所有参数都设置好了，我们就可以构建一个SEALContext了 对象。类的有效性和属性是一个重类 我们刚刚设置的参数。 演示code EncryptionParameters parms(scheme_type::bfv); //声明HE 使用的模式 // 设置 3 个参数 size_t poly_modulus_degree = 4096; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(1024); // 明文 MOD数 (2的倍数, 素数最好) //创建一个context SEALContext context(parms); //当使用参数创建SEALContext时，Microsoft SEAL将首先创建验证这些参数。这里选择的参数是有效的。 cout &lt;&lt; \"Parameter validation (success): \" &lt;&lt; context.parameter_error_message() &lt;&lt; endl; 二 KeyGenerator类 公钥加密方案有一个用于加密数据的单独的公钥，和一个用于解密数据的单独的秘密密钥。 我们需要KeyGenerator类的一个实例。构造密钥生成器会自动生成一个密钥。然后，我们可以使用 KeyGenerator::create_public_key为它创建尽可能多的公钥。 用法 参数 解释说明 KeyGenerator keygen(context); SEALContext 创建一个钥匙生成器 SecretKey secret_key = keygen.secret_key(); 创造一个私钥 PublicKey public_key; 声明一个公钥 keygen.create_public_key(public_key); 创造一个公钥 Encryptor encryptor(); SEALContext，PublicKey 构造Encryptor的一个实例 Evaluator evaluator(); SEALContext 对密文的计算使用Evaluator类执行 Decryptor decryptor(); SEALContext，SecretKey 构造Decryptor类的一个实例 Note that KeyGenerator::create_public_key has another overload that takes no parameters and returns a Serializable&lt;PublicKey&gt; object. We will discuss this in &#96;6_serialization.cpp&#39;. 为了能够加密，我们需要构造Encryptor的一个实例,注意，加密器只需要公钥， ​ Encryptor encryptor(contest,public_key); 对密文的计算使用Evaluator类执行,Evaluator不会由持有密钥的同一方构造。 ​ Evaluator evaluator(context); 当然，我们希望对结果进行解密，以验证一切工作正常，因此还需要构造Decryptor类的一个实例。注意，解密器需要密钥。 ​ Decryptor decryptor(context, secret_key); 演示code code Ciphertext x_encrypted; // 密文 encryptor.encrypt(x_plain, x_encrypted); // 将明文 x_plain 加密输出到密文x_encrypted上 Plaintext x_decrypted; decryptor.decrypt(x_encrypted, x_decrypted); // 解密 将加密密文,输出覆盖到明文上 cout &lt;&lt; \"Compute x_sq_plus_one (x^2+1).\" &lt;&lt; endl; Ciphertext x_sq_plus_one; evaluator.square(x_encrypted, x_sq_plus_one); // 计算平方, 结果输出到 x_sq_plus_one 中 Plaintext plain_one(\"1\"); // 明文 1 /** 加密的乘法导致输出密文的大小增加。 更准确地说，如果输入密文的大小为M和N，则输出 同态乘法后的密文大小为M+N-1。 **/ 线性化 Relinearization `Relinearization’ is an operation that reduces the size of a ciphertext after multiplication back to the initial size, 2. Thus, relinearizing one or both input ciphertexts before the next multiplication can have a huge positive impact on both noise growth and performance, even though relinearization has a significant computational cost itself. It is only possible to relinearize size 3 ciphertexts down to size 2, so often the user would want to relinearize after each multiplication to keep the ciphertext sizes at 2. Relinearization requires special `relinearization keys’, which can be thought of as a kind of public key. Relinearization keys can easily be created with the KeyGenerator. “重新线性化”是一种减少密文大小的操作。 乘法返回初始大小2。因此，重新线性化一个或两个 下一个乘法之前的输入密文可以具有很大的正数 即使重新线性化已对噪声增长和性能产生影响 巨大的计算成本本身。 只能重新线性化 大小为3的密文，大小减小为2，因此用户经常需要重新线性化 每次乘法后，将密文大小保持为2。 重新线性化需要特殊的“重新线性化键”，可以认为 作为一种公钥。 重新线性化键可以轻松创建 KeyGenerator。 线性化用法 用法 参数 解释说明 RelinKeys relin_keys; 声明线性化类 keygen.create_relin_keys(relin_keys); (RelinKeys) 创建一个线性密钥 evaluator.relinearize_inplace(x_squared, relin_keys); (Ciphertext，RelinKeys) 将计算结果重新线性化大小到2以内 演示Code code print_line(__LINE__); cout &lt;&lt; \"Compute and relinearize x_squared (x^2),\" &lt;&lt; endl; cout &lt;&lt; string(13, ' ') &lt;&lt; \"then compute x_sq_plus_one (x^2+1)\" &lt;&lt; endl; Ciphertext x_squared; evaluator.square(x_encrypted, x_squared); cout &lt;&lt; \" + size of x_squared: \" &lt;&lt; x_squared.size() &lt;&lt; endl; evaluator.relinearize_inplace(x_squared, relin_keys);// 重新线性化大小到2以内 cout &lt;&lt; \" + size of x_squared (after relinearization): \" &lt;&lt; x_squared.size() &lt;&lt; endl; evaluator.add_plain(x_squared, plain_one, x_sq_plus_one); // x_sq_plus_one = x_squared + plain_one; cout &lt;&lt; \" + noise budget in x_sq_plus_one: \" &lt;&lt; decryptor.invariant_noise_budget(x_sq_plus_one) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + decryption of x_sq_plus_one: \"; decryptor.decrypt(x_sq_plus_one, decrypted_result); ss2.clear(); ss2 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss2 >> d2; cout &lt;&lt; \"Hex: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer: \"&lt;&lt;d2&lt;&lt;\" ...... Correct. (x^2 + 1 ) \" &lt;&lt; endl; 源代码 code #include \"seal/seal.h\" #include \"examples.h\" #include &lt;iostream> using namespace std; using namespace seal; int main() &#123; print_example_banner(\"Example: BFV Basics\"); EncryptionParameters parms(scheme_type::bfv); //声明HE 使用的模式 // 设置 3 个参数 size_t poly_modulus_degree = 4096; parms.set_poly_modulus_degree(poly_modulus_degree); parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree)); parms.set_plain_modulus(1024); // 明文 MOD数 (2的倍数, 素数最好) //创建一个context SEALContext context(parms); print_line(__LINE__); cout &lt;&lt; \"Set encryption parameters and print\" &lt;&lt; endl; print_parameters(context); cout &lt;&lt; \"Hello World!\"&lt;&lt;endl; cout &lt;&lt; \"Parameter validation (success): \" &lt;&lt; context.parameter_error_message() &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"~~~~~~ A naive way to calculate 4(x^2+1)(x+1)^2. ~~~~~~\" &lt;&lt; endl; KeyGenerator keygen(context); // 密钥类 SecretKey secret_key = keygen.secret_key(); // 创建私钥 PublicKey public_key; keygen.create_public_key(public_key); // 创建公钥 Encryptor encryptor(context, public_key);// 加密类,只需要公钥即可; Evaluator evaluator(context); // 评估计算类 Decryptor decryptor(context, secret_key); // 解密类 /** 4x^4 + 8x^3 + 8x^2 + 8x + 4 **/ print_line(__LINE__); int x = 6; Plaintext x_plain(to_string(x)); //x_plain.to_string() 转换成16进制输出 cout &lt;&lt; \"Express x = \" + to_string(x) + \" as a plaintext polynomial 0x\" + x_plain.to_string() + \".\" &lt;&lt; endl; print_line(__LINE__); Ciphertext x_encrypted;// 密文类 cout &lt;&lt; \"Encrypt x_plain to x_encrypted.\" &lt;&lt; endl; encryptor.encrypt(x_plain, x_encrypted); cout &lt;&lt; \" + size of freshly encrypted x: \" &lt;&lt; x_encrypted.size() &lt;&lt; endl; /* There is plenty of noise budget left in this freshly encrypted ciphertext. 噪声预算，当噪音预算降低到0的时候，计算结果不正确 */ cout &lt;&lt; \" + noise budget in freshly encrypted x: \" &lt;&lt; decryptor.invariant_noise_budget(x_encrypted) &lt;&lt; \" bits\" &lt;&lt; endl; Plaintext x_decrypted; cout &lt;&lt; \" + decryption of x_encrypted: \"; decryptor.decrypt(x_encrypted, x_decrypted); cout &lt;&lt; \"0x\" &lt;&lt; x_decrypted.to_string() &lt;&lt; \" ...... Correct.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Compute x_sq_plus_one (x^2+1).\" &lt;&lt; endl; Ciphertext x_sq_plus_one; evaluator.square(x_encrypted, x_sq_plus_one); // 计算平方, 结果输出到 x_sq_plus_one 中 Plaintext plain_one(\"1\"); // 明文 1 evaluator.add_plain_inplace(x_sq_plus_one, plain_one); // x_sq_plus_one = x_sq_plus_one + plain_one /** 加密的乘法导致输出密文的大小增加。 更准确地说，如果输入密文的大小为M和N，则输出 同态乘法后的密文大小为M+N-1。 **/ cout &lt;&lt; \" + size of x_sq_plus_one: \" &lt;&lt; x_sq_plus_one.size() &lt;&lt; endl; cout &lt;&lt; \" + noise budget in x_sq_plus_one: \" &lt;&lt; decryptor.invariant_noise_budget(x_sq_plus_one) &lt;&lt; \" bits\" &lt;&lt; endl; /* * 计算4个多项式样例 * 4x^4 + 8x^3 + 8x^2 + 8x + 4 * 4x^4 + 8x^3 + 8x^2 + 8x + 4 = 4(x + 1)^2 * (x^2 + 1) 转换成 4(x + 1)^2 * (x^2 + 1) 降低多项式系数 */ stringstream ss2;//字符串流 ,做字符转换用 int d2; // 密文计算(x^2+1) 的解密结果为: Plaintext decrypted_result; cout &lt;&lt; \" + decryption of x_sq_plus_one : \"; decryptor.decrypt(x_sq_plus_one, decrypted_result); ss2.clear(); ss2 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); // 十六进制输出到ss2， ss2 >> d2; // ss2 输出十进制到 d2 cout &lt;&lt; \"HEX: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer: \" &lt;&lt; d2 &lt;&lt; \" .... Correct. \" &lt;&lt; endl; /* 接着密文计算 (x + 1)^2. */ print_line(__LINE__); cout &lt;&lt; \"Compute x_plus_one_sq ((x+1)^2).\" &lt;&lt; endl; Ciphertext x_plus_one_sq; evaluator.add_plain(x_encrypted, plain_one, x_plus_one_sq); //密文 x_plus_one_sq = x_encrypted + plain_one (x+1) evaluator.square_inplace(x_plus_one_sq); // x_plus_one_sq = x_plus_one_sq * x_plus_one_sq; cout &lt;&lt; \" + size of x_plus_one_sq: \" &lt;&lt; x_plus_one_sq.size() &lt;&lt; endl; cout &lt;&lt; \" + noise budget in x_plus_one_sq: \" &lt;&lt; decryptor.invariant_noise_budget(x_plus_one_sq) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + decryption of x_plus_one_sq: \"; decryptor.decrypt(x_plus_one_sq, decrypted_result); ss2.clear(); ss2 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); // 十六进制输出到ss2， ss2 >> d2; // ss2 输出十进制到 d2 cout&lt;&lt;\"Hex: Ox\"&lt;&lt;decrypted_result.to_string()&lt;&lt;\" Integer: \"&lt;&lt;d2&lt;&lt;\" .... Correct. \" &lt;&lt; endl; /* 最终计算 (x^2 + 1) * (x + 1)^2 * 4. */ print_line(__LINE__); cout &lt;&lt; \"Compute encrypted_result (4(x^2+1)(x+1)^2).\" &lt;&lt; endl; Ciphertext encrypted_result; Plaintext plain_four(\"4\"); evaluator.multiply_plain_inplace(x_sq_plus_one, plain_four); // x_sq_plus_one = x_sq_plus_one * 4; evaluator.multiply(x_sq_plus_one, x_plus_one_sq, encrypted_result); // 密文encrypted_result = x_sq_plus_one * x_plus_one_sq ; cout &lt;&lt; \" + size of encrypted_result: \" &lt;&lt; encrypted_result.size() &lt;&lt; endl; cout &lt;&lt; \" + noise budget in encrypted_result: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_result) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \"NOTE: Decryption can be incorrect if noise budget is zero.\" &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"~~~~~~ A better way to calculate 4(x^2+1)(x+1)^2. ~~~~~~\" &lt;&lt; endl; decryptor.decrypt(encrypted_result, decrypted_result); stringstream ss3; ss3.clear(); ss3 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss3 >> d2; // ss2 输出十进制到 d2 cout &lt;&lt; d2 &lt;&lt; \" \" &lt;&lt; decrypted_result.to_string() &lt;&lt; endl; // 得到的结果不正确 /* * 利用Relinearization 线性化 对运算进行优化 */ print_line(__LINE__); cout &lt;&lt; \"Generate relinearization keys.\" &lt;&lt; endl; RelinKeys relin_keys; // 做线性化类 keygen.create_relin_keys(relin_keys); // 创建线性化密钥 /* We now repeat the computation relinearizing after each multiplication. 我们在每次乘法之后重复重新线性化的计算。 */ print_line(__LINE__); cout &lt;&lt; \"Compute and relinearize x_squared (x^2),\" &lt;&lt; endl; cout &lt;&lt; string(13, ' ') &lt;&lt; \"then compute x_sq_plus_one (x^2+1)\" &lt;&lt; endl; Ciphertext x_squared; evaluator.square(x_encrypted, x_squared); cout &lt;&lt; \" + size of x_squared: \" &lt;&lt; x_squared.size() &lt;&lt; endl; evaluator.relinearize_inplace(x_squared, relin_keys);// 重新线性化大小到2以内 cout &lt;&lt; \" + size of x_squared (after relinearization): \" &lt;&lt; x_squared.size() &lt;&lt; endl; evaluator.add_plain(x_squared, plain_one, x_sq_plus_one); // x_sq_plus_one = x_squared + plain_one; cout &lt;&lt; \" + noise budget in x_sq_plus_one: \" &lt;&lt; decryptor.invariant_noise_budget(x_sq_plus_one) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + decryption of x_sq_plus_one: \"; decryptor.decrypt(x_sq_plus_one, decrypted_result); ss2.clear(); ss2 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss2 >> d2; cout &lt;&lt; \"Hex: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer: \"&lt;&lt;d2&lt;&lt;\" ...... Correct. (x^2 + 1 ) \" &lt;&lt; endl; print_line(__LINE__); Ciphertext x_plus_one; cout &lt;&lt; \"Compute x_plus_one (x+1),\" &lt;&lt; endl; cout &lt;&lt; string(13, ' ') &lt;&lt; \"then compute and relinearize x_plus_one_sq ((x+1)^2).\" &lt;&lt; endl; evaluator.add_plain(x_encrypted, plain_one, x_plus_one);// x_plus_one = x_encrypted + plain_one; evaluator.square(x_plus_one, x_plus_one_sq);// x_plus_one_sq = x_plus_one * x_plus_one; cout &lt;&lt; \" + size of x_plus_one_sq: \" &lt;&lt; x_plus_one_sq.size() &lt;&lt; endl; evaluator.relinearize_inplace(x_plus_one_sq, relin_keys); // 大小线性优化到2内 cout &lt;&lt; \" + noise budget in x_plus_one_sq: \" &lt;&lt; decryptor.invariant_noise_budget(x_plus_one_sq) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; \" + decryption of x_plus_one_sq: \"; ss3.clear(); decryptor.decrypt(x_plus_one_sq, decrypted_result); ss3&lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss3 >> d2; cout &lt;&lt; \"Hex: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer: \"&lt;&lt;d2&lt;&lt;\" ...... Correct.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Compute and relinearize encrypted_result (4(x^2+1)(x+1)^2).\" &lt;&lt; endl; evaluator.multiply_plain_inplace(x_sq_plus_one, plain_four); // x_sq_plus_one = x_sq_plus_one * plain_four evaluator.multiply(x_sq_plus_one, x_plus_one_sq, encrypted_result);// encrypted_result = x_sq_plus_one * x_plus_one_sq cout &lt;&lt; \" + size of encrypted_result: \" &lt;&lt; encrypted_result.size() &lt;&lt; endl; evaluator.relinearize_inplace(encrypted_result, relin_keys); // 线性优化 cout &lt;&lt; \" + size of encrypted_result (after relinearization): \" &lt;&lt; encrypted_result.size() &lt;&lt; endl; cout &lt;&lt; \" + noise budget in encrypted_result: \" &lt;&lt; decryptor.invariant_noise_budget(encrypted_result) &lt;&lt; \" bits\" &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"NOTE: Notice the increase in remaining noise budget.\" &lt;&lt; endl; print_line(__LINE__); cout &lt;&lt; \"Decrypt encrypted_result (4(x^2+1)(x+1)^2).\" &lt;&lt; endl; ss3.clear(); decryptor.decrypt(encrypted_result, decrypted_result); ss3 &lt;&lt; hex &lt;&lt; decrypted_result.to_string(); ss3 >> d2; cout &lt;&lt; \" + decryption of 4(x^2+1)(x+1)^2 ,after Mod = Hex: 0x\" &lt;&lt; decrypted_result.to_string() &lt;&lt; \" Integer:\" &lt;&lt; d2 &lt;&lt; \" ...... Correct.(4(x^2+1)(x+1)^2)\" &lt;&lt; endl; /* * 对于 x=6, 4(x^2+1)(x+1)^2 = 7252. 因为 plaintext modulus MOD被设置为 1024, * 所以结果%1024.故 7252 % 1024 == 84, 或者16进制： 0x54 */ print_line(__LINE__); cout &lt;&lt; \"An example of invalid parameters\" &lt;&lt; endl; parms.set_poly_modulus_degree(2048); context = SEALContext(parms); print_parameters(context); cout &lt;&lt; \"Parameter validation (failed): \" &lt;&lt; context.parameter_error_message() &lt;&lt; endl &lt;&lt; endl; return 0; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"}],"tags":[{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}],"author":"sizaif"},{"title":"Java反射技术拿取和设置Object实体类中的属性","slug":"Java反射技术拿取和设置Object实体类中的属性","date":"2021-08-11T14:01:20.000Z","updated":"2021-09-19T10:13:55.343Z","comments":true,"path":"posts/c57ba29d/","link":"","permalink":"https://www.sizaif.com/posts/c57ba29d/","excerpt":"","text":"[TOC] @auther by sizaif 说明 在实际项目开发中使用PageHelper插件拿到的数据封装在 PageInfo中,而某些操作需要拿到里面的值和设置一些值,由于Object的缘故,无法直接get和set,所有使用java反射来get和set for (Object contestVO : pageInfo.getList()) &#123; .....XXXXX..... &#125; 拿属性的值 /** * 根据属性名获取属性值 * * @param 要拿取的属性的名称 * @param 实体类 * @return */ private static String getFieldValueByFieldName(String fieldName, Object object) &#123; try &#123; Field field = object.getClass().getDeclaredField(fieldName); //设置对象的访问权限，保证对private的属性的访问 field.setAccessible(true); return (String)field.get(object); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; 设置 /** * 根据属性名设置属性值 * * @param 要设置的属性名称 * @param 实体类 * @param 对于要设置的属性类型 * @return */ private static void setFieldValueByFieldName(String fieldName, Object object, 对于要设置的属性类型 value) &#123; try &#123; // 获取obj类的字节文件对象 Class aClass = object.getClass(); // 获取该类的成员变量 Field field = aClass.getDeclaredField(fieldName); // 取消语言访问检查 field.setAccessible(true); // 给变量赋值 field.set(object, value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"}],"author":"sizaif"},{"title":"解决 Win10 Hyper-v 保留端口占用问题","slug":"解决-win10-hyper-v-保留端口占用问题","date":"2021-08-11T01:31:53.000Z","updated":"2021-09-19T10:14:21.978Z","comments":true,"path":"posts/f8215b18/","link":"","permalink":"https://www.sizaif.com/posts/f8215b18/","excerpt":"","text":"解决 win10 hyper-v 保留端口占用问题 [TOC] 查找问题 首先，检查端口占用 # powershell netstat -ano | findstr \":8080\" 没有结果，意味着并不是有程序占用了端口。 猜测可能是更新了win10 2004，导致win10防火墙配置有变更，又检查了一番win10防火墙，发现并没有拦截或者端口禁用的配置。此时，我才想起好像先前开启了hyper-v，最后搜索了一番，找到了出现问题的地方： code # powershell # 查看系统默认端口占用访问 netsh int ipv4 show dynamicport tcp 协议 tcp 动态端口范围 --------------------------------- 启动端口 : 1024 端口数 : 13977 # 查看hyper-v启动后的保留端口范围 netsh interface ipv4 show excludedportrange protocol=tcp 协议 tcp 端口排除范围 开始端口 结束端口 ---------- -------- 1026 1125 1226 1325 1326 1425 1426 1525 1526 1625 2180 2279 ... # 通过这个可以查看被占用的项目端口是否在这个范围内 解决办法 由于直接进行第二步配置，会遇到程序占用(hyper-v占用)，所以需要先关闭hyper-v， 可以win+s 快捷键搜索 “windows功能” ，关闭hyper-v，或者使用下列命令，然后重启 # powershell / cmd dism.exe /Online /Disable-Feature:Microsoft-Hyper-V 配置ipv4动态端口 / 或者配置需要的端口不被占用 # powershell / cmd 管理员权限 # start 起始端口 num 表示可用端口数 按自己的需求来 netsh int ipv4 set dynamicport tcp start=30000 num=16383 # 排除ipv4动态端口占用 startport 起始端口 numberofports 端口数 netsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1 重启hyper-v 命令或配置窗口(参考1 dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"}],"tags":[{"name":"Win","slug":"Win","permalink":"https://www.sizaif.com/tags/Win/"},{"name":"Hyper-v","slug":"Hyper-v","permalink":"https://www.sizaif.com/tags/Hyper-v/"}],"author":"sizaif"},{"title":"VS2019平台引入C++版tensorflow遇到的一些问题及解决方法","slug":"VS2019平台引入C-版tensorflow遇到的一些问题及解决方法","date":"2021-08-11T01:23:38.000Z","updated":"2021-09-19T10:12:28.524Z","comments":true,"path":"posts/54fe9f8f/","link":"","permalink":"https://www.sizaif.com/posts/54fe9f8f/","excerpt":"","text":"VS2019平台引入C++版tensorflow遇到的一些问题及解决方法 [TOC] 安装tensorflow 我采用的是已编译好的tensorflow 下载tensorflow https://github.com/fo40225/tensorflow-windows-wheel 注意: 这里面只有tensorflow1.71.10的版本有编译好的cpp库，其他的版本只有编译好的安装tf的python库的whl文件，所以强烈推荐大家用1.71.10的tensorflow。 例如我需要tensorflow1.10的、cpu支持AVX2指令集的版本，就下载tensorflow-windows-wheel/1.10.0/cpp/libtensorflow-cpu-windows-x86_64-1.10.0-avx2.7z 例如我需要tensorflow1.10的、cpu支持SSE2指令集、且gpu支持CUDA9.2和CUDNN7.2的版本，就下载tensorflow-windows-wheel/1.10.0/cpp/libtensorflow-gpu-windows-x86_64-1.10.0-sse2cuda92cudnn72.7z 然后把其中的include路径包含进去，把lib文件添加到工程中，再在执行exe时把dll文件复制进去就好了 ———————————————— 版权声明：本文为CSDN博主「_沥川往事」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/yuejisuo1948/article/details/84197534 引入tensorflow 在cmakelist.txt中写入； include_directories(&lt;Your Path&gt;&#x2F;tensorflow&#x2F;include) link_directories(&lt;Your Path&gt;&#x2F;tensorflow&#x2F;lib) target_link_libraries(&lt;Your exe name&gt; tensorflow) 遇到的问题: 1. “(”:“::”右边的非法标记应输入标记符 原因处在vc和c++模板库上.min和max与&lt;windows.h&gt;中传统的min/max宏定义有冲突 在属性-&gt;C/C+±&gt;预处理器-&gt; 预处理定义中 添加NOMINMAX 解决方法: 2.找不到tensorflow.dll 解决方法: ==将已编译好的tensorflow的bin目录下 tensorflow.dll 复制到 debug目录下和*.exe一起== 如图: 3.找不到cublas64_92.dll 没安装cuda的缘故 我对应的是安装9.2的版本 参考安装CUDA文章 https://blog.csdn.net/qq_46126258/article/details/112739305?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=94a15f6a-35fe-4639-90bf-20c5530f2251&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control 安装完后再运行提示 找不到 cudnn64_7.dll 没有安装对应的cudnn版本 去nvidia官网安装 https://developer.nvidia.com/rdp/cudnn-archive 选择对应的Cuda版本 ， 这里选择的就是 下载后 将对应的文件复制到 CUDA 的安装目录： a) Copy &lt;installpath>\\cuda\\bin\\cudnn64_7.dll to C:\\Program Files \\NVIDIA GPU Computing Toolkit\\CUDA\\v9.2\\bin. b) Copy &lt;installpath>\\cuda\\ include\\cudnn.h to C:\\Program Files \\NVIDIA GPU Computing Toolkit\\CUDA\\v9.2\\include. c) Copy &lt;installpath>\\cuda\\lib\\x64\\cudnn.lib to C:\\Program Files \\NVIDIA GPU Computing Toolkit\\CUDA\\v9.2\\lib\\x64","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"VS2019","slug":"技术向/VS2019","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/VS2019/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"VS2019","slug":"VS2019","permalink":"https://www.sizaif.com/tags/VS2019/"}],"author":"sizaif"},{"title":"Ubuntu 20.04LTS 编译Tensorflow C++","slug":"ubuntu-20-04LTS-编译tensorflow-C","date":"2021-08-11T01:23:22.000Z","updated":"2021-09-19T10:12:33.711Z","comments":true,"path":"posts/71bba0f8/","link":"","permalink":"https://www.sizaif.com/posts/71bba0f8/","excerpt":"","text":"ubuntu 20.04LTS 编译tensorflow C++ NOTE! 因为ubuntu在虚拟机里,我是用的笔记本的显卡比较落后,安装NVIDIA驱动失败,故未使用 GPU功能,仅使用了CPU模式; 编译得到libtensorflow_cc.so和libtensorflow_framework.so 是C++ 所需要的 [TOC] tensorflow 和Bazel 以及python 对应的版本 Linux CPU CPU VersionPython versionCompilerBuild toolstensorflow-2.4.03.6-3.8GCC 7.3.1Bazel 3.1.0tensorflow-2.3.03.5-3.8GCC 7.3.1Bazel 3.1.0tensorflow-2.2.03.5-3.8GCC 7.3.1Bazel 2.0.0tensorflow-2.1.02.7, 3.5-3.7GCC 7.3.1Bazel 0.27.1tensorflow-2.0.02.7, 3.3-3.7GCC 7.3.1Bazel 0.26.1tensorflow-1.15.02.7, 3.3-3.7GCC 7.3.1Bazel 0.26.1tensorflow-1.14.02.7, 3.3-3.7GCC 4.8Bazel 0.24.1tensorflow-1.13.12.7, 3.3-3.7GCC 4.8Bazel 0.19.2tensorflow-1.12.02.7, 3.3-3.6GCC 4.8Bazel 0.15.0tensorflow-1.11.02.7, 3.3-3.6GCC 4.8Bazel 0.15.0tensorflow-1.10.02.7, 3.3-3.6GCC 4.8Bazel 0.15.0tensorflow-1.9.02.7, 3.3-3.6GCC 4.8Bazel 0.11.0tensorflow-1.8.02.7, 3.3-3.6GCC 4.8Bazel 0.10.0tensorflow-1.7.02.7, 3.3-3.6GCC 4.8Bazel 0.10.0tensorflow-1.6.02.7, 3.3-3.6GCC 4.8Bazel 0.9.0tensorflow-1.5.02.7, 3.3-3.6GCC 4.8Bazel 0.8.0tensorflow-1.4.02.7, 3.3-3.6GCC 4.8Bazel 0.5.4tensorflow-1.3.02.7, 3.3-3.6GCC 4.8Bazel 0.4.5tensorflow-1.2.02.7, 3.3-3.6GCC 4.8Bazel 0.4.5tensorflow-1.1.02.7, 3.3-3.6GCC 4.8Bazel 0.4.2tensorflow-1.0.02.7, 3.3-3.6GCC 4.8Bazel 0.4.2 GPU GPU VersionPython versionCompilerBuild toolscuDNNCUDAtensorflow-2.4.03.6-3.8GCC 7.3.1Bazel 3.1.08.011.0tensorflow-2.3.03.5-3.8GCC 7.3.1Bazel 3.1.07.610.1tensorflow-2.2.03.5-3.8GCC 7.3.1Bazel 2.0.07.610.1tensorflow-2.1.02.7, 3.5-3.7GCC 7.3.1Bazel 0.27.17.610.1tensorflow-2.0.02.7, 3.3-3.7GCC 7.3.1Bazel 0.26.17.410.0tensorflow_gpu-1.15.02.7, 3.3-3.7GCC 7.3.1Bazel 0.26.17.410.0tensorflow_gpu-1.14.02.7, 3.3-3.7GCC 4.8Bazel 0.24.17.410.0tensorflow_gpu-1.13.12.7, 3.3-3.7GCC 4.8Bazel 0.19.27.410.0tensorflow_gpu-1.12.02.7, 3.3-3.6GCC 4.8Bazel 0.15.079tensorflow_gpu-1.11.02.7, 3.3-3.6GCC 4.8Bazel 0.15.079tensorflow_gpu-1.10.02.7, 3.3-3.6GCC 4.8Bazel 0.15.079tensorflow_gpu-1.9.02.7, 3.3-3.6GCC 4.8Bazel 0.11.079tensorflow_gpu-1.8.02.7, 3.3-3.6GCC 4.8Bazel 0.10.079tensorflow_gpu-1.7.02.7, 3.3-3.6GCC 4.8Bazel 0.9.079tensorflow_gpu-1.6.02.7, 3.3-3.6GCC 4.8Bazel 0.9.079tensorflow_gpu-1.5.02.7, 3.3-3.6GCC 4.8Bazel 0.8.079tensorflow_gpu-1.4.02.7, 3.3-3.6GCC 4.8Bazel 0.5.468tensorflow_gpu-1.3.02.7, 3.3-3.6GCC 4.8Bazel 0.4.568tensorflow_gpu-1.2.02.7, 3.3-3.6GCC 4.8Bazel 0.4.55.18tensorflow_gpu-1.1.02.7, 3.3-3.6GCC 4.8Bazel 0.4.25.18tensorflow_gpu-1.0.02.7, 3.3-3.6GCC 4.8Bazel 0.4.25.18 具体步骤 一 首先安装python3 环境, 如果你没有安装的话 sudo apt install python3-dev python3-pip 安装TensorFlow 2 .whl包需要一个pip版本&gt;19.0 二 安装 Bazel 这里我才用的是安装程序文件来进行的. 安装程序可以从Bazel’s下载 https://github.com/bazelbuild/bazel/releases 选择上面你要编译的对应的bazel版本 安装程序包含Bazel二进制文件，并将其提取到**$HOME/bin**文件夹中。为了让Bazel工作，必须手动安装一些附加库。 如果没有以下环境. 需要进行安装 sudo apt install g++ unzip zip 如果想用Bazel 构建JAVA代码, 使用JDK # Ubuntu 16.04 (LTS) uses OpenJDK 8 by default: sudo apt-get install openjdk-8-jdk # Ubuntu 18.04 (LTS) uses OpenJDK 11 by default: sudo apt-get install openjdk-11-jdk 下载之后, 运行 chmod +x bazel-&lt;version>-installer-linux-x86_64.sh ./bazel-&lt;version>-installer-linux-x86_64.sh --user The --user flag installs Bazel to the $HOME/bin directory on your system and sets the .bazelrc path to $HOME/.bazelrc. Use the --help command to see additional installation options. 当使用–user 来安装时, Bazel 会被安装到 $HOME/bin 路径下, 添加环境语句到环境**/.bashrc**或者**/.zshrc**变量里 可以使用VIM vim ~/.bashrc 添加以下语句 export PATH=\"$PATH:$HOME/bin\" 然后实质生效 source ~/.bashrc 三下载tensorflow源码 git clone https://github.com/tensorflow/tensorflow.git cd tensorflow 选择要安装的版本 git checkout branch_name # r2.2, r2.3, r2.4 etc. 构建环境 ./configure configure 会话展示 这里要说明的是如果有CUDA，那么Do you wish to build Tensorflow with CUDA?一定要选Y，然后其它的我基本都是N code ./configure You have bazel 3.0.0 installed. Please specify the location of python. [Default is /usr/bin/python3]: Found possible Python library paths: /usr/lib/python3/dist-packages /usr/local/lib/python3.6/dist-packages Please input the desired Python library path to use. Default is [/usr/lib/python3/dist-packages] Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: No OpenCL SYCL support will be enabled for TensorFlow. Do you wish to build TensorFlow with ROCm support? [y/N]: No ROCm support will be enabled for TensorFlow. Do you wish to build TensorFlow with CUDA support? [y/N]: Y CUDA support will be enabled for TensorFlow. Do you wish to build TensorFlow with TensorRT support? [y/N]: No TensorRT support will be enabled for TensorFlow. Found CUDA 10.1 in: /usr/local/cuda-10.1/targets/x86_64-linux/lib /usr/local/cuda-10.1/targets/x86_64-linux/include Found cuDNN 7 in: /usr/lib/x86_64-linux-gnu /usr/include Please specify a list of comma-separated CUDA compute capabilities you want to build with. You can find the compute capability of your device at: https://developer.nvidia.com/cuda-gpus Each capability can be specified as \"x.y\" or \"compute_xy\" to include both virtual and binary GPU code, or as \"sm_xy\" to only include the binary code. Please note that each additional compute capability significantly increases your build time and binary size, and that TensorFlow only supports compute capabilities >= 3.5 [Default is: 3.5,7.0]: 6.1 Do you want to use clang as CUDA compiler? [y/N]: nvcc will be used as CUDA compiler. Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]: Please specify optimization flags to use during compilation when bazel option \"--config=opt\" is specified [Default is -march=native -Wno-sign-compare]: Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: Not configuring the WORKSPACE for Android builds. Preconfigured Bazel build configs. You can use any of the below by adding \"--config=&lt;>\" to your build command. See .bazelrc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=ngraph # Build with Intel nGraph support. --config=numa # Build with NUMA support. --config=dynamic_kernels # (Experimental) Build kernels into separate shared objects. --config=v2 # Build TensorFlow 2.x instead of 1.x. Preconfigured Bazel build configs to DISABLE default on features: --config=noaws # Disable AWS S3 filesystem support. --config=nogcp # Disable GCP support. --config=nohdfs # Disable HDFS support. --config=nonccl # Disable NVIDIA NCCL support. Configuration finished 编译 配置好之后就进行编译：若采用CUDA 则如下 bazel build --config=opt --config=cuda //tensorflow:libtensorflow_cc.so ​ 这里如果不用cuda的话(前面配置的时候在CUDA那一项那里输入N)，就输入： bazel build --config=opt //tensorflow:libtensorflow_cc.so 可能会遇到的问题: /usr/bin/env: ‘python‘: No such file or directory 如果以及安装了python3的版本,可能是因为显示的是python3.X 但用的的名称为python 所以可以建立一个软连接 whereis python3# 如果安装的话,默认在/usr/bin/目录下sudo ln -s /usr/bin/python3 /usr/bin/python 接下来就是漫长的等待, 因为我没有用CUDA( NVIDIA的驱动没有安装上,所以用不了GPU加速) 耗时3+小时 最终会在 当前目录下生成一个 bazel-bin 目录下 tensorflow 里 找到这两个文件","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"}],"author":"sizaif"},{"title":"Tensorflow-C++ & OpenCV & OpenBlas & Eigen3 & Protobuf 环境Docker镜像","slug":"tensorflow-C-OpenCV-OpenBlas-eigen3-protobuf-环境docker镜像","date":"2021-08-11T01:23:06.000Z","updated":"2021-09-19T10:12:40.739Z","comments":true,"path":"posts/1c98e054/","link":"","permalink":"https://www.sizaif.com/posts/1c98e054/","excerpt":"","text":"tensorflow-C++ &amp; OpenCV &amp; OpenBlas &amp; eigen3 &amp; protobuf 环境docker镜像 [toc] 版本 tensorflow 2.4.1 protobuf 3.9.2 opencv 4.5.2 openblas 0.3.13 eigen3 3.3.9 使用方法: code # 下载镜像 docker pull sizaif2000/siz:1.0 # 运行后 在 /home/tf_test/ 下有 tensorflow 测试 -------- docker run -p 本机映射端口:镜像映射端口 -d --name 启动镜像名称 -e 镜像启动参数 镜像名称:镜像版本号 参数释义： -p 本机端口和容器启动端口映射 -d 后台运行 --name 容器名称 -e 镜像启动参数 ------------------------ tf_test . |-- CMakeLists.txt |-- README.md `-- src `-- main.cpp 1 directory, 3 files ------------------------ cd tf_test cmake. make ./main # if ok, then you can see like this: This is tensorflow test XXXX-XX-XX 03:55:33.709188: I tensorflow/core/platform/cpu_feature_guard.cc:142] This TensorFlow binary is optimized with oneAPI D eep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations: SSE3 SSE4.1 SSE4.2 AVX AVX2 FMA To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags. OK Session successfully created.","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"OpenCV","slug":"机器学习/OpenCV","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/OpenCV/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.sizaif.com/tags/OpenCV/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"}],"author":"sizaif"},{"title":"Tensorflow V2.4 C++ 编译测试遇到的问题以及相关解决方法","slug":"tensorflow-V2-4-C-编译测试遇到的问题以及相关解决方法","date":"2021-08-11T01:22:48.000Z","updated":"2021-09-19T10:12:37.519Z","comments":true,"path":"posts/fabe9f4f/","link":"","permalink":"https://www.sizaif.com/posts/fabe9f4f/","excerpt":"","text":"tensorflow V2.4 C++ 编译测试遇到的问题以及相关解决方法 [TOC] fatal error: absl/strings/string_view.h: No such file or directory 解决方法: 将 https://github.com/abseil/abseil-cpp 项目中 git下来, 将 absl 目录下所有文件 复制到 tensorflow/ 目录下 /usr/local/include/tf/tensorflow 为 tensorflow 的 头文件位置 git clone https://github.com/abseil/abseil-cpp sudo cp -r ./abseil-cpp/absl /usr/local/include/tf/tensorflow atal error: tensorflow/core/protobuf/error_codes.pb.h: No such file or directory 解决方法 先查看 tensorflow 头文件 目录下 /usr/local/include/tf/tensorflow/core/protobuf/ 下有无此文件, 若无,则有可能在 bazel-bin/tensorflow/core/protobuf 目录下 # 当前在tensorflow 源码目录下 sudo cp -r ./bazel-bin/tensorflow/ /usr/local/indlue/tf/tensorflow","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"}],"author":"sizaif"},{"title":"Tensorflow 与Protobuf版本对应问题","slug":"tensorflow-与protobuf版本对应问题","date":"2021-08-11T01:22:32.000Z","updated":"2021-08-14T14:15:24.794Z","comments":true,"path":"posts/a689049b/","link":"","permalink":"https://www.sizaif.com/posts/a689049b/","excerpt":"","text":"tensorflow 与protobuf版本对应问题 [TOC] 问题描述 我在前面的文章编译了tensorflow 2.4.1版本, 然后随之又根据protobuf github教程安装了3.15版本的protobuf 当我在编译代码引入tensorflow 时 提示如下错误: 当我运行如下命令; 得到protoc的位置,和版本信息 siz@ubuntu:~$ which protoc /usr/local/bin/protoc siz@ubuntu:~$ protoc --version libprotoc 3.15.8 查阅博客得到如下信息: (参考链接: https://blog.csdn.net/datase/article/details/82347834) 我想我遇到的应该是第二个问题: 所以我去了tensorflow github 查看了 workspace.bzl 信息: 对应的 protobuf的版本为3.9.2; 尝试解决 卸载 protobuf ==Note! 因为之前第一次安装protobuf 采用的是覆盖安装,所以将Ubuntu自带的protobuf覆盖掉了, 所以我选择直接卸载掉最新的,重新安装,没有采用兼容安装的方式== 删除方式, 进入到下载的protobuf 路径里, 采用 make uninstall 方式 code siz@ubuntu:~/soft$ cd protobuf-3.15.8/ siz@ubuntu:~/soft/protobuf-3.15.8$ sudo make uninstall [sudo] password for siz: Making uninstall in . make[1]: Entering directory '/home/siz/soft/protobuf-3.15.8' ( cd '/usr/local/lib/pkgconfig' &amp;&amp; rm -f protobuf.pc protobuf-lite.pc ) make[1]: Leaving directory '/home/siz/soft/protobuf-3.15.8' Making uninstall in src make[1]: Entering directory '/home/siz/soft/protobuf-3.15.8/src' ( cd '/usr/local/bin' &amp;&amp; rm -f protoc ) /bin/bash ../libtool --mode=uninstall rm -f '/usr/local/lib/libprotobuf-lite.la' libtool: uninstall: rm -f /usr/local/lib/libprotobuf-lite.la /usr/local/lib/libprotobuf-lite.a /bin/bash ../libtool --mode=uninstall rm -f '/usr/local/lib/libprotobuf.la' libtool: uninstall: rm -f /usr/local/lib/libprotobuf.la /usr/local/lib/libprotobuf.a /bin/bash ../libtool --mode=uninstall rm -f '/usr/local/lib/libprotoc.la' libtool: uninstall: rm -f /usr/local/lib/libprotoc.la /usr/local/lib/libprotoc.a ( cd '/usr/local/include' &amp;&amp; rm -f google/protobuf/descriptor.proto google/protobuf/any.proto google/protobuf/api.proto google/protobuf/duration.proto google/protobuf/empty.proto google/protobuf/field_mask.proto google/protobuf/source_context.proto google/protobuf/struct.proto google/protobuf/timestamp.proto google/protobuf/type.proto google/protobuf/wrappers.proto google/protobuf/compiler/plugin.proto ) ( cd '/usr/local/include' &amp;&amp; rm -f google/protobuf/stubs/callback.h google/protobuf/stubs/bytestream.h google/protobuf/stubs/casts.h google/protobuf/stubs/common.h google/protobuf/stubs/hash.h google/protobuf/stubs/logging.h google/protobuf/stubs/macros.h google/protobuf/stubs/map_util.h google/protobuf/stubs/mutex.h google/protobuf/stubs/once.h google/protobuf/stubs/platform_macros.h google/protobuf/stubs/port.h google/protobuf/stubs/status.h google/protobuf/stubs/stl_util.h google/protobuf/stubs/stringpiece.h google/protobuf/stubs/strutil.h google/protobuf/stubs/template_util.h google/protobuf/any.pb.h google/protobuf/api.pb.h google/protobuf/any.h google/protobuf/arena.h google/protobuf/arena_impl.h google/protobuf/arenastring.h google/protobuf/descriptor_database.h google/protobuf/descriptor.h google/protobuf/descriptor.pb.h google/protobuf/duration.pb.h google/protobuf/dynamic_message.h google/protobuf/empty.pb.h google/protobuf/extension_set.h google/protobuf/extension_set_inl.h google/protobuf/field_mask.pb.h google/protobuf/generated_enum_reflection.h google/protobuf/generated_enum_util.h google/protobuf/generated_message_reflection.h google/protobuf/generated_message_table_driven.h google/protobuf/generated_message_util.h google/protobuf/has_bits.h google/protobuf/implicit_weak_message.h google/protobuf/io/io_win32.h google/protobuf/map_entry.h google/protobuf/map_entry_lite.h google/protobuf/map_field.h google/protobuf/map_field_inl.h google/protobuf/map_field_lite.h google/protobuf/map.h google/protobuf/map_type_handler.h google/protobuf/message.h google/protobuf/message_lite.h google/protobuf/metadata.h google/protobuf/metadata_lite.h google/protobuf/parse_context.h google/protobuf/port.h google/protobuf/port_def.inc google/protobuf/port_undef.inc google/protobuf/reflection.h google/protobuf/reflection_ops.h google/protobuf/repeated_field.h google/protobuf/service.h google/protobuf/source_context.pb.h google/protobuf/struct.pb.h google/protobuf/text_format.h google/protobuf/timestamp.pb.h google/protobuf/type.pb.h google/protobuf/unknown_field_set.h google/protobuf/wire_format.h google/protobuf/wire_format_lite.h google/protobuf/wrappers.pb.h google/protobuf/io/coded_stream.h google/protobuf/io/gzip_stream.h google/protobuf/io/printer.h google/protobuf/io/strtod.h google/protobuf/io/tokenizer.h google/protobuf/io/zero_copy_stream.h google/protobuf/io/zero_copy_stream_impl.h google/protobuf/io/zero_copy_stream_impl_lite.h google/protobuf/compiler/code_generator.h google/protobuf/compiler/command_line_interface.h google/protobuf/compiler/importer.h google/protobuf/compiler/parser.h google/protobuf/compiler/plugin.h google/protobuf/compiler/plugin.pb.h google/protobuf/compiler/cpp/cpp_generator.h google/protobuf/compiler/csharp/csharp_generator.h google/protobuf/compiler/csharp/csharp_names.h google/protobuf/compiler/java/java_generator.h google/protobuf/compiler/java/java_names.h google/protobuf/compiler/js/js_generator.h google/protobuf/compiler/js/well_known_types_embed.h google/protobuf/compiler/objectivec/objectivec_generator.h google/protobuf/compiler/objectivec/objectivec_helpers.h google/protobuf/compiler/php/php_generator.h google/protobuf/compiler/python/python_generator.h google/protobuf/compiler/ruby/ruby_generator.h google/protobuf/util/type_resolver.h google/protobuf/util/delimited_message_util.h google/protobuf/util/field_comparator.h google/protobuf/util/field_mask_util.h google/protobuf/util/json_util.h google/protobuf/util/time_util.h google/protobuf/util/type_resolver_util.h google/protobuf/util/message_differencer.h ) make[1]: Leaving directory '/home/siz/soft/protobuf-3.15.8/src' siz@ubuntu:~/soft/protobuf-3.15.8$ which protoc siz@ubuntu:~/soft/protobuf-3.15.8$ 重新安装protobuf protobuf github release 地址: https://github.com/protocolbuffers/protobuf/releases 下载对应的3.92版本: 并解压 cd protobuf-XXX/ ./autogen.sh ./configure make make check sudo make install sudo ldconfig # refresh shared library cache. 查看版本 protoc --version 至此安装完成","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.sizaif.com/tags/OpenCV/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"}],"author":"sizaif"},{"title":"OpenSSL 使用手册","slug":"OpenSSL-使用手册","date":"2021-08-10T06:34:10.000Z","updated":"2021-08-14T14:15:24.735Z","comments":true,"path":"posts/e82eda1b/","link":"","permalink":"https://www.sizaif.com/posts/e82eda1b/","excerpt":"","text":"OpenSSL 命令行解析 😄 @Auther: sizaif 📆 2021-05-09 16:32:02 [TOC] 参考文档 服务端: https://www.openssl.org/docs/man1.0.2/man1/openssl-s_server.html 客户端:https://www.openssl.org/docs/man1.0.2/man1/s_client.html OpenSSL命令分为以下3个部分。 标准命令Standard commands 1.asn1parse: asn1parse用于解释用ANS.1语法书写的语句(ASN一般用于定义语法的构成) 演示命令操作顺序：4 -&gt; 5 -&gt; 3 -&gt; 2-&gt; 6 -&gt; 7 -&gt;8 2.ca: ca用于CA的管理. 用法： openssl ca [-options]。 code 2.1) -selfsign 使用对证书请求进行签名的密钥对来签发证书。即\"自签名\"，这种情况发生在生成证书的客户端、签发证书的CA都是同一台机器(也是我们大多数实验中的情况)，我们可以使用同一个密钥对来进行\"自签名\" 2.2) -in file 需要进行处理的PEM格式的证书 2.3) -out file 处理结束后输出的证书文件 2.4) -cert file 用于签发的根CA证书 2.5) -days arg 指定签发的证书的有效时间 2.6) -keyfile arg CA的私钥证书文件 2.7) -keyform arg CA的根私钥证书文件格式: 2.7.1) PEM 2.7.2) ENGINE 2.8) -key arg CA的根私钥证书文件的解密密码(如果加密了的话) 2.9) -config file 配置文件 3. X.509证书签发请求(CSR)管理 用法： openssl req [options] outfile code 3.1) -inform arg 输入文件格式 3.1.1) DER 3.1.2) PEM 3.2) -outform arg 输出文件格式 3.2.1) DER 3.2.2) PEM 3.3) -in arg 待处理文件 3.4) -out arg 待输出文件 3.5) -passin 用于签名待生成的请求证书的私钥文件的解密密码 3.6) -key file 用于签名待生成的请求证书的私钥文件 3.7) -keyform arg 3.7.1) DER 3.7.2) NET 3.7.3) PEM 3.8) -new 新的请求 3.9) -x509 输出一个X509格式的证书 3.10) -days X509证书的有效时间 3.11) -newkey rsa:bits 生成一个bits长度的RSA私钥文件，用于签发 3.12) -[digest] HASH算法 3.12.1) md5 3.12.2) sha1 3.12.3) md2 3.12.4) mdc2 3.12.5) md4 3.13) -config file 指定openssl配置文件 3.14) -text: text显示格式 4. genrsa: 生成RSA参数 用法： code openssl genrsa [args] [numbits] 4.1) 对生成的私钥文件是否要使用加密算法进行对称加密: 4.1.1) -des: CBC模式的DES加密 4.1.2) -des3: CBC模式的3DES加密 4.1.3) -aes128: CBC模式的AES128加密 4.1.4) -aes192: CBC模式的AES192加密 4.1.5) -aes256: CBC模式的AES256加密 4.2) -passout arg: arg为对称加密(des、3des、aes)的密码(使用这个参数就省去了console交互提示输入密码的环节) 4.3) -out file: 输出证书私钥文件 [numbits]: 密钥长度 example: 生成一个1024位的RSA私钥，并用3DES加密(密码为123456)，保存为server.key文件 openssl genrsa -out server.key -passout pass:123456 -des3 1024 5. RSA数据管理 用法： openssl rsa [options] outfile code 5.1) -inform arg 输入密钥文件格式: 5.1.1) DER(ASN1) 5.1.2) NET 5.1.3) PEM(base64编码格式) 5.2) -outform arg 输出密钥文件格式 5.2.1) DER 5.2.2) NET 5.2.3) PEM 5.3) -in arg 待处理密钥文件 5.4) -passin arg 输入这个加密密钥文件的解密密钥(如果在生成这个密钥文件的时候，选择了加密算法了的话) 5.5) -out arg 待输出密钥文件 5.6) -passout arg 如果希望输出的密钥文件继续使用加密算法的话则指定密码 5.7) -des: CBC模式的DES加密 5.8) -des3: CBC模式的3DES加密 5.9) -aes128: CBC模式的AES128加密 5.10) -aes192: CBC模式的AES192加密 5.11) -aes256: CBC模式的AES256加密 5.12) -text: 以text形式打印密钥key数据 5.13) -noout: 不打印密钥key数据 5.14) -pubin: 检查待处理文件是否为公钥文件 5.15) -pubout: 输出公钥文件 6. x509 openssl x509是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作 用法： openssl x509 [args] code 6.1) -inform arg 待处理X509证书文件格式 6.1.1) DER 6.1.2) NET 6.1.3) PEM 6.2) -outform arg 待输出X509证书文件格式 6.2.1) DER 6.2.2) NET 6.2.3) PEM 6.3) -in arg 待处理X509证书文件 6.4) -out arg 待输出X509证书文件 6.5) -req 表明输入文件是一个\"请求签发证书文件(CSR)\"，等待进行签发 6.6) -days arg 表明将要签发的证书的有效时间 6.7) -CA arg 指定用于签发请求证书的根CA证书 6.8) -CAform arg 根CA证书格式(默认是PEM) 6.9) -CAkey arg 指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有 6.10) -CAkeyform arg 指定根CA私钥证书文件格式(默认为PEM格式) 6.11) -CAserial arg 指定序列号文件(serial number file) 6.12) -CAcreateserial 如果序列号文件(serial number file)没有指定，则自动创建它 7 dhparam openssl dhparam用于生成和管理dh文件。dh(Diffie-Hellman)是著名的密钥交换协议，或称为密钥协商协议，它可以保证通信双方安全地交换密钥。但注意，它不是加密算法，所以不提供加密功能，仅仅只是保护密钥交换的过程。在openvpn中就使用了该交换协议 code openssl dhparam [-in filename] [-out filename] [-dsaparam] [-noout] [-text] [-rand file(s)] [numbits] 选项说明： -in filename：从filename文件中读取密钥交换协议参数。 -out filename：输出密钥交换协议参数到filename文件。 -dsaparam：指定此选项将使用dsa交换协议替代dh交换协议。虽然生成速度更快，但更不安全。 -noout：禁止输出任何信息。 -text：以文本格式输出dh协议。 -rand：指定随机数种子文件。 numbits：指定生成的长度。 使用 客户端 openssl s_client -key ./experiments/keystore/client.key -cert ./experiments/keystore/client.crt -CAfile ./experiments/keystore/demoCA/cacert.pem 服务端 openssl s_server -key ./experiments/keystore/server.key -cert ./experiments/keystore/server.crt -CAfile ./experiments/keystore/demoCA/cacert.pem -accept 4433 -HTTP","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"}],"author":"sizaif"},{"title":"OpenCV Tensorflow C++API   Protobuf Eigen3 编译过程","slug":"OpenCV-Tensorflow-C-API-Protobuf-eigen3-编译过程","date":"2021-08-10T06:22:04.000Z","updated":"2021-08-14T14:15:24.732Z","comments":true,"path":"posts/56ff1cb1/","link":"","permalink":"https://www.sizaif.com/posts/56ff1cb1/","excerpt":"","text":"OpenCV Tensorflow C++API Protobuf eigen3 编译过程 @auther by sizaif 2021-08-10 14:22:25 [TOC] OpenCV 首先安装OpenCV的依赖文件，在终端运行下面命令： code sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev # if errorE: unable to locate libjasper-dev sudo add-apt-repository \"deb http://security.ubuntu.com/ubuntu xenial-security main\" # or vim sources.list add \"deb http://security.ubuntu.com/ubuntu xenial-security main\" and update vim /etc/apt/sources.list sudo apt update sudo apt install libjasper1 libjasper-dev Install compiler and build tools To compile OpenCV you will need a C++ compiler. Usually it is G++/GCC or Clang/LLVM: Install GCC… sudo apt install -y g++ … or Clang: sudo apt install -y clang OpenCV uses CMake build configuration tool: sudo apt install -y cmake CMake can generate scripts for different build systems, e.g. make,ninja: Install Make… sudo apt install -y make … or Ninja: sudo apt install -y ninja-build Install tool for getting and unpacking sources: wget and unzip … sudo apt install -y wget unzip … or git : sudo apt install -y git Download sources There are two methods of getting OpenCV sources: Download snapshot of repository using web browser or any download tool (~80-90Mb) and unpack it… wget -O opencv.zip https://github.com/opencv/opencv/archive/master.zipunzip opencv.zipmv opencv-master opencv … or clone repository to local machine using git to get full change history (&gt;470Mb): git clone https://github.com/opencv/opencv.gitgit -C opencv checkout master Note Snapshots of other branches, releases or commits can be found on the GitHub and the official download page. Configure and build Create build directory: mkdir -p build &amp;&amp; cd build Configure - generate build scripts for the preferred build system: For make… #自定义路径安装OpenCV 到 /usr/local/opencv 中cmake -D CMAKE_INSTALL_PREFIX=/usr/local/opencv ../opencv … or for ninja : cmake -GNinja ../opencv Build - run actual compilation process: Using make … make -j4 … or ninja : ninja Note Configure process can download some files from the internet to satisfy library dependencies, connection failures can cause some of modules or functionalities to be turned off or behave differently. Refer to the OpenCV installation overview and OpenCV configuration options reference tutorials for details and full configuration options reference. If you experience problems with the build process, try to clean or recreate the build directory. Changes in the configuration like disabling a dependency, modifying build scripts or switching sources to another branch are not handled very well and can result in broken workspace. Make can run multiple compilation processes in parallel, -j&lt;NUM&gt; option means “run jobs simultaneously”. Ninja will automatically detect number of available processor cores and does not need -j option. Check build results After successful build you will find libraries in the build/lib directory and executables (test, samples, apps) in the build/bin directory: ls binls lib CMake package files will be located in the build root: ls OpenCVConfig*.cmakels OpenCVModules.cmake Install Warning The installation process only copies files to predefined locations and does minor patching. Installing using this method does not integrate opencv into the system package registry and thus, for example, opencv can not be uninstalled automatically. We do not recommend system-wide installation to regular users due to possible conflicts with system packages. By default OpenCV will be installed to the /usr/local directory, all files will be copied to following locations: /usr/local/bin - executable files /usr/local/lib - libraries (.so) /usr/local/cmake/opencv4 - cmake package /usr/local/include/opencv4 - headers /usr/local/share/opencv4 - other files (e.g. trained cascades in XML format) Since /usr/local is owned by the root user, the installation should be performed with elevated privileges (sudo): sudo make install or sudo ninja install Installation root directory can be changed with CMAKE_INSTALL_PREFIX configuration parameter, e.g. -DCMAKE_INSTALL_PREFIX=$HOME/.local to install to current user’s local directory. Installation layout can be changed with OPENCV_*_INSTALL_PATH parameters. See OpenCV configuration options reference for details. Generated on Tue Apr 20 2021 02:31:39 for OpenCV by 1.8.13 Tensorflow bazel code # Bazel needs a C++ compiler and unzip / zip in order to work: sudo apt install g++ unzip zip # Run the installer chmod +x bazel-&lt;version>-installer-linux-x86_64.sh ./bazel-&lt;version>-installer-linux-x86_64.sh --user # Set up your environment vim ~/.bashrc export PATH=\"$PATH:$HOME/bin\" source ~/.bashrc tensorflow-v2.4.0 code # 安装以下构建工具以配置开发环境。 sudo apt install python3-dev python3-pip pip install numpy # 安装 Bazel git clone https://github.com/tensorflow/tensorflow.git cd tensorflow git checkout branch_name # r2.2, r2.3, etc. ./configure # CUDA GPU bazel build --config=opt --config=cuda //tensorflow:libtensorflow_cc.so # CPU bazel build --config=opt //tensorflow:libtensorflow_cc.so # 编译完成后, 将头文件 ( bazel-bin/tensorflow 和 下 **.so 复制到 /usr/local/include/tf/tensorflow 和 /usr/local/lib mkdir /usr/local/include/tf cp -r bazel-bin/tensorflow/* /usr/local/include/tf/tensorflow/ sudo cp -r bazel-bin/tensorflow/*.so /usr/local/lib/ 测试 CMakeLists.txt CMakeLists.txt cmake_minimum_required(VERSION 2.8) # project Name &amp; Version project(STOtest) # find_package find_package(OpenCV REQUIRED) # set location # Openblas set(OpenBlas_DIR /usr/local/OpenBlas) # eigen set(Eigen_DIR /usr/local/include/eigen3) # tensorflow set(Tensorflow_INCLUDES /usr/local/include/tf/ /usr/local/include/tf/tensorflow/ /usr/local/include/tf/tensorflow/third-party) set(Tensorflow_LIBS /usr/local/lib/libtensorflow_cc.so /usr/local/lib/libtensorflow_framework.so) # protobuf set(Protobuf_INCLUDES /usr/local/include/google) set(Protobuf_LIBS /usr/local/bin/protoc) message(STATUS: \"OpenBlas_DIR= $&#123;OpenBlas_DIR&#125;\") message(STATUS \"OpenCV library status:\") message(STATUS \" config=: $&#123;OpenCV_DIR&#125;\") message(STATUS \" version=: $&#123;OpenCV_VERSION&#125;\") message(STATUS \" libraries=: $&#123;OpenCV_LIBS&#125;\") message(STATUS \" include path=: $&#123;OpenCV_INCLUDE_DIRS&#125;\") # include include_directories( $&#123;Tensorflow_INCLUDES&#125; $&#123;Eigen_DIR&#125; $&#123;OpenBlas_DIR&#125; $&#123;Protobuf_INCLUDES&#125; ) # src cpp aux_source_directory(./src DIR_SRCS) add_executable( main .$&#123;DIR_SRCS&#125;) # target target_link_libraries(main PRIVATE $&#123;OpenCV_LIBS&#125; $&#123;Tensorflow_LIBS&#125; $&#123;Protobuf_LIBS&#125;) code &#x2F;&#x2F;#include &quot;opencv2&#x2F;highgui.hpp&quot; &#x2F;&#x2F;#include &quot;opencv2&#x2F;imgproc.hpp&quot; #include &lt;tensorflow&#x2F;core&#x2F;platform&#x2F;env.h&gt; #include &lt;tensorflow&#x2F;core&#x2F;public&#x2F;session.h&gt; #include &lt;iostream&gt; &#x2F;&#x2F;susing namespace cv; using namespace std; using namespace tensorflow; int main( ) &#123; cout &lt;&lt; &quot;hello tensorflow&quot; &lt;&lt;endl; Session* session; Status status &#x3D; NewSession(SessionOptions(), &amp;session); if (!status.ok()) &#123; cout &lt;&lt; status.ToString() &lt;&lt; endl; cout &lt;&lt;&quot;Session not ok&quot; &lt;&lt; endl; return 1; &#125; cout &lt;&lt; &quot;Session successfully created.&quot;&lt;&lt;endl; return 0; &#125; Protobuf 1）上Github下载protocbuf源码包 https://github.com/protocolbuffers/protobuf/releases/tag/vX.X.X 2）安装依赖包 sudo apt-get install autoconf automake libtool curl make g++ unzip 3）进入源码目录，执行./autogen.sh生成configure文件 4）依次执行 code ./configure make make check sudo make install sudo ldconfig # refresh shared library cache. # 验证版本 siz@ubuntu:~$ protoc --version libprotoc 3.9.2 siz@ubuntu:~$ whereis protoc protoc: /usr/local/bin/protoc Eigen3 简单命令安装 sudo apt-get install libeigen3-dev 源码编译安装 code http://eigen.tuxfamily.org/index.php?title=Main_Page git clone https://gitlab.com/libeigen/eigen.git mkdir build cd build cmake .. sudo make instal # 安装成功后,头文件路径在 /usr/local/include/eigen3/ # CMakeLists.txt 中添加 eigen3 头文件 include_directories( \"/usr/include/eigen3\" ) OpenBlas code git clone https://github.com/xianyi/OpenBLAS.git cd OpenBLAS make make PREFIX=/usr/local/Openblas install","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"OpenCV","slug":"机器学习/OpenCV","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/OpenCV/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.sizaif.com/tags/OpenCV/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"}],"author":"sizaif"},{"title":"GnuTLS 使用手册","slug":"GnuTLS-使用手册","date":"2021-08-10T06:20:43.000Z","updated":"2021-08-14T14:15:24.729Z","comments":true,"path":"posts/89554caf/","link":"","permalink":"https://www.sizaif.com/posts/89554caf/","excerpt":"","text":"GnuTLS 使用手册 😄 @by sizaif 📆 2021-05-17 16:23:57 [TOC] 命令行解析 gnutls-serv https://gnutls.org/manual/html_node/gnutls_002dserv-Invocation.html GnuTLS server gnutls-serv - GnuTLS server Usage: gnutls-serv [ -&lt;flag> [&lt;val>] | --&lt;name>[&#123;=| &#125;&lt;val>] ]... -d, --debug=num Enable debugging - it must be in the range: 0 to 9999 --sni-hostname=str Server's hostname for server name extension --sni-hostname-fatal Send fatal alert on sni-hostname mismatch --alpn=str Specify ALPN protocol to be enabled by the server - may appear multiple times --alpn-fatal Send fatal alert on non-matching ALPN name --noticket Don't accept session tickets --earlydata Accept early data --maxearlydata=num The maximum early data size to accept - it must be in the range: greater than or equal to 1 --nocookie Don't require cookie on DTLS sessions -g, --generate Generate Diffie-Hellman parameters -q, --quiet Suppress some messages --nodb Do not use a resumption database --http Act as an HTTP server --echo Act as an Echo server --crlf Do not replace CRLF by LF in Echo server mode -u, --udp Use DTLS (datagram TLS) over UDP --mtu=num Set MTU for datagram TLS - it must be in the range: 0 to 17000 --srtp-profiles=str Offer SRTP profiles -a, --disable-client-cert Do not request a client certificate - prohibits the option 'require-client-cert' -r, --require-client-cert Require a client certificate --verify-client-cert If a client certificate is sent then verify it. -b, --heartbeat Activate heartbeat support --x509fmtder Use DER format for certificates to read from --priority=str Priorities string --dhparams=file DH params file to use - file must pre-exist --x509cafile=str Certificate file or PKCS #11 URL to use --x509crlfile=file CRL file to use - file must pre-exist --x509keyfile=str X.509 key file or PKCS #11 URL to use - may appear multiple times --x509certfile=str X.509 Certificate file or PKCS #11 URL to use - may appear multiple times --rawpkkeyfile=str Private key file (PKCS #8 or PKCS #12) or PKCS #11 URL to use - may appear multiple times --rawpkfile=str Raw public-key file to use - requires the option 'rawpkkeyfile' - may appear multiple times --srppasswd=file SRP password file to use - file must pre-exist --srppasswdconf=file SRP password configuration file to use - file must pre-exist --pskpasswd=file PSK password file to use - file must pre-exist --pskhint=str PSK identity hint to use --ocsp-response=str The OCSP response to send to client - may appear multiple times --ignore-ocsp-response-errors Ignore any errors when setting the OCSP response -p, --port=num The port to connect to -l, --list Print a list of the supported algorithms and modes --provider=file Specify the PKCS #11 provider library - file must pre-exist --keymatexport=str Label used for exporting keying material --keymatexportsize=num Size of the exported keying material --recordsize=num The maximum record size to advertise - it must be in the range: 0 to 16384 --httpdata=file The data used as HTTP response - file must pre-exist -v, --version[=arg] output version information and exit -h, --help display extended usage information and exit -!, --more-help extended usage information passed thru pager Options are specified by doubled hyphens and their name or by a single hyphen and the flag character. Server program that listens to incoming TLS connections. 使用 服务端 Note that the server listens to port 5556 by default. 例子 gnutls-serv --http --x509keyfile experiments/keystore/rsa2048_key.pem --x509certfile experiments/keystore/rsa2048_cert.pem --x509cafile experiments/keystore/rsa2048_cert.pem --pskpasswd experiments/keystore/keys.psk --priority NORMAL:+PSK:+SRP --mtu 1500 -p 30002\"","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GnuTLS","slug":"GnuTLS","permalink":"https://www.sizaif.com/tags/GnuTLS/"}],"author":"sizaif"},{"title":"Fuckopenssl 1.0.1l","slug":"fuckopenssl-1-0-1l","date":"2021-08-10T06:19:18.000Z","updated":"2021-08-14T14:15:24.739Z","comments":true,"path":"posts/2dc41376/","link":"","permalink":"https://www.sizaif.com/posts/2dc41376/","excerpt":"","text":"fuckopenssl 1.0.1l [TOC] 2021-08-10 14:19:38 @Auther by : sizaif 安装 openssl 1.0.1l 不整幺蛾子, 就默认安装位置 code wget https://www.openssl.org/source/openssl-1.0.1l.tar.gz tar xzf openssl-1.0.1l.tar.gz cd openssl-1.0.1l ./config enable-ssl2 enable-weak-ciphers make &amp;&amp; make install # 默认安装位置在 /usr/local/ssl 更改版本信息 code # 将旧版本的openssl进行备份 # 如果已经是root 了 就不用sudo sudo mv /usr/bin/openssl /usr/bin/openssl.old # 将新版本的openssl进行软链接 sudo ln -s /usr/local/ssl/bin/openssl /usr/bin/openssl #进入etc目录 cd /etc/ #下一步一定要切换到root用户 # 如果已经是root 用户, 直接执行 echo \"/usr/local/lib\" >> ld.so.conf su #将openssl的安装路径加入配置中 echo \"/usr/local/lib\" >> ld.so.conf # 重新加载配置 ldconfig 结果如图: 图片 编译drown git clone https://github.com/Tim---/drown SSL_PREFIX=/usr/local/ssl make 结果如图: 图片 ./decrypt host:port certfile c # ./decrypt 127.0.0.1:7899 certfile c # Passive attack Passive attack # 因为已经将 openssl1.0.1l 配置到系统环境, 所以可以直接使用openssl 命令 # openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days # 结果如下: ######################################################################################### root@iZj6cg4e6vhdv5s3hpkoffZ:~/supengfei/drown/fuck# openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 123 Generating a 2048 bit RSA private key ...........................+++ ....+++ writing new private key to 'key.pem' Enter PEM pass phrase: # 这里输入的是fuckopenssl Verifying - Enter PEM pass phrase: ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [AU]:zh State or Province Name (full name) [Some-State]:beijing Locality Name (eg, city) []:beijing Organization Name (eg, company) [Internet Widgits Pty Ltd]:IBM Organizational Unit Name (eg, section) []:123 Common Name (e.g. server FQDN or YOUR name) []:root Email Address []:123456@123.com ######################################################################################### openssl s_server -cert cert.pem -key key.pem -accept 4433 -www # ######################################################################################### root@iZj6cg4e6vhdv5s3hpkoffZ:~/supengfei/drown/fuck# openssl s_server -cert cert.pem -key key.pem -accept 4433 -www Enter pass phrase for key.pem: # 这里输入的是上面的fuckopenssl Using default temp DH parameters Using default temp ECDH parameters ACCEPT ######################################################################################### # 打开新窗口 # 安装 tshark apt-get install tshark # tshark -i lo -w handshakes.cap tcp port 4433 code # 打开新窗口 # openssl 已经配置到系统环境, 所以直接使用openssl 命令 for i in $(seq 1000) ; do (echo 'GET / HTTP/1.1\\r\\n'; sleep 0.1) | openssl s_client -connect 127.0.0.1:4433 -cipher kRSA; done # 展示 ######################################################################################### New, TLSv1/SSLv3, Cipher is AES256-GCM-SHA384 SSL-Session: Protocol : TLSv1.2 Cipher : AES256-GCM-SHA384 Session-ID: 49EB9A81AD65AE80476F9F72CF4472D17CFB4E33539DAAE5734B5BD2EFD878F3 Session-ID-ctx: 01000000 Master-Key: CCCF32EBBEC91A411D63589FBFAD0B2CE8290797D2749BAF3FFD5C05A4CAB79CFE2E0DAC2939155721DF65218B9757EE Key-Arg : None PSK identity: None PSK identity hint: None SRP username: None Start Time: 1620033794 Timeout : 300 (sec) Verify return code: 0 (ok) --- 128 items in the session cache 0 client connects (SSL_connect()) 0 client renegotiates (SSL_connect()) 0 client connects that finished 1000 server accepts (SSL_accept()) 0 server renegotiates (SSL_accept()) 1000 server accepts that finished 0 session cache hits 0 session cache misses 0 session cache timeouts 0 callback cache hits 872 cache full overflows (128 allowed) --- no client certificate available &lt;/BODY>&lt;/HTML> read:errno=0 ######################################################################################### # get the encrypted pre-master secrets for each session with tshark -r handshakes.cap -d tcp.port==4433,ssl -T fields -e ssl.handshake.epms -Y ssl.handshake.epms | tr -d : 结果如下: 图片 code # To decrypt these handshakes, we need an OpenSSL server accepting SSLv2 connections : openssl s_server -cert cert.pem -key key.pem -accept 4434 -www -ssl2 ######################################################################################### root@iZj6cg4e6vhdv5s3hpkoffZ:~/supengfei/drown/fuck# openssl s_server -cert cert.pem -key key.pem -accept 4434 -www -ssl2 Enter pass phrase for key.pem: # 这里输入的是 上面的pem: fuckfuckfuck Using default temp DH parameters Using default temp ECDH parameters ACCEPT ######################################################################################### # We can now decrypt the encrypted pre-master secret #在drown/fuck/目录下执行 ######################################################################################### # root@iZj6cg4e6vhdv5s3hpkoffZ:~# ll supengfei/drown/fuck/ # total 8024 # drwxr-xr-x 2 root root 4096 May 3 17:33 ./ # drwxr-xr-x 4 root root 4096 May 3 17:28 ../ # -rw-r--r-- 1 root root 1375 May 3 17:14 cert.pem # -rw------- 1 root root 8196592 May 3 17:23 handshakes.cap # -rw-r--r-- 1 root root 1834 May 3 17:14 key.pem # -rw-r--r-- 1 root root 0 May 3 17:33 pms.tx # -rw-r--r-- 1 root root 0 May 3 17:28 pms.txt # root@iZj6cg4e6vhdv5s3hpkoffZ:~# ######################################################################################### #这个位置是cert.perm handshakes.cap 的位置 # ../decrypt 是drown目录下编译后会生成一个decrypt可执行文件位置 tshark -r handshakes.cap -d tcp.port==4433,ssl -T fields -e ssl.handshake.epms -Y ssl.handshake.epms | tr -d : | ../decrypt localhost:4434 cert.pem > pms.txt 结果展示 图片 code RSA 830cdf70dc488c8b 0303b45e46017e9dfefd22a26b7c64648fb2d00fcf8627cb0070132e370ab57a1b595e2544b1668caf3618942c2a0e34 RSA a62c4d1a5c4322e2 0303e37a220b3300e6c0d139d55a1c44c2429f11b0613d746db390beb16ad8bb0203f7494d3e7385a294e4f8a18fa5ae RSA 7215d21d1c22dfb8 0303434023187d88c73a921af635d7861ed60d66ebc4053e487ea85ab6d6b76dd373844063e8da156505dc8466310395 RSA 1976fb27fbccbd36 0303c9c320f9cc92567bc488c502ffacbbef28241348e30df4b2d55fdd7f8680fb201b5f75e02b9bd1db4e8e2c2fdf84 RSA 3b56f9c80a754f77 0303e8abf59f4132b1634f2b4e04bf4362c7f6dae5077dc9b6bb0c48efe0c7be47a256267688c7e28e70a28c830e6af6 RSA 1686f037050931a5 03036cb5a1851a174a9f43f97be770bd22411da688197bef08154d7f91f687dc6e0090d35ce147862e8bcc5c7218398c RSA 6ce5d3fd06970d25 0303e4da20c0d6dd5e03bf97d0ee4d802cab150810df524359ab990df0a01f2d51fe6c69ebfdae99ff1b1c9042367966 RSA 0e447f6c36cadd1c 030313b76ce57518d001229385f6b3ca376821692f72401a32e8b2b9a1322f523b9dc3c4808e7975e6e96c3883c3b8c4 RSA 830280803c06b66a 0303c80069cbb7517d723d8476ff22077e7b33b10c67872093bc7793e01a501d56c2ea2f9d16266b32bd933d8d957f2b RSA 4ee250f545d2f1ae 0303096a212344c48bfaa3153f1d1196c81beb918d61e9497033b9bd4fb118dc474187fb0965de2eff0448c072ee46e0 RSA 7b5fddbfbc5e2586 0303c7714d54a817514c086f8d4004547fb6191cbc5cd36ec7816b4ab81295278b5ba13054014413cd3abf75faa05d60 RSA 6053a37a45c64592 03035126dad66420ee530e50be0cfdb6aca5cb3e6897c3a2c1cb56c39704112efd36069e450814ccd70b629dc23e26b4 RSA a04a28e475029688 03036657caed02639f6b450a0c7293f4abf3ad188652bd443f2d27e6ffe53f859d1d91441aa0fcc646648557ecb910f8 RSA 1d37821396fecd87 030375a2214a9b475fe93ddd424a71536a0642a07d0d093abdcc84a0e1b89d3f052719e44d1816f2698d24b67ef7cc26 RSA 62a5f513fc94585b 0303a873790bf018f5d6c4e1ac4d87487a34e58471762a2dffd6d92e122ec284b7dc2206569118e0a6ebfb4c2960457d RSA 8de0c774b04a20d2 0303e8748fbea20c72709a8dc436fc631521cbd068c6beddfacd4fb224ef03da92e76af9bbf3b740908efd699a797973 RSA a7575ef2b95aeeeb 03033f49c4e3b9642fddcda12c05601d69113adf7bebc4c0cb963ff898373a50a0494564c97a9e0ac3e18e1f709b68a9","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"}],"author":"sizaif"},{"title":"安装Openssl GNUTLS WolfSSL 手册","slug":"安装Openssl-GNUTLS-WolfSSL-手册","date":"2021-08-10T06:11:40.000Z","updated":"2021-08-14T14:15:24.747Z","comments":true,"path":"posts/b924c044/","link":"","permalink":"https://www.sizaif.com/posts/b924c044/","excerpt":"","text":"安装Openssl GNUTLS WolfSSL 手册 😄 @Auther sizaif 📆2021-05-18 09:19:35 [TOC] OpenSSL 项目地址:https://www.openssl.org/ 安装依赖库 # 安装ssl 依赖库 sudo apt update sudo apt-get install libssl-dev make 下载源码并进入文件 https://www.openssl.org/source/old/1.1.1/ # 下载OpenSSL对应版本源码 https://www.openssl.org/source/old/1.1.1/openssl-1.1.1j.tar.gz # 进入文件后 cd openssl-XXX/ 编译安装 编译安装有两种方式, 一种是编译后,不进行安装,即不把编译后的文件安装到系统环境下, 输入openssl version版本不变 另一种是编译后进行安装,更换到系统环境下 第一种,仅编译, 使用时通过/openssl-xxx/apps/openssl 使用这个版本的openssl 这样的优势是,可以快速测试多个openssl的版本,而不用重复更新安装 code # 配置环境 prefix 是安装目录，openssldir是配置文件目录 # # Configure --prefix=/YOUR PATH ./Configure # or ./config # ./config --prefix=/YOUR PATH # 编译安装 #因为这里我们不需要安装,只需要拿到编译的结果去运行 # 所以 不需要make install make 第二种,编译安装, 使用时直接使用openssl 命令来使用新安装的版本 code # 编译 需要等好长时间, 不如趁这个功夫取喝个茶,上个洗手间 make # 编译完成后, 进行安装 , 等待时间也不短, 不如去刷个小视频 # make install # 将旧版本的openssl进行备份 sudo mv /usr/bin/openssl /usr/bin/openssl.old # 将新版本的openssl进行软链接 sudo ln -s /usr/local/bin/openssl /usr/bin/openssl #进入etc目录 cd /etc/ #下一步一定要切换到root用户 su #将openssl的安装路径加入配置中 echo \"/usr/local/lib\" >> ld.so.conf # 重新加载配置 ldconfig # 测试 版本 得到如下结果 openssl version >OpenSSL 1.1.1b 26 Feb 2019 # 测试 ll /usr/local/include/ ll /usr/local/lib/ # 如下结果 #如果需要更换版本的话,修改软链接的名称即可，参照： #将旧版本进行备份 sudo mv /usr/include/openssl /usr/include/openssl.old #将新版本进行软链接 sudo ln -s /usr/local/include/openssl /usr/include/openssl GnuTLS 项目地址: https://www.gnutls.org/index.html 安装依赖库 编译需要 libnettle 和gmplib Debian/Ubuntu: Debian/Ubuntu apt-get install -y dash git-core autoconf libtool gettext autopoint apt-get install -y automake autogen nettle-dev libp11-kit-dev libtspi-dev libunistring-dev apt-get install -y guile-2.0-dev libtasn1-6-dev libidn2-0-dev gawk gperf apt-get install -y libunbound-dev dns-root-data bison help2man gtk-doc-tools apt-get install -y texinfo texlive texlive-generic-recommended texlive-extra-utils apt-get install pkg-config 编译安装 解释如下 The GnuTLS Guile bindings are available for the Guile 3.0 and 2.2 series, as well as the legacy 2.0 and even 1.8 series. By default they are installed under the GnuTLS installation directory, typically /usr/local/share/guile/site/). Normally Guile will not find the module there without help. You may experience something like this: >$ guile >… >scheme@(guile-user)> (use-modules (gnutls)) >ERROR: no code for module (gnutls) There are two ways to solve this. The first is to make sure that when building GnuTLS, the Guile bindings will be installed in the same place where Guile looks. You may do this by using the --with-guile-site-dir parameter as follows: >$ ./configure --with-guile-site-dir=no 命令如下 # --with-guile-site-dir=no 构建GnuTLS时，Guile绑定将安装在与Guile相同的位置, 解释如上 # 因为只需要测试GnuTls 所以使用如下的命令 # 视实际情况决定 ./configure --with-guile-site-dir=no --with-included-libtasn1 --with-included-unistring --without-p11-kit --disable-guile --disable-doc ./configure结果 ./configure结果 configure: summary of build options: version: 3.6.7 shared 53:2:23 Host/Target system: x86_64-pc-linux-gnu Build system: x86_64-pc-linux-gnu Install prefix: /usr/local Compiler: gcc Valgrind: no CFlags: -g -O2 Library types: Shared=yes, Static=no Local libopts: yes Local libtasn1: yes Local unistring: yes Use nettle-mini: no Documentation: no (manpages: no) configure: External hardware support: /dev/crypto: no Hardware accel: x86-64 Padlock accel: yes Random gen. variant: getrandom PKCS#11 support: no TPM support: no configure: Optional features: (note that included applications might not compile properly if features are disabled) SSL3.0 support: no SSL2.0 client hello: yes Allow SHA1 sign: no DTLS-SRTP support: yes ALPN support: yes OCSP support: yes SRP support: yes PSK support: yes DHE support: yes ECDHE support: yes GOST support: yes Anon auth support: yes Heartbeat support: yes IDNA support: no Non-SuiteB curves: no FIPS140 mode: no configure: Optional libraries: Guile wrappers: no C++ library: yes DANE library: no OpenSSL compat: no configure: System files: Trust store pkcs11: Trust store dir: Trust store file: /etc/ssl/certs/ca-certificates.crt Blacklist file: CRL file: Priority file: /etc/gnutls/default-priorities DNSSEC root key file: /etc/unbound/root.key configure: WARNING: *** *** The DNSSEC root key file in /etc/unbound/root.key was not found. *** This file is needed for the verification of DNSSEC responses. *** Use the command: unbound-anchor -a \"/etc/unbound/root.key\" *** to generate or update it. *** 安装 同Openssl 一样, 有两种方式, 仅 make 和 make &amp;&amp; make install code # 编译 make # 编译后 在 src 目录下 可以得到 gnutls-cli gnutls-cli-debug gnutls-serv 可执行文件 # 验证版本 $root@380xxx:/xxx/gnutls-3.6.7# ./src/gnutls-serv -v gnutls-serv 3.6.7 Copyright (C) 2000-2019 Free Software Foundation, and others, all rights reserved. This is free software. It is licensed for use, modification and redistribution under the terms of the GNU General Public License, version 3 or later &lt;http://gnu.org/licenses/gpl.html> Please send bug reports to: &lt;bugs@gnutls.org> ######################################################################################## # 如果 安装的话 执行 make install make install # 会在 /usr/local/include/gnutls 生成头文件 # /usr/local/bin/ 下 生成 gnutls-cli gnutls-cli-debug gnutls-serv 可执行文件 # 验证版本 $root@380xxx:/xxx/gnutls-3.6.7# /usr/local/bin/gnutls-serv -v gnutls-serv 3.6.7 Copyright (C) 2000-2019 Free Software Foundation, and others, all rights reserved. This is free software. It is licensed for use, modification and redistribution under the terms of the GNU General Public License, version 3 or later &lt;http://gnu.org/licenses/gpl.html> Please send bug reports to: &lt;bugs@gnutls.org> WolfSSL https://github.com/wolfSSL/wolfssl https://www.wolfssl.com/ 下载源码 https://www.wolfssl.com/download/# 手动下载 编译安装 ./configure#./configure --help ./configure --enable-psk --enable-pwdbased --enable-rsa --enable-sha --enable-debug --disable-dh --disable-ecc C_EXTRA_FLAGS=-DWOLFSSL_STATIC_PSK 结果 code Configuration summary for wolfssl version 4.7.0 * Installation prefix: /usr/local * System type: pc-linux-gnu * Host CPU: x86_64 * C Compiler: gcc * C Flags: -DWOLFSSL_STATIC_PSK -g -ggdb -O0 -Wno-pragmas -Wall -Wno-strict-aliasing -Wextra -Wu nknown-pragmas --param=ssp-buffer-size=1 -Waddress -Warray-bounds -Wbad-function-cast -Wchar-subscripts -Wcomment -Wfloa t-equal -Wformat-security -Wformat=2 -Wmaybe-uninitialized -Wmissing-field-initializers -Wmissing-noreturn -Wmissing-pro totypes -Wnested-externs -Wnormalized=id -Woverride-init -Wpointer-arith -Wpointer-sign -Wredundant-decls -Wshadow -Wsig n-compare -Wstrict-overflow=1 -Wswitch-enum -Wundef -Wunused -Wunused-result -Wunused-variable -Wwrite-strings -fwrapv * C++ Compiler: * C++ Flags: * CPP Flags: * CCAS Flags: -DWOLFSSL_STATIC_PSK * LIB Flags: -pie -z relro -z now * Debug enabled: yes * Coverage enabled: * Warnings as failure: no * make -j: 9 * VCS checkout: no Features * FIPS: no * Single threaded: no * Filesystem: yes * OpenSSH Build: no * OpenSSL Extra API: no * OpenSSL Coexist: no * Old Names: yes * Max Strength Build: no * Distro Build: no * Reproducible Build: no * fastmath: yes * Assembly Allowed: yes * sniffer: no * snifftest: no * ARC4: no * AES: yes * AES-NI: no * AES-CBC: yes * AES-GCM: yes * AES-CCM: no * AES-CTR: no * AES-CFB: no * AES-OFB: no * DES3: no * IDEA: no * Camellia: no * NULL Cipher: no * MD2: no * MD4: no * MD5: yes * RIPEMD: no * SHA: yes * SHA-224: yes * SHA-384: yes * SHA-512: yes * SHA3: yes * SHAKE256: yes * BLAKE2: no * BLAKE2S: no * CMAC: no * keygen: no * certgen: no * certreq: no * certext: no * certgencache: no * HC-128: no * RABBIT: no * CHACHA: yes * XCHACHA: no * Hash DRBG: yes * PWDBASED: yes * scrypt: no * wolfCrypt Only: no * HKDF: yes * X9.63 KDF: no * MD4: no * PSK: yes * Poly1305: yes * LEANPSK: no * LEANTLS: no * RSA: yes * RSA-PSS: yes * DSA: no * DH: no * DH Default Parameters: yes * ECC: no * ECC Custom Curves no * ECC Minimum Bits 224 * CURVE25519: no * ED25519: no * CURVE448: no * ED448: no * FPECC: no * ECC_ENCRYPT: no * ASN: yes * Anonymous cipher: no * CODING: yes * MEMORY: yes * I/O POOL: no * LIGHTY: no * HAPROXY: no * STUNNEL: no * Apache httpd: no * NGINX: no * ASIO: no * LIBWEBSOCKETS: no * Qt no * Qt Unit Testing no * SIGNAL: no * ERROR_STRINGS: yes * DTLS: no * SCTP: no * Indefinite Length: no * Multicast: no * SSL v3.0 (Old): no * TLS v1.0 (Old): no * TLS v1.1 (Old): yes * TLS v1.2: yes * TLS v1.3: yes * Post-handshake Auth: no * Early Data: no * Send State in HRR Cookie: no * OCSP: no * OCSP Stapling: no * OCSP Stapling v2: no * CRL: no * CRL-MONITOR: no * Persistent session cache: no * Persistent cert cache: no * Atomic User Record Layer: no * Public Key Callbacks: no * NTRU: no * QSH: no * Whitewood netRandom: no * Server Name Indication: no * ALPN: no * Maximum Fragment Length: no * Trusted CA Indication: no * Truncated HMAC: no * Supported Elliptic Curves: no * FFDHE only in client: no * Session Ticket: no * Extended Master Secret: yes * Renegotiation Indication: no * Secure Renegotiation: no * Fallback SCSV: no * Keying Material Exporter: no * All TLS Extensions: no * PKCS#7 no * S/MIME no * wolfSSH no * wolfTPM no * wolfSCEP no * Secure Remote Password no * Small Stack: no * Linux Kernel Module: no * valgrind unit tests: no * LIBZ: no * Examples: yes * Crypt tests: yes * Stack sizes in tests: no * Heap stats in tests: no * User Crypto: no * Fast RSA: no * Single Precision: no * SP math implementation: no * Async Crypto: no * PKCS#11: no * PKCS#12: yes * Cavium Nitrox: no * Cavium Octeon (Sync): no * Intel Quick Assist: no * ARM ASM: no * AES Key Wrap: no * Write duplicate: no * Xilinx Hardware Acc.: no * Inline Code: yes * Linux AF_ALG: no * Linux devcrypto: no * Crypto callbacks: no code make # 如果遇到错误 'aclocal-1.15' is missing on your system” # 先执行autoreconf -f -i 在执行 ./configure 在 make ## 安装 如上 sudo make install # To test the build, run the testsuite program from the root wolfSSL directory: ./testsuite/testsuite.test # or use autoconf to run the testsuite as well as the standard wolfSSL API and crypto tests: make test ############################ # 如果没有configure 使用 cmake # 安装 cmake sudo apt-get install cmake # Usage: mkdir build &amp;&amp; cd build cmake .. cmake --build . 结果运行 在根目录下/exaples/ 中 有 server 和 client","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GnuTLS","slug":"GnuTLS","permalink":"https://www.sizaif.com/tags/GnuTLS/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"},{"name":"WolfSSL","slug":"WolfSSL","permalink":"https://www.sizaif.com/tags/WolfSSL/"}],"author":"sizaif"},{"title":"本地Navicat连接本地docker容器中mysql","slug":"本地navicat连接本地docker容器中mysql","date":"2021-08-10T06:04:59.000Z","updated":"2021-09-19T10:15:32.553Z","comments":true,"path":"posts/35862d23/","link":"","permalink":"https://www.sizaif.com/posts/35862d23/","excerpt":"","text":"本地navicat连接本地docker容器中mysql 😄 @Auther by sizaif 📆 2021-06-24 17:54:18 [TOC] 修订历史 2021-06-24 17:54:31: 首次编辑 2021-06-24 22:28:18: update bug 具体步骤 如果已经有了mysql镜像, 直接跳过,到docker mysql容器中 docker 拉去 mysql 镜像 $ docker pull mysql 启动MySQL镜像 $ docker run --name=mysql -itd -p &lt;宿主机映射端口>:3306 -e MYSQL_ROOT_PASSWORD=&lt;密码> mysql 进入MySQL容器 $ docker exec -it mysql /bin/bash 进入MySQL 设置允许外部登录的mysql用户 $ mysql -uroot -p&lt;密码> # 设置允许外部登录的mysql用户: 'test' host监听地址:'%' 密码 test $ mysql> CREATE USER If Not Exists 'test'@'%' IDENTIFIED WITH mysql_native_password BY 'test'; # 赋予用户权限 $ mysql> GRANT all privileges ON test.* TO 'test'@'%' identified by 'test'; # 刷新 $ mysql>flush privileges; 修改mysql配置，允许任意主机访问 # 修改 mysqld.cnf中 bind-address监听地址loaclhst为0.0.0.0 $ sed -i 's/^bind-address.*$/bind-address=0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf # 重启mysql $ service mysql restart 若嫌进入mysql太麻烦直接运行如下命令,替换掉&lt;&gt;中内容 #修改mysql配置，允许任意主机访问 $ sed -i 's/^bind-address.*$/bind-address=0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf $ service mysql restart # 新建允许外部登录的mysql用户：'&lt;test>'@'%'，密码&lt;test> USER=`cat /etc/mysql/debian.cnf |grep user|head -1|awk '&#123;print $3&#125;'` PW=`cat /etc/mysql/debian.cnf |grep password|head -1|awk '&#123;print $3&#125;'` mysql -u$&#123;USER&#125; -p$&#123;PW&#125; -e\"CREATE USER If Not Exists '&lt;test>'@'%' IDENTIFIED WITH mysql_native_password BY '&lt;test>';\" mysql -u$&#123;USER&#125; -p$&#123;PW&#125; -e\"GRANT all privileges ON &lt;your mysql continer name>.* TO '&lt;test>'@'%' identified by '&lt;test>';flush privileges;\" navicat 远程连接 然后远程连接【宿主机ip:&lt;宿主机映射端口&gt;】，使用新建的用户登录mysql即可。 >$ docker run --name=mysql -itd -p &lt;宿主机映射端口>:3306 -e MYSQL_ROOT_PASSWORD=&lt;密码> mysql 问题发现整理 报2013错误 这个原因一般是由mysql中已经设定用户的远程host为’%',但是mysqld.cnf 或 my.cnf中 bind-address 监听地址为localhost导致 报1045错误 Access defined 一般是由于密码不正确或用户不正确导致","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"},{"name":"Mysql","slug":"技术向/Mysql","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mysql/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.sizaif.com/tags/Mysql/"},{"name":"教程","slug":"教程","permalink":"https://www.sizaif.com/tags/%E6%95%99%E7%A8%8B/"}],"author":"sizaif"},{"title":"生成Openssl && Gnutls  Keys","slug":"生成openssl-gnutls-keys","date":"2021-08-10T06:03:30.000Z","updated":"2021-08-14T14:15:24.753Z","comments":true,"path":"posts/bb0d4a87/","link":"","permalink":"https://www.sizaif.com/posts/bb0d4a87/","excerpt":"","text":"生成openssl &amp;&amp; gnutls keys 😄 @by sizaif 📆 2021-05-17 20:36:00 [TOC] Openssl 代码 # Generate DH parameters openssl dhparam -outform PEM -out dhparams.pem -5 2048 # Generate CA key and certificate CA.pl or CA.sh /usr/lib/ssl/misc/CA.pl -newca # Generate server key and certificate openssl req -newkey rsa:1024 -nodes -keyout server.key -out server.req openssl ca -out server.crt -infiles server.req # Generate client key and certificate openssl req -newkey rsa:1024 -nodes -keyout client.key -out client.req openssl ca -out client.crt -infiles client.req # Generate client DH key and certificate openssl genpkey -paramfile dhparams.pem -out client_dh.key openssl pkey -in client_dh.key -pubout -out client_dh.pub #~/SSL/openssl/openssl-1.0.2/apps/openssl x509 -req -in client.req -CAkey demoCA/private/cakey.pem -CA demoCA/cacert.pem -force_pubkey client_dh.pub -out client_dh.crt -CAcreateserial -extensions v3_req -extfile ./openssl.cnf # Get keys in Java keystore # 这里设置服务端 的名称为 server 密码为 changeit openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12 -name server -CAfile ca.crt -caname root keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore keystore -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias server # 这里设置客户端 的名称为 client 密码为 changeit openssl pkcs12 -export -in client.crt -inkey client.key -out client.p12 -name client -CAfile ca.crt -caname root keytool -importkeystore -srckeystore client.p12 -destkeystore keystore -srcstoretype PKCS12 -srcstorepass changeit -deststorepass changeit -destkeypass changeit -alias client #openssl pkcs12 -export -in client_dh.crt -inkey client_dh.key -out client_dh.p12 -name clientdh -CAfile ca.crt -caname root #keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore keystore -srckeystore client_dh.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias clientdh # Get keys in Netscape keystore certutil -N -d . certutil -A -n ca -i demoCA/cacert.pem -d . -t TC certutil -A -n server -i server.crt -d . -t P pk12util -d . -i server.p12 certutil -A -n client1 -i client.crt -d . -t P pk12util -d . -i client.p12 GnuTLS code #生成CA私钥 certtool --generate-privkey > x509-ca-key.pem # 创建CA模版 vim ca.tmpl cn = \"GnuTLS test CA\" organization = \"TLSTest\" serial = 1 expiration_days = 3650 ca signing_key cert_signing_key crl_signing_key #生成CA证书 certtool --generate-self-signed --load-privkey x509-ca-key.pem --template ca.tmpl --outfile x509-ca.pem #生成Server私钥 certtool --generate-privkey > x509-server-key.pem #创建Server证书模版 vim server.tmpl cn = \"GnuTLS test server\" organization = \"TLSTest\" expiration_days = 3650 signing_key encryption_key tls_www_server #生成Server证书 certtool --generate-certificate --load-privkey x509-server-key.pem \\ --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \\ --template server.tmpl --outfile x509-server.pem #生成Client私钥 certtool --generate-privkey > x509-client-key.pem #创建Client证书模版 vim client.tmpl cn = GnuTLS test client tls_www_client encryption_key signing_key tls_www_client #生成Client证书 certtool --generate-certificate --load-privkey x509-client-key.pem \\ --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \\ --template client.tmpl --outfile x509-client.pem #转换为p12证书 以及java keystore ;Get keys in Java keystore # 这里设置的名称为 client # 密码为123456 certtool --to-p12 --load-ca-certificate x509-ca.pem \\ --load-privkey x509-client-key.pem --load-certificate x509-client.pem \\ --outder --outfile x509-client.p12 keytool -importkeystore -srckeystore x509-client.p12 -destkeystore keystore -srcstoretype PKCS12 -srcstorepass 123456 -deststorepass 123456 -alias client # 这里设置的名称为 server # 密码为123456 certtool --to-p12 --load-ca-certificate x509-ca.pem \\ --load-privkey x509-server-key.pem --load-certificate x509-server.pem \\ --outder --outfile x509-server.p12 keytool -importkeystore -srckeystore x509-server.p12 -destkeystore keystore -srcstoretype PKCS12 -srcstorepass 123456 -deststorepass 123456 -alias server","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GnuTLS","slug":"GnuTLS","permalink":"https://www.sizaif.com/tags/GnuTLS/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"}],"author":"sizaif"},{"title":"使用代理进行 Docker Build 问题的解决思路","slug":"使用代理进行-docker-build-问题的解决思路","date":"2021-08-10T06:01:12.000Z","updated":"2021-09-19T10:15:19.803Z","comments":true,"path":"posts/d4ac1b81/","link":"","permalink":"https://www.sizaif.com/posts/d4ac1b81/","excerpt":"","text":"使用代理进行 docker build 问题的解决思路 😄 @Auther: sizaif 📆 2021-06-10 00:03:14 🐔 转载至: 原文作者: simpleapples 原文链接: http://www.simpleapples.com/2019/04/18/building-docker-image-behind-proxy/ 许可协议: 知识共享署名-非商业性使用 4.0 国际许可协议 [TOC] 问题描述 在使用 docker build 打包镜像时，遇到了需要使用代理访问网络的需求。使用如下的 Dockerfile 来模拟这个场景： FROM golang:1.12 RUN curl www.google.com --max-time 3 国内一般网络环境下，curl www.google.com 是无法正常返回的，加入 –max-time 让 curl 的耗时不要太长。 配置 http_proxy 变量 首先需要在环境变量中设置 http_proxy 和 https_proxy，使得访问网络的命令（这里使用 curl 来代表）能够通过环境变量中配置的代理服务器访问 www.google.com。 docker build 命令虽然是在 docker 所在的宿主机上执行的，看上去像是直接使用了宿主机的网络环境，但实际上docker build 也是启动了一个container进行构建，所以在构建过程中的所有命令都是在 container 中执行的，http_proxy 和 https_proxy 的配置也应该是在 container 中进行的。可以使用 ENV 来配置 container 中的环境变量。 代理服务器启动在宿主机的 1087 端口上，修改 dockerfile 文件： FROM golang:1.12 ENV http_proxy \"http://127.0.0.1:1087\" ENV HTTP_PROXY \"http://127.0.0.1:1087\" ENV https_proxy \"http://127.0.0.1:1087\" ENV HTTPS_PROXY \"http://127.0.0.1:1087\" RUN curl www.google.com --max-time 3 重新执行 docker build 会发现 curl 依旧无法访问 www.google.com，从报错信息上可以看到 127.0.0.1 上的 1087 端口上并没有服务。 访问宿主机 由于 container 默认是桥接网络，宿主机和 container 是平级的，被放在了一个虚拟的网段里。访问宿主机上的代理服务器，对于 container 来说实际上是访问另一台机器上的服务器，127.0.0.1 指向的是 container 本身。在 docker 默认的桥接网络中，宿主机的 IP 一般是 172.17.0.1（Linux），或者 192.168.65.1（MacOS），可以将 http_proxy 中的 IP 换成 172.17.0.1/192.168.65.1，来实现通过宿主的代理服务器访问网络，修改 dockerfile： FROM golang:1.12 ENV http_proxy \"http://172.17.0.1:1087\" ENV HTTP_PROXY \"http://172.17.0.1:1087\" ENV https_proxy \"http://172.17.0.1:1087\" ENV HTTPS_PROXY \"http://172.17.0.1:1087\" RUN curl www.google.com --max-time 3 虽然使用这种方式可以达到目的，但是如果编译环境变了或者代理服务器的配置变了，哪怕只是操作系统从 Linux 变成了 MacOS，都得修改 dockerfile，显然不够解耦，也不方便。 配置网络模式 docker 中还有一种 host 网络模式，就是让 container 使用宿主机的网络，相当于 container 在网络层面和宿主机不做隔离，使用这种网络模式执行 docker build，就不需要在 dockerfile 中添加 http_proxy 环境变量，container 可以直接读取宿主上的环境变量。 首先在宿主上导入 http_proxy 环境变量： export http_proxy=\"http://127.0.0.1:7890\" export HTTP_PROXY=\"http://127.0.0.1:7890\" export https_proxy=\"http://127.0.0.1:7890\" export HTTPS_PROXY=\"http://127.0.0.1:7890\" 接下来将 dockerfile 简化： FROM golang:1.12 RUN curl www.google.com --max-time 3 重新执行 docker build，加上参数 –network host，使用宿主网络： docker build --network host . 执行后 curl 就可以像在宿主上直接执行一样，通过代理访问 www.google.com 了。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"证书间的道道油","slug":"证书间的道道油","date":"2021-08-10T05:57:13.000Z","updated":"2021-08-14T14:15:24.757Z","comments":true,"path":"posts/b495581d/","link":"","permalink":"https://www.sizaif.com/posts/b495581d/","excerpt":"","text":"证书间的道道油 😄 @auther sizaif 📆 2021-05-20 17:29:05 [TOC] 什么是PEM文件格式 ( Privacy-Enhanced Mail) 是一种事实上的文件格式，用于存储和发送加密密钥、证书和其他数据，基于一组定义“增强隐私的邮件”的1993 IETF标准 许多密码学标准使用ASN.1来定义它们的数据结构，并使用区分编码规则**(Distinguished Encoding Rules, DER)**来序列化这些结构,因为DER产生二进制输出，所以通过只支持ASCII的系统(如电子邮件)传输结果文件可能很困难。 PEM格式通过使用base64对二进制数据进行编码解决了这个问题。PEM还定义了一行页眉，包括“-----BEGIN”、一个标签和“-----”;一行页脚，包括“-----END”、一个标签和“-----”。标签决定了编码的消息类型。常用标签有“CERTIFICATE”、“CERTIFICATE REQUEST”、“PRIVATE KEY”、“X509 CRL”等。 PEM数据通常存储在后缀为“ .pem”，后缀为“ .cer”或“ .crt”（用于证书）或后缀“ .key”（用于公钥或私钥）的文件中。[3] PEM文件中的标签比文件后缀更准确地表示数据类型，因为可以将许多不同类型的数据保存在“ .pem”文件中。 什么是X.690 X.690是一个ITU-T标准，指定了几种ASN.1编码格式: Basic Encoding Rules (BER) Canonical Encoding Rules (CER) Distinguished Encoding Rules (DER) 参考链接: https://en.wikipedia.org/wiki/X.690#DER_encoding BER encoding 基本编码规则的格式指定编码ASN.1数据结构的自描述和自定界格式。每个数据元素都被编码为类型标识符、长度描述、实际数据元素以及必要时的内容结束标记。这些编码类型通常称为类型-长度-值或TLV编码。这种格式允许接收方从不完整的流中解码ASN.1信息，而不需要任何关于数据的大小、内容或语义的预先知识 DER encoding DER (Distinguished Encoding Rules) 是BER的一个受限变体，用于为ASN.1描述的数据结构产生明确的传输语法。像CER, DER编码是有效的BER编码。除一个发送者的选项外，DER与BER是一样的。 DER是BER的子集，提供了一种对ASN.1值进行编码的方法。DER适用于需要唯一编码的情况，例如在密码学中，并确保需要进行数字签名的数据结构产生唯一的序列化表示。DER可以被认为是误码率的标准形式。例如，在BER中，一个布尔值true可以被编码为255个非零字节值中的任何一个，而在DER中，有一种方法可以将布尔值true编码。 最重要的DER编码约束是: 长度编码必须使用确定的形式 ​ 此外，必须使用尽可能短的长度编码 位字符串、八字节字符串和受限字符串必须使用原始编码 Set中的元素根据标记值按排序顺序进行编码 DER广泛用于X.509等数字证书。 CER encoding CER(规范编码规则)是BER的一种受限变体，用于为ASN.1描述的数据结构生成明确的传输语法。BER提供了对数据值如何编码的选择，而CER(连同DER)只从基本编码规则允许的编码中选择一种编码，消除了其他选项。当必须保留编码时，CER是有用的;例如，在证券交易中 BER、CER、DER比较 BER格式和CER或DER格式之间的关键区别是基本编码规则提供的灵活性 BER，如上所述，是ITU-T X.690给出的用于ASN.1数据结构传输的编码规则的基本集合。它为发送方想要发送的数据结构提供了明确的编码规则，但也给发送方留下了一些编码选择.正如X.690标准中所述，“作为发送方的选项，基本编码规则允许替代编码。”声称符合基本编码规则的接收方应支持所有替代方案” 接收方必须准备好接受所有合法编码，才能合法声明BER-compliance,相比之下，CER和DER都将可用长度规范限制为单个选项。因此，CER和DER是误码率的限制形式，用于消除误码率标准的歧义。 CER和DER的不同之处在于它们对发送方施加的限制。CER和DER的基本区别是，在某些精确定义的情况下，DER采用定长形式，CER采用不定长形式。也就是说，DER总是具有前导长度信息，而CER使用内容结束八位元，而不是提供编码数据的长度。因此，对于大的编码值，CER需要较少的元数据，而对于小的编码值，DER需要较少的元数据。 为了便于编码规则之间的选择，X.690标准文档提供了以下指导: 如果编码的值足够小，能够适应可用内存，并且需要快速跳过一些嵌套的值，那么区分编码规则比规范编码规则更合适。规范化编码规则比杰出的编码规则更合适的如果有需要编码值太大了,他们不能轻易适应可用内存或需要编码和传输的一部分价值在整个价值是可用的。基本编码规则比规范的或专有的编码规则i更合适 公钥,私钥,数字证书 公钥私钥 Bob有两把钥匙，一把叫公钥（public key），一把叫私钥（private key） Bob的公钥可以公开供其他人使用，他只保留自己的私钥。公钥和私钥用来加解密数据，如果使用任意一把来加密数据，那么只有使用另外一把才能解密数据。 Susan想给Bob写信，她可以使用Bob的公钥将内容加密以后发送给Bob，Bob收到以后，使用私钥解密以便阅读内容。Bob的的其他同事即使截获了Susan发送给Bob的信件，由于没有Bob的私钥，也无法解密，从而确保数据安全。以上就是使用公钥和私钥加解密的过程演示。 如果Bob给Susan回信，如何保证数据安全呢？他可以使用Susan的公钥加密消息后发给Susan，Susan使用自己的私钥解密后阅读。所以保护好自己的私钥是多么重要的事情啊。 数字签名 现在Bob决定给Pat写一份信，信件的内容不用加密，但是要保证Pat收到信件后，能够确认信件的确是Bob发出的，而不是别人冒充Bob发给Pat的，应该如果做呢？ Bob将信件通过hash软件计算一下，得到一串消息摘要（有的文章也称之为“hash值”）。这一过程能够保证2点： 1、过程不可逆。即不能通过消息摘计算出信件的内容。 2、消息摘要不会重复。即如果信件有任何改动，再次hash计算出的消息摘要一定不会和改动前的消息摘要一致。 然后，Bob使用自己的私钥，将消息摘要加密。加密后的结果，我们称之为“数字签名”。现在，Bob就可以将信件连同数字签名一起发给Pat。 Pat收到信件以后，会做2件事： 1、使用Bob的公钥将数字签名解密，如果顺利解密，说明的确是Bob签发的数字签名，不是别人签发的，因为Bob的私钥没有公开。 2、Pat使用hash软件对信件再次进行hash计算，和解密数字签名得到的消息摘要对比，如果一致，说明信件没有篡改，确实是Bob发出的。这就是数字签名的过程。它能够确保签名人发出的消息不被篡改，也能证明的确是签名人发出的消息。 数字证书 使用数字证书可以确保公钥不被冒充。数字证书是经过权威机构（CA）认证的公钥，通过查看数字证书，可以知道该证书是由那家权威机构签发的，证书使用人的信息，使用人的公钥。它有以下特点： 1、由专门的机构签发的数字证书才安全有效。 2、签发数字证书是收费的。 3、不会被冒充，安全可信。 4、数字证书有使用期限，过了使用期限，证书变为不可用。CA也可以在试用期内，对证书进行作废操作。 公钥私钥证书生成 参考: 生成OpenSSL &amp;&amp; GntTLS &amp;&amp; WolfSSL keys 文档","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"}],"author":"sizaif"},{"title":"JAXB 学习","slug":"JAXB-学习","date":"2021-08-10T05:53:06.000Z","updated":"2021-09-19T10:14:38.067Z","comments":true,"path":"posts/a893dad1/","link":"","permalink":"https://www.sizaif.com/posts/a893dad1/","excerpt":"","text":"JAXB 学习 😄 @Auther: sizaif 📆 2021-06-06 21:13:30 [TOC] 说明 Java XML绑定体系结构(JAXB)通过JAXB应用程序的示例介绍了Java XML绑定体系结构(JAXB)技术。 在阅读本教程之前 要理解和使用XML绑定Java体系结构(JAXB)教程中的信息，您应该了解以下技术: Java编程语言及其开发环境 可扩展标记语言 本教程只详细研究JAXB特有的代码。 JAXB概论 用于XML绑定的Java体系结构(JAXB)提供了一种快速而方便的方法来绑定XML模式和Java表示，使得Java开发人员可以很容易地在Java应用程序中合并XML数据和处理函数。作为此过程的一部分，JAXB提供了将XML实例文档编组(读取)为Java内容树，然后将Java内容树编组(写入)为XML实例文档的方法。JAXB还提供了一种从Java对象生成XML模式的方法。 AXB 2.0包含了JAXB 1.0的几个重要改进: 支持所有W3C XML Schema特性。(JAXB 1.0没有为某些W3C XML Schema特性指定绑定。) 通过添加javax.xml.bind.annotation包来控制这种绑定，支持将java绑定到xml。(JAXB 1.0指定了XML模式到java的映射，但没有指定java到XML模式的映射。) 显著减少了生成的模式派生类的数量。 通过JAXP 1.3验证api提供的额外验证功能。 较小的运行时库。 本课描述JAXB体系结构、函数和核心概念，并提供示例和使用JAXB的逐步过程。 JAXB架构 本节描述JAXB处理模型中的组件和交互。 结构概述 下图显示了组成JAXB实现的组件。 图:JAXB体系结构概述 JAXB实现由以下架构组件组成: 模式编译器:将源模式绑定到一组从模式派生的程序元素。绑定由基于xml的绑定语言描述。 模式生成器:将一组现有的程序元素映射到派生的模式。映射是由程序注释描述的。 绑定运行时框架:提供解组(读取)和编组(写入)操作，以便使用模式派生的或现有的程序元素访问、操作和验证XML内容。 JAXB绑定过程 下图显示了JAXB绑定过程中发生的事情。 图:JAXB绑定过程中的步骤 JAXB数据绑定过程中的一般步骤是: 生成类(Generate classes):将XML模式用作JAXB绑定编译器的输入，以基于该模式生成JAXB类。 编译类(Compile classes):必须编译所有生成的类、源文件和应用程序代码。 解组(Unmarshal):根据源模式中的约束编写的XML文档由JAXB绑定框架解组。请注意，JAXB还支持从文件和文档以外的源(如DOM节点、字符串缓冲区、SAX源等)对XML数据进行解组。 生成内容树(Generate content tree):解组过程生成从生成的JAXB类实例化的数据对象的内容树;这个内容树表示源XML文档的结构和内容。 验证(可选)😦 Validate (optional))解组过程涉及在生成内容树之前验证源XML文档。注意，如果在步骤6中修改了内容树，还可以使用JAXB Validate操作在将内容编组回XML文档之前验证更改。 过程内容(Process content):通过使用绑定编译器生成的接口，客户机应用程序可以修改Java内容树表示的XML数据。 封装(Marshal):将处理过的内容树封送到一个或多个XML输出文档。可以在编组前对内容进行验证。 More About Unmarshalling 解组(Unmarshalling)为客户机应用程序提供了将XML数据转换为jaxb派生的Java对象的能力。即 从xml -&gt; java object More About Marshalling Marshalling 为客户端应用程序提供将jaxb派生的Java对象树转换为XML数据的能力。 即从 java object -&gt; xml 默认情况下，Marshaller在生成XML数据时使用UTF-8编码。 客户机应用程序不需要在编组之前验证Java内容树。也不要求Java内容树相对于其原始模式是有效的，以便将其编组为XML数据。 More About Validation Validation 是验证XML文档是否满足模式中表示的所有约束的过程 JAXB 1.0在编组时提供验证，并在JAXB内容树上支持按需验证。JAXB 2.0只允许在解组和编组时进行验证。web服务处理模型在读取数据时是宽松的，而在写出数据时是严格的。为了满足该模型，在封送时间中添加了验证，以便用户可以确认在修改JAXB表单中的文档时没有使XML文档失效。 表示 XML 内容 本节描述 JAXB 如何将 XML 内容表示为 Java 对象。 XML 模式的 Java 表示 JAXB 支持在 Java 包中对生成的类进行分组。一个包包含以下内容： 从 XML 元素名称派生或由绑定定制指定的 Java 类名称。 一个ObjectFactory的类，它是用来返回一个必然的Java类的实例的工厂。 绑定 XML 模式 本节介绍 JAXB 使用的默认 XML-to-Java 绑定。所有这些绑定都可以通过使用自定义绑定声明来全局或逐个覆盖。有关默认 JAXB 绑定的完整信息，请参阅 JAXB 规范。 简单类型定义 使用简单类型定义的模式组件通常绑定到 Java 属性。因为有不同种类的架构组件，以下 Java 属性属性（架构组件通用）包括： 基础类型 集合类型，如果有 谓词 其余的 Java 属性属性是使用简单类型定义在模式组件中指定的。 默认数据类型绑定 以下部分解释了默认的 schema-to-Java、 JAXBElement和 Java-to-schema 数据类型绑定。 Schema-to-Java Mapping Java语言提供了比XML模式更丰富的数据类型集,下表提供了JAXB中XML数据类型到Java数据类型的映射。 XML Schema Type Java Data Type xsd:string java.lang.String xsd:integer java.math.BigInteger xsd:int int xsd.long long xsd:short short xsd:decimal java.math.BigDecimal xsd:float float xsd:double double xsd:boolean boolean xsd:byte byte xsd:QName javax.xml.namespace.QName xsd:dateTime javax.xml.datatype.XMLGregorianCalendar xsd:base64Binary byte[] xsd:hexBinary byte[] xsd:unsignedInt long xsd:unsignedShort int xsd:unsignedByte short xsd:time javax.xml.datatype.XMLGregorianCalendar xsd:date javax.xml.datatype.XMLGregorianCalendar xsd:g javax.xml.datatype.XMLGregorianCalendar xsd:anySimpleType java.lang.Object xsd:anySimpleType java.lang.String xsd:duration javax.xml.datatype.Duration xsd:NOTATION javax.xml.namespace.QName 表:XML模式内置数据类型的JAXB映射 JAXBElement对象 当XML内容的派生Java表示不能推断XML元素信息时，将提供一个JAXBElement对象。该对象具有获取和设置对象名称和对象值的方法。 Java-to-Schema Mapping 下表显示了Java类到XML数据类型的默认映射。 Java Class XML Data Type java.lang.String xs:string java.math.BigInteger xs:integer java.math.BigDecimal xs:decimal java.util.Calendar xs:dateTime java.util.Date xs:dateTime javax.xml.namespace.QName xs:QName java.net.URI xs:string javax.xml.datatype.XMLGregorianCalendar xs:anySimpleType javax.xml.datatype.Duration xs:duration java.lang.Object xs:anyType java.awt.Image xs:base64Binary javax.activation.DataHandler xs:base64Binary javax.xml.transform.Source xs:base64Binary java.util.UUID xs:string 表:XML数据类型到Java类的JAXB映射 自定义生成的类和 Java 程序元素 以下部分描述了如何定制生成的 JAXB 类和 Java 程序元素。 Schema-to-Java 自定义JAXB绑定声明使您能够在XML模式中特定于XML的约束之外自定义生成的JAXB类，以包括特定于java的细化，例如类和包名映射。 JAXB 提供了两种自定义 XML 模式的方法： 作为源 XML 模式中的内联注释 作为传递给 JAXB 绑定编译器的外部绑定定制文件中的声明 本文档后面提供了展示如何定制 JAXB 绑定的代码示例。 Java-to-Schema javax.xml.bind.annotation 包中定义的 JAXB 注释可用于自定义 Java 程序元素到 XML 模式的映射。下表总结了可用于 Java 包的 JAXB 注释。 表：与 Java 包关联的 JAXB 注释 下表总结了可以与Java类一起使用的JAXB注释。 表：与 Java 类关联的 JAXB 注释 下表总结了可用于 Java枚举类型的JAXB 注释。 表：与 Java枚举 类型关联的 JAXB 注释 下表总结了可用于 Java 属性和字段的 JAXB 注释。 表：与 Java 属性和字段关联的 JAXB 注释 下表总结了可用于对象工厂的 JAXB 注释。 表：与对象工厂关联的 JAXB 注释 下表总结了可与适配器一起使用的 JAXB 注释。 表：与适配器关联的 JAXB 注释 JAXB Examples 以下部分描述了如何使用 JAXB RI 包中包含的示例应用程序。JAXB RI 包可从 http://jaxb.java.net 获得。下载并安装 JAXB RI 包。这些示例位于jaxb-ri-install /samples/目录中。这些示例演示并建立在关键的 JAXB 特性和概念之上。按照显示的顺序执行这些程序。 阅读完本节后，您应该对 JAXB 感到很舒服，您可以： 从 XML 模式生成 JAXB Java 类 使用模式派生的 JAXB 类来解组和编组 Java 应用程序中的 XML 内容 使用派生架构的 JAXB 类创建 Java 内容树 在解组和运行时验证 XML 内容 自定义 JAXB 模式到 Java 的绑定 本文档描述了三组示例： 基本示例（Modify Marshal、Unmarshal Validate）演示了基本的 JAXB 概念，例如使用默认设置和绑定解组、编组和验证 XML 内容。 自定义示例（自定义内联、数据类型转换器、外部自定义）演示了自定义 XML 模式到 Java 对象的默认绑定的各种方法。 java-to-schema 示例展示了如何使用注释将 Java 类映射到 XML 模式。 注意： 基本和自定义示例基于采购订单场景。每个都使用一个 XML 文档po.xml，它是针对 XML 模式po.xsd 编写的。这些文档来自 W3C XML Schema Part 0: Primer，由 David C. Fallside 编辑。 基本和自定义示例目录包含几个基本文件： po.xsd是 XML 模式，用作 JAXB 绑定编译器的输入，将从模式派生的 JAXB Java 类生成。对于自定义内联和数据类型转换器示例，此文件包含内联绑定自定义。 po.xml是包含示例 XML 内容的采购订单 XML 文件，它是每个示例中解组到 Java 内容树中的文件。该文件在每个示例中几乎相同；有细微的内容差异来突出不同的 JAXB 概念。 Main.java是每个示例的主要 Java 类。 build.xml是一个为您提供方便的 Ant 项目文件。使用 Ant 工具自动生成、编译和运行模式派生的 JAXB 类。该的build.xml文件跨越例子变化。 inline-customize示例中的MyDatatypeConverter.java是一个 Java 类，用于提供自定义数据类型转换。 外部定制示例中的binding.xjb是一个外部绑定声明文件，它被传递到 JAXB 绑定编译器以定制默认的 JAXB 绑定。 下表简要描述了基本的、定制的和 java-to-schema JAXB 示例。 Example Name Description Modify Marshal 演示如何修改Java内容树。 Unmarshal Validate 演示如何在解组期间启用验证 表:定制JAXB示例 Example Name Description Customize Inline 演示如何通过在 XML 模式中使用内联注释来自定义默认 JAXB 绑定。 Datatype Converter 说明 XML simpleType定义到 Java 数据类型的替代、更简洁的绑定，类似于自定义内联示例。 External Customize 说明如何使用外部绑定声明文件将只读模式的绑定自定义传递给 JAXB 绑定编译器。 表:java到模式的JAXB示例 Example Name Description Create Marshal 演示如何使用 ObjectFactory 类创建 Java 内容树并将其编组为 XML 数据。它还演示了如何向 JAXB 列表属性添加内容。 XmlAccessorOrder 说明如何在 Java 类中使用@XmlAccessorOrder和@XmlType.propOrder映射注释来控制 Java 类型编组或解组 XML 内容的顺序。 XmlAdapter 说明如何使用接口XmlAdapter和注释@XmlJavaTypeAdapter提供 XML 内容进出HashMap（字段）的自定义映射，该字段使用整数 ( int ) 作为键，将字符串 ( String ) 作为值。 XmlAttribute 说明如何使用注解@XmlAttribute定义要作为 XML 属性处理的属性或字段。 XmlRootElement 说明如何使用注释@XmlRootElement为相应类的 XML 架构类型定义 XML 元素名称。 XmlSchemaType Class 说明如何使用注释@XmlSchemaType自定义属性或字段到 XML 内置类型的映射。 XmlType 说明如何使用注释@XmlType将类或枚举类型映射到 XML 架构类型。 下表描述了基本示例的这些类及其与源XML模式的特定绑定。 表:Schema-to-Java绑定 Schema-Derived JAXB Classes 下一节将简要解释JAXB绑定编译器为示例生成的以下各个类的功能: [Items Class](#Items` Class) [ObjectFactory Class](#ObjectFactory` Class) [PurchaseOrderType Class](# Class) [USAddress Class](#USAddress` Class) Items Class In Items.java: 该项目类是部分 primer.po包。 该类为Items 和ItemType提供公共接口。 此类实例化中的内容绑定到 XML ComplexTypes Items及其子元素 ItemType。 Item提供了getItem()方法。 ItemType提供以下方法： getPartNum(); setPartNum(String value); getComment(); setComment(java.lang.String value); getUSPrice(); setUSPrice(java.math.BigDecimal value); getProductName(); setProductName(String value); getShipDate(); setShipDate(java.util.Calendar value); getQuantity(); setQuantity(java.math.BigInteger value); ObjectFactory Class In ObjectFactory.java: 所述的ObjectFactory类是部分primer.po包。 ObjectFactory提供了工厂方法，用于在 Java 内容树中实例化表示 XML 内容的 Java 接口。 方法名称是通过连接生成的： 字符串常量create。 所有外部 Java 类名称，如果 Java 内容接口嵌套在另一个接口中。 Java 内容接口的名称。 例如，在这种情况下，对于 Java 接口prime.po.Items.ItemType，ObjectFactory创建方法createItemsItemType()。 PurchaseOrderType Class In PurchaseOrderType.java: 所述PurchaseOrderType类是部分primer.po包。 此类实例化中的内容绑定到名为PurchaseOrderType的 XML 架构子元素。 PurchaseOrderType是一个公共接口，提供以下方法： getItems(); setItems(primer.po.Items value); getOrderDate(); setOrderDate(java.util.Calendar value); getComment(); setComment(java.lang.String value); getBillTo(); setBillTo(primer.po.USAddress value); getShipTo(); setShipTo(primer.po.USAddress value); USAddress Class In USAddress.java: 的校舍地址类是部分 primer.po包。 此类实例化中的内容绑定到名为USAddress的 XML 模式元素。 USAddress是一个公共接口，提供以下方法： getState(); setState(String value); getZip(); setZip(java.math.BigDecimal value); getCountry(); setCountry(String value); getCity(); setCity(String value); getStreet(); setStreet(String value); getName(); setName(String value); 基本示例 本节介绍了基本 JAXB 示例（Modify Marshal、Unmarshal Validate），这些示例演示了如何： 将 XML 文档解组为 Java 内容树并访问其中包含的数据 修改 Java 内容树 使用ObjectFactory类创建 Java 内容树，然后将其编组为 XML 数据 在解组期间执行验证 在运行时验证 Java 内容树 Modify Marshal Example Modify Marshal示例演示了如何修改Java内容树。 该JAXB里安装/samples/modify-marshal/src/Main.java类声明导入三种标准的Java类，五JAXB绑定框架类和的primer.po包： import java.io.FileInputStream; import java.io.IOException; import java.math.BigDecimal; import javax.xml.bind.JAXBContext; import javax.xml.bind.JAXBElement; import javax.xml.bind.JAXBException; import javax.xml.bind.Marshaller; import javax.xml.bind.Unmarshaller; import primer.po.*; 创建了一个JAXBContext实例来处理在prime.po 中生成的类 JAXBContext jc = JAXBContext.newInstance( \"primer.po\" ); 创建了一个Unmarshaller实例，并解组了po.xml文件。 Unmarshaller u = jc.createUnmarshaller(); PurchaseOrder po = (PurchaseOrder) u.unmarshal(new FileInputStream(\"po.xml\")); set方法用于修改内容树的地址分支中的信息。 USAddress address = po.getBillTo(); address.setName(\"John Bob\"); address.setStreet(\"242 Main Street\"); address.setCity(\"Beverly Hills\"); address.setState(\"CA\"); address.setZip(new BigDecimal address.setName(\"John Bob\"); address.setStreet(\"242 Main Street\"); address.setCity(\"Beverly Hills\"); address.setState(\"CA\"); address.setZip(new BigDecimal(\"90210\")); 创建了一个Marshaller实例，并将更新的 XML 内容编组到system.out。所述的setProperty API用于指定输出编码; 在这种情况下，它是格式化的（人类可读的）XML。 Marshaller m = jc.createMarshaller(); m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE); m.marshal(po, System.out); Building and Running the Modify Marshal Example Using Ant 要使用 Ant 编译和运行 Modify Marshal 示例，请在终端窗口中，转到jaxb-ri-install /samples/modify-marshal/目录并键入以下内容： ant Unmarshal Validate Example Unmarshal Validate 示例演示了如何在解组期间启用验证。请注意，JAXB 在解组期间提供验证功能，但在编组期间不提供。验证在更多关于验证中进行了更详细的解释 。 该JAXB里安装/samples/unmarshal-validate/src/Main.java类声明为一个标准的Java类，十JAXB绑定框架类和进口primer.po包： import java.io.File; import javax.xml.bind.JAXBContext; import javax.xml.bind.JAXBException; import javax.xml.bind.Marshaller; import javax.xml.bind.UnmarshalException; import javax.xml.bind.Unmarshaller; import javax.xml.bind.ValidationEvent; import javax.xml.bind.ValidationEventHandler; import javax.xml.bind.ValidationEventLocator; import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI; import javax.xml.validation.SchemaFactory; import javax.xml.validation.Schema; import primer.po.*; 创建了一个JAXBContext实例来处理在prime.po包中生成的类。 JAXBContext jc = JAXBContext.newInstance(\"primer.po\"); 一个Unmarshaller的实例被创建。 Unmarshaller u = jc.createUnmarshaller(); 默认的 JAXB Unmarshaller ``ValidationEventHandler已启用以向system.out发送验证警告和错误。默认配置会导致解组操作在遇到第一个验证错误时失败。 u.setValidating( true ); 尝试将po.xml文件解组为 Java 内容树。出于本示例的目的，po.xml文件包含故意错误 PurchaseOrder po = (PurchaseOrder)u.unmarshal( new FileInputStream(\"po.xml\")); 默认验证事件处理程序处理验证错误，生成输出到system.out，然后抛出异常. &#125; catch( UnmarshalException ue ) &#123; System.out.println(\"Caught UnmarshalException\");&#125; catch( JAXBException je ) &#123; je.printStackTrace();&#125; catch( IOException ioe ) &#123; ioe.printStackTrace();&#125; Building and Running the Unmarshal Validate Example Using Ant 要使用 Ant 编译和运行 Unmarshal Validate 示例，请在终端窗口中，转到jaxb-ri-install /samples/unmarshal-validate/目录并键入以下内容： ant","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"JAXB","slug":"笔记/JAXB","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/JAXB/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Xml","slug":"Xml","permalink":"https://www.sizaif.com/tags/Xml/"},{"name":"JAXB","slug":"JAXB","permalink":"https://www.sizaif.com/tags/JAXB/"}],"author":"sizaif"},{"title":"IDEA 配置Docker 本地环境开发Java","slug":"IDEA-配置docker-本地环境开发java","date":"2021-08-10T05:50:35.000Z","updated":"2021-09-19T10:14:55.524Z","comments":true,"path":"posts/8904d55a/","link":"","permalink":"https://www.sizaif.com/posts/8904d55a/","excerpt":"","text":"IDEA 配置docker 本地环境开发java 😄 @by sizaif 📆 2021-05-17 22:52:02 [TOC] 说明 初步的思路是: 在windows平台下 使用idea调试代码, 通过 docker 配置运行linux环境, 连接到docker 容器中, 在docker容器中运行代码 安装docker插件 docker-winwdos 开启tcp远程连接 idea中配置docker环境 idea配置运行环境 未完待续","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.sizaif.com/tags/IDEA/"},{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"}],"author":"sizaif"},{"title":"Git 多人协作 & 贡献","slug":"git-多人协作-贡献","date":"2021-08-10T05:44:06.000Z","updated":"2021-09-19T10:15:01.624Z","comments":true,"path":"posts/8ea2fec1/","link":"","permalink":"https://www.sizaif.com/posts/8ea2fec1/","excerpt":"","text":"git 多人协作 &amp; 贡献 😄 @Auther by sizaif 📆 2021-06-24 17:03:01 [TOC] 修订历史 2021-06-24 17:04:08: 首次编辑 2021-06-25 10:23:09: 添加pull request图片 整体流程 首先fork别人的项目到在自己的github仓库中,然后拉取项目到本地开发,开发完成后做Pull Request 别人项目(主仓): upstream/master 自己远程仓库: origin/master 本地仓库: local/master 保持你的仓库和原作者的仓库一致 一是在github项目中点击: 二是通过git命令实现 child:codeblock open:false color:green #查看本地远程仓库信息 $ git remote -v #添加主仓到本地仓,并命为upstream,( 这个仓库保持最新与原作者的master一致) $ git remote add upstream 原作者的项目.git #再次查看本地远程仓库信息,此时 upstream 显示为原作者的项目地址 $ git remote-v #将主仓fetch到本地和本地master合并 $ git pull upstream master # 将本地master push到 你的远程仓库实现最新 $ git push Pull Request 当本地开发完,想pull 给作者贡献时, 用到pull request 在接下来的界面中,添加一下你的主要工作内容,让原作者可以清晰的理解你的新get点, 提交后等待即可. 也可以直接在jetbrains家 idea,pycharm等软件里直接提交","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Git","slug":"技术向/Git","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.sizaif.com/tags/Git/"}],"author":"sizaif"},{"title":"Dockerfile构建docker时apt-Get Install遇到交互式处理方法","slug":"Dockerfile构建docker时apt-get-install遇到交互式处理方法","date":"2021-08-10T05:38:52.000Z","updated":"2021-09-19T10:15:07.127Z","comments":true,"path":"posts/37be8a52/","link":"","permalink":"https://www.sizaif.com/posts/37be8a52/","excerpt":"","text":"Dockerfile构建docker时apt-get install遇到交互式处理方法 😄 @auther by sizaif 📆2021-07-01 02:20:43 [TOC] 编辑历史 2021-07-01 02:21:01: 第一次编辑 问题说明 当使用Dockerfile构建docker时,执行命令apt-get install -y build-essential 时,会安装tzdata, 但从tzdata 2018版本开始（如2018d），安装过程中默认采用交互式，即要求输入指定的Geographic area和Time zone，从而必须人工值守进行安装，输出信息如下。 而Dockerfile构建过程中,无法进行交互. 解决方法 在 apt-get install -y 命令前 添加 DEBIAN_FRONTEND=noninteractive 即: RUN DEBIAN_FRONTEND=noninteractive apt-get install -y &lt;software name> 注: DEBIAN_FRONTEND=noninteractive 同样适用于shell 脚本","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"Dockerfile Tutorial","slug":"Dockerfile-Tutorial","date":"2021-08-10T05:17:22.000Z","updated":"2021-09-19T10:15:10.993Z","comments":true,"path":"posts/f8a23a09/","link":"","permalink":"https://www.sizaif.com/posts/f8a23a09/","excerpt":"","text":"Dockerfile Tutorial 😄 @Auther: sizaif 📆2021-06-08 15:30:38 [TOC] Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。 在一个空白目录中，建立一个文本文件，并命名为 Dockerfile： $ mkdir mynginx $ cd mynginx $ touch Dockerfile 其内容为： FROM nginx RUN echo '&lt;h1>Hello, Docker!&lt;/h1>' > /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 FROM FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 FROM XXX ... 在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 RUN 执行命令 RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。 既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样： FROM debian:stretch RUN apt-get update RUN apt-get install -y gcc libc6-dev make wget RUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。 Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。 上面的 Dockerfile 正确的写法应该是这样： Dickerfile FROM debian:stretch RUN set -x; buildDeps='gcc libc6-dev make wget' \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。 构建镜像 好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。 在 Dockerfile 文件所在目录执行： $ docker build -t nginx:v3 . Sending build context to Docker daemon 2.048 kB Step 1 : FROM nginx ---> e43d811ce2f4 Step 2 : RUN echo '&lt;h1>Hello, Docker!&lt;/h1>' > /usr/share/nginx/html/index.html ---> Running in 9cdc27646c7b ---> 44aa4490ce2c Removing intermediate container 9cdc27646c7b Successfully built 44aa4490ce2c 从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。 这里我们使用了 docker build 命令进行镜像构建。其格式为： docker build [选项] &lt;上下文路径/URL/-> 在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。 镜像构建上下文（Context） 如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？ 这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： COPY ./package.json /app/ 这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。 因此，COPY 这类指令中的源文件的路径都是**相对路径。**这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。 如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程： $ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kB... 理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。 这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。 当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。 COPY 复制文件 格式： COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt; COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如： COPY package.json /usr/src/app/ &lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： COPY hom* /mydir/COPY hom?.txt /mydir/ &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 在使用该指令的时候还可以加上 --chown=&lt;user&gt;:&lt;group&gt; 选项来改变文件的所属用户及所属组。 COPY --chown=55:mygroup files* /mydir/COPY --chown=bin files* /mydir/COPY --chown=1 files* /mydir/COPY --chown=10:11 files* /mydir/ 如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"}],"author":"sizaif"},{"title":"Docker Tutorial","slug":"Docker-Tutorial","date":"2021-08-10T05:17:05.000Z","updated":"2021-09-19T10:15:14.432Z","comments":true,"path":"posts/ac15f71a/","link":"","permalink":"https://www.sizaif.com/posts/ac15f71a/","excerpt":"","text":"Docker Tutorial 😄 @Auther: sizaif 📆 2021-06-08 15:38:53 [TOC] docker docs https://docs.docker.com/get-docker/ Install Docker Desktop for Windows https://docs.docker.com/docker-for-windows/install/ overview Commands https://docs.docker.com/engine/reference/commandline/cli/ Build $ docker build [OPTIONS] PATH | URL | - Run Usage $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Options options Name, shorthandDefaultDescription--add-hostAdd a custom host-to-IP mapping (host:ip)--attach , -aAttach to STDIN, STDOUT or STDERR--blkio-weightBlock IO (relative weight), between 10 and 1000, or 0 to disable (default 0)--blkio-weight-deviceBlock IO weight (relative device weight)--cap-addAdd Linux capabilities--cap-dropDrop Linux capabilities--cgroup-parentOptional parent cgroup for the container--cgroupnsAPI 1.41+ Cgroup namespace to use (host|private) ‘host’: Run the container in the Docker host’s cgroup namespace ‘private’: Run the container in its own private cgroup namespace ‘’: Use the cgroup namespace as configured by the default-cgroupns-mode option on the daemon (default)--cidfileWrite the container ID to the file--cpu-countCPU count (Windows only)--cpu-percentCPU percent (Windows only)--cpu-periodLimit CPU CFS (Completely Fair Scheduler) period--cpu-quotaLimit CPU CFS (Completely Fair Scheduler) quota--cpu-rt-periodAPI 1.25+ Limit CPU real-time period in microseconds--cpu-rt-runtimeAPI 1.25+ Limit CPU real-time runtime in microseconds--cpu-shares , -cCPU shares (relative weight)--cpusAPI 1.25+ Number of CPUs--cpuset-cpusCPUs in which to allow execution (0-3, 0,1)--cpuset-memsMEMs in which to allow execution (0-3, 0,1)--detach , -dRun container in background and print container ID--detach-keysOverride the key sequence for detaching a container--deviceAdd a host device to the container--device-cgroup-ruleAdd a rule to the cgroup allowed devices list--device-read-bpsLimit read rate (bytes per second) from a device--device-read-iopsLimit read rate (IO per second) from a device--device-write-bpsLimit write rate (bytes per second) to a device--device-write-iopsLimit write rate (IO per second) to a device--disable-content-trusttrueSkip image verification--dnsSet custom DNS servers--dns-optSet DNS options--dns-optionSet DNS options--dns-searchSet custom DNS search domains--domainnameContainer NIS domain name--entrypointOverwrite the default ENTRYPOINT of the image--env , -eSet environment variables--env-fileRead in a file of environment variables--exposeExpose a port or a range of ports--gpusAPI 1.40+ GPU devices to add to the container (‘all’ to pass all GPUs)--group-addAdd additional groups to join--health-cmdCommand to run to check health--health-intervalTime between running the check (ms|s|m|h) (default 0s)--health-retriesConsecutive failures needed to report unhealthy--health-start-periodAPI 1.29+ Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s)--health-timeoutMaximum time to allow one check to run (ms|s|m|h) (default 0s)--helpPrint usage--hostname , -hContainer host name--initAPI 1.25+ Run an init inside the container that forwards signals and reaps processes--interactive , -iKeep STDIN open even if not attached--io-maxbandwidthMaximum IO bandwidth limit for the system drive (Windows only)--io-maxiopsMaximum IOps limit for the system drive (Windows only)--ipIPv4 address (e.g., 172.30.100.104)--ip6IPv6 address (e.g., 2001:db8::33)--ipcIPC mode to use--isolationContainer isolation technology--kernel-memoryKernel memory limit--label , -lSet meta data on a container--label-fileRead in a line delimited file of labels--linkAdd link to another container--link-local-ipContainer IPv4/IPv6 link-local addresses--log-driverLogging driver for the container--log-optLog driver options--mac-addressContainer MAC address (e.g., 92:d0:c6:0a:29:33)--memory , -mMemory limit--memory-reservationMemory soft limit--memory-swapSwap limit equal to memory plus swap: ‘-1’ to enable unlimited swap--memory-swappiness-1Tune container memory swappiness (0 to 100)--mountAttach a filesystem mount to the container--nameAssign a name to the container--netConnect a container to a network--net-aliasAdd network-scoped alias for the container--networkConnect a container to a network--network-aliasAdd network-scoped alias for the container--no-healthcheckDisable any container-specified HEALTHCHECK--oom-kill-disableDisable OOM Killer--oom-score-adjTune host’s OOM preferences (-1000 to 1000)--pidPID namespace to use--pids-limitTune container pids limit (set -1 for unlimited)--platformAPI 1.32+ Set platform if server is multi-platform capable--privilegedGive extended privileges to this container--publish , -pPublish a container’s port(s) to the host--publish-all , -PPublish all exposed ports to random ports--pullmissingPull image before running (“always”|“missing”|“never”)--read-onlyMount the container’s root filesystem as read only--restartnoRestart policy to apply when a container exits--rmAutomatically remove the container when it exits--runtimeRuntime to use for this container--security-optSecurity Options--shm-sizeSize of /dev/shm--sig-proxytrueProxy received signals to the process--stop-signalSIGTERMSignal to stop a container--stop-timeoutAPI 1.25+ Timeout (in seconds) to stop a container--storage-optStorage driver options for the container--sysctlSysctl options--tmpfsMount a tmpfs directory--tty , -tAllocate a pseudo-TTY--ulimitUlimit options--user , -uUsername or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])--usernsUser namespace to use--utsUTS namespace to use--volume , -vBind mount a volume--volume-driverOptional volume driver for the container--volumes-fromMount volumes from the specified container(s)--workdir , -wWorking directory inside the container # 启动容器 $ docker exec -it XXID /bin/bash #创造容器 $ docker run -dit -p 8080:80 -v /e/windowssrc:容器里映射路径 --name 起个名字 ubuntu:你的镜像tag（默认是latest） #创造容器并运行多个命令 $ docker run -dit XXX(images) /bin/bash -c \"ls &amp;&amp; pwd\" #删除容器 $ docker rm -f XXID #查看所有的容器命令如下： $ docker ps -a 容器打包并做成镜像 容器打包 $ docker commit containerId dockerUserName/XXX 注：containerId为你需要上传的容器id，dockerUserName为dockerHub的登录名，xxx为仓库名,当然也不一定非得是dockerUserName/xxx，只是为了方便起见 接下来为存在于本地的镜像打标签 $ docker tag imageName dockerUserName/xxx[:tag] #注：imageName为你需要上传的镜像name， # dockerUserName为dockerHub的登录名，xxx为仓库名，必须和你在dockerhub中新建的仓库名相同，tag不指定就是latest 打包好之后，就把打包好的镜像上传 $ docker push dockerUserName/xxx[:tag] 注：tag不指定就是latest ———————————————— git设置、查看、取消代理 设置代理： $ git config --global http.proxy 'socks5://127.0.0.1:1080' $ git config --global https.proxy 'socks5://127.0.0.1:1080' 查看代理： $ git config --global --get http.proxy $ git config --global --get https.proxy 取消代理： $ git config --global --unset http.proxygit config --global --unset https.proxy 换源 针对docker容器的代理配置： 在创建(run)容器的时候，加上 --net=host 这个选项，就可以实现容器内外共享网络，然后再在容器内部配置git，就可以实现容器内代理了 Ubuntu系统中，软件源文件地址为：/etc/apt/sources.list 1.备份原来的源，将以前的源备份一下，以防以后可以用的。 $ sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak 2.打开/etc/apt/sources.list文件，在前面添加如下条目，并保存。 $ sudo vim /etc/apt/sources.list（可将vim更换为自己熟悉的编辑器） 添加源 #添加阿里源 deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse #添加清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse 3.更新 更新源 $ sudo apt-get update 如出现依赖问题，解决方式如下： $ sudo apt-get -f install 更新软件： $sudo apt-get upgrade 修改/etc/profile 打包后不生效得问题 解决办法: 可以将环境变量放到 /root/.bashrc 这个里面 docker 容器中 默认用户为 root, 将环境变量放到 ./bashrc 中","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"教程","slug":"教程","permalink":"https://www.sizaif.com/tags/%E6%95%99%E7%A8%8B/"}],"author":"sizaif"},{"title":"Java 8 Tutorial 教程","slug":"Java-8-Tutorial-教程","date":"2021-08-09T16:00:00.000Z","updated":"2021-09-19T10:14:49.368Z","comments":true,"path":"posts/c65d65/","link":"","permalink":"https://www.sizaif.com/posts/c65d65/","excerpt":"","text":"Java 8 Tutorial 教程 😄 @Auther sizaif 📆 2021-05-29 20:41:05 🔗 翻译自 https://winterbe.com/posts/2014/03/16/java-8-tutorial/ [TOC] 说明 欢迎来到我对Java 8的介绍。本教程将逐步指导您了解所有新的语言特性。在简短简单的代码示例的支持下，您将学习如何使用默认接口方法、lambda表达式、方法引用和可重复注释。在本文的最后，您将熟悉最新的API变化，如流、功能接口、地图扩展和新的日期API。 接口缺省方法 Java 8允许我们利用default关键字向接口添加非抽象的方法实现。 此特性也称为扩展方法( Extension Methods.)。这是第一个例子: interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125; &#125; 除了抽象方法calculate接口外，Formula还定义了默认方法sqrt。具体类只需实现抽象方法calculate 默认方法sqrt可以开箱即用。 Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125; &#125;; formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0 该公式以匿名对象的形式实现。这段代码相当冗长:6行代码就可以完成这样一个简单的sqrt(a * 100)计算。正如我们将在下一节中看到的，在Java 8中有一种更好的实现单个方法对象的方法。 拉姆达(Lambda)表达式 让我们从一个简单的例子开始，在以前的Java版本中如何对字符串列表排序: List&lt;String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\"); Collections.sort(names, new Comparator&lt;String>() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125; &#125;); 静态实用方法Collections.sort接受一个列表和一个比较器，以便对给定列表的元素进行排序. 您经常会发现自己创建了匿名比较器并将它们传递给sort方法。 Java 8的语法要短得多，而不是整天创建匿名对象， lambda expressions: Collections.sort(names, (String a, String b) -> &#123; return b.compareTo(a); &#125;); 正如您所看到的，代码更短，更容易阅读。但它变得更短: Collections.sort(names, (String a, String b) -> b.compareTo(a)); 对于一行方法主体，可以跳过大括号{}和return关键字。但它变得更短: Collections.sort(names, (a, b) -> b.compareTo(a)); java编译器知道参数类型，所以您也可以跳过它们。让我们更深入地了解lambda表达式在实际中是如何使用的 函数式接口 lambda表达式如何适应java类型系统?每个lambda对应于由接口指定的给定类型.一个所谓的函数接口必须包含一个抽象方法声明。 该类型的每个lambda表达式都将与这个抽象方法匹配。由于默认方法不是抽象的，您可以自由地将默认方法添加到函数接口中。 只要接口只包含一个抽象方法，我们就可以将任意接口作为lambda表达式使用。为了确保您的接口满足需求，您应该添加@FunctionalInterface注释。编译器知道这个注释，当您试图向接口添加第二个抽象方法声明时，就会抛出编译器错误。 Example: @FunctionalInterface interface Converter&lt;F, T> &#123; T convert(F from); &#125; Converter&lt;String, Integer> converter = (from) -> Integer.valueOf(from); Integer converted = converter.convert(\"123\"); System.out.println(converted); // 123 请记住，如果@FunctionalInterface注释被省略，那么代码也是有效的。 方法和构造函数引用 通过使用静态方法引用，可以进一步简化上面的示例代码: Converter&lt;String, Integer> converter = Integer::valueOf; Integer converted = converter.convert(\"123\"); System.out.println(converted); // 123 Java 8允许您通过::关键字传递方法或构造函数的引用。上面的例子展示了如何引用静态方法。但我们也可以引用对象方法: class Something &#123; String startsWith(String s) &#123; return String.valueOf(s.charAt(0)); &#125;&#125; Something something = new Something();Converter&lt;String, String> converter = something::startsWith;String converted = converter.convert(\"Java\");System.out.println(converted); // \"J\" 让我们看看::关键字如何在构造函数中工作。首先，我们定义了一个带有不同构造函数的示例bean: class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 接下来，我们指定一个用于创建新人员的人员工厂接口: interface PersonFactory&lt;P extends Person> &#123; P create(String firstName, String lastName);&#125; 我们不是手动实现工厂，而是通过构造函数引用将所有东西粘在一起: PersonFactory&lt;Person> personFactory = Person::new;Person person = personFactory.create(\"Peter\", \"Parker\"); 通过Person::new创建对Person构造函数的引用。Java编译器通过匹配PersonFactory.create的签名自动选择正确的构造函数。 Lambda范围 从lambda表达式访问外部作用域变量非常类似于匿名对象。您可以从本地外部作用域以及实例字段和静态变量访问最终变量。 访问局部变量 我们可以从lambda表达式的外部作用域读取最终局部变量: final int num = 1;Converter&lt;Integer, String> stringConverter = (from) -> String.valueOf(from + num);stringConverter.convert(2); // 3 但与匿名对象不同的是，变量num不必声明为final。此代码也是有效的: int num = 1;Converter&lt;Integer, String> stringConverter = (from) -> String.valueOf(from + num);stringConverter.convert(2); // 3 但是num必须是隐式的final，才能编译代码。以下代码无法编译: int num = 1;Converter&lt;Integer, String> stringConverter = (from) -> String.valueOf(from + num);num = 3; 也禁止从lambda表达式内写入num。 访问字段和静态变量 与局部变量相比，我们可以从lambda表达式中读写实例字段和静态变量。这种行为在匿名对象中很常见。 class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String> stringConverter1 = (from) -> &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String> stringConverter2 = (from) -> &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125;&#125; 访问缺省接口方法 还记得第一部分的公式例子吗? 接口Formula定义了一个默认方法sqrt，可以从每个公式实例(包括匿名对象)访问该方法。这不适用于lambda表达式。 不能从lambda表达式中访问默认方法。以下代码无法编译: Formula formula = (a) -> sqrt( a * 100); 内置函数式接口 JDK 1.8 API包含许多内置的功能性接口。它们中的一些在较早的Java版本中很有名，比如Comparator或Runnable。通过@FunctionalInterface注释对这些现有接口进行了扩展，以支持Lambda。 但是Java 8 API也充满了新的功能接口，使您的生活更轻松。其中一些新接口来自 Google Guava库。即使您熟悉这个库，也应该密切关注这些接口是如何通过一些有用的方法扩展来扩展的。 谓词(Predicates) 谓词是一个参数的布尔值函数。该接口包含用于将谓词组合成复杂逻辑术语(和或否定)的各种默认方法。 Predicate&lt;String> predicate = (s) -> s.length() > 0;predicate.test(\"foo\"); // truepredicate.negate().test(\"foo\"); // falsePredicate&lt;Boolean> nonNull = Objects::nonNull;Predicate&lt;Boolean> isNull = Objects::isNull;Predicate&lt;String> isEmpty = String::isEmpty;Predicate&lt;String> isNotEmpty = isEmpty.negate(); 函数(Functions) 函数接受一个参数并产生一个结果。默认方法可以用于将多个函数链接在一起(compose, andThen)。 Function&lt;String, Integer> toInteger = Integer::valueOf;Function&lt;String, String> backToString = toInteger.andThen(String::valueOf);backToString.apply(\"123\"); // \"123\" suppliers Suppliers生成给定泛型类型的结果。与函数不同，,Suppliers不接受参数。 Supplier&lt;Person> personSupplier = Person::new;personSupplier.get(); // new Person Consumers 消费者表示对单个输入参数执行的操作 Consumer&lt;Person> greeter = (p) -> System.out.println(\"Hello, \" + p.firstName);greeter.accept(new Person(\"Luke\", \"Skywalker\")); comparators 比较器在较早的Java版本中很有名。Java 8向接口中添加了各种默认方法。 Comparator&lt;Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);Person p1 = new Person(\"John\", \"Doe\");Person p2 = new Person(\"Alice\", \"Wonderland\");comparator.compare(p1, p2); // > 0comparator.reversed().compare(p1, p2); // &lt; 0 Optionals 可选对象不是函数接口，而是一个防止NullPointerException的漂亮实用工具。这是下一节的一个重要概念，所以让我们快速了解一下optional是如何工作的。 Optional是一个简单的值容器，它可以是空值或非空值。考虑一个可能返回非空结果但有时什么也不返回的方法。在Java 8中，不是返回null，而是返回一个Optional。 Optional&lt;String> optional = Optional.of(\"bam\");optional.isPresent(); // trueoptional.get(); // \"bam\"optional.orElse(\"fallback\"); // \"bam\"optional.ifPresent((s) -> System.out.println(s.charAt(0))); // \"b\" Streams stream表示一个可以执行一个或多个操作的元素序列。流操作可以是中间操作，也可以是终端操作。终端操作返回某种类型的结果，而中间操作返回流本身，因此您可以在一行中链接多个方法调用。流是在源文件上创建的，例如java.util.Collection，如列表或集合(不支持映射)。流操作可以顺序执行，也可以并行执行。 让我们首先看看顺序流是如何工作的。首先，我们以字符串列表的形式创建一个示例源: List&lt;String> stringCollection = new ArrayList&lt;>();stringCollection.add(\"ddd2\");stringCollection.add(\"aaa2\");stringCollection.add(\"bbb1\");stringCollection.add(\"aaa1\");stringCollection.add(\"bbb3\");stringCollection.add(\"ccc\");stringCollection.add(\"bbb2\");stringCollection.add(\"ddd1\"); Java 8中的集合被扩展了，所以你可以通过调用Collection.stream()或Collection.parallelStream()简单地创建流。下面的部分解释了最常见的流操作。 Filter Filter接受一个谓词(predicate)来过滤流中的所有元素。这个操作是中间的，它使我们能够对结果调用另一个流操作(forEach)。ForEach 接受要为过滤流中的每个元素执行的使用者。ForEach是一个终端操作。它是void的，所以我们不能调用另一个流操作。 stringCollection .stream() .filter((s) -> s.startsWith(\"a\")) .forEach(System.out::println);// \"aaa2\", \"aaa1\" Sorted Sorted是一个中间操作，它返回流的排序视图。元素按自然顺序排序，除非传递自定义Comparator。 stringCollection .stream() .sorted() .filter((s) -> s.startsWith(\"a\")) .forEach(System.out::println);// \"aaa1\", \"aaa2\" ==请记住，sorted只创建流的排序视图，而不操作后台集合的顺序。stringCollection的顺序是不变的:== System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map 中间操作映射(Map)通过给定的函数将每个元素转换为另一个对象。下面的示例将每个字符串转换为大写字符串。但是您也可以使用map将每个对象转换为另一种类型。结果流的泛型类型取决于传递给map的函数的泛型类型。 // 映射map 从小写变成大写, 并按照从小到大排序stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -> b.compareTo(a)) .forEach(System.out::println);// \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\" Match 可以使用各种匹配操作来检查某个谓词是否与流匹配。所有这些操作都是terminal，并返回一个布尔结果。 // 是否有至少一个以a开头的存在?boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -> s.startsWith(\"a\"));System.out.println(anyStartsWithA); // true//是否全都是以a开头?boolean allStartsWithA = stringCollection .stream() .allMatch((s) -> s.startsWith(\"a\"));System.out.println(allStartsWithA); // false// 是否不存在以z开头?boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -> s.startsWith(\"z\"));System.out.println(noneStartsWithZ); // true Count Count是一个终端操作，将流中的元素个数作为long返回。 // 以B开头的个数long startsWithB = stringCollection .stream() .filter((s) -> s.startsWith(\"b\")) .count();System.out.println(startsWithB); // 3 Reduce 这个终端操作使用给定函数对流中的元素进行还原。结果是一个可选(Optional)的保存减少的值。 Optional&lt;String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -> s1 + \"#\" + s2);reduced.ifPresent(System.out::println);// \"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\" Parallel Streams 如上所述，流可以是顺序的，也可以是并行的。顺序流上的操作在单个线程上执行，而并行流上的操作在多个线程上并发执行。 下面的示例演示了通过使用并行流来提高性能是多么容易。 首先，我们创建了一系列独特元素: int max = 1000000;List&lt;String> values = new ArrayList&lt;>(max);for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString());&#125; 现在我们测量对这个集合的流进行排序所花费的时间。 Sequential Sort long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(\"sequential sort took: %d ms\", millis));// sequential sort took: 899 ms Parallel Sort long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(\"parallel sort took: %d ms\", millis));// parallel sort took: 472 ms 正如您可以看到的，这两个代码片段几乎是相同的，但并行排序大约快50%。您需要做的就是将stream()更改为parallelStream()。 Map 如前所述，映射不支持流。相反，映射现在支持各种新的、有用的方法来完成常见的任务。 Map&lt;Integer, String> map = new HashMap&lt;>();for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, \"val\" + i);&#125;map.forEach((id, val) -> System.out.println(val)); 上面的代码应该是不言自明的:putIfAbsent阻止我们写额外的if null检查;forEach接受一个消费者来为映射的每个值执行操作。 这个例子展示了如何使用函数在mao上计算代码: map.computeIfPresent(3, (num, val) -> val + num);map.get(3); // val33map.computeIfPresent(9, (num, val) -> null);map.containsKey(9); // falsemap.computeIfAbsent(23, num -> \"val\" + num);map.containsKey(23); // truemap.computeIfAbsent(3, num -> \"bam\");map.get(3); // val33 接下来，我们学习如何删除一个给定键的条目，仅当它当前映射到一个给定值时: map.remove(3, \"val3\");map.get(3); // val33map.remove(3, \"val33\");map.get(3); // null 另一个有用的方法: map.getOrDefault(42, \"not found\"); // not found 合并一个map条目是很容易的: map.merge(9, \"val9\", (value, newValue) -> value.concat(newValue));map.get(9); // val9map.merge(9, \"concat\", (value, newValue) -> value.concat(newValue));map.get(9); // val9concat 合并要么把键/值放到映射中，如果键不存在，要么调用合并函数来改变现有的值。 Date API Java 8在Java .time包下包含了一个全新的日期和Date API。新的Date API可以与J Joda-Time库相比较，但是它们是不同的。下面的示例涵盖了这个新API的最重要部分。 Clock Clock提供对当前日期和时间的访问。时钟知道一个时区，可以用来代替System.currentTimeMillis()来检索当前的毫秒数。这种时间线上的瞬时点也可以用Instant类表示。instant可用于创建遗留的java.util.Date对象。 Clock clock = Clock.systemDefaultZone();long millis = clock.millis();Instant instant = clock.instant();Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones 时区用ZoneId表示。可以通过静态工厂方法轻松地访问它们。时区定义了在瞬间和本地日期和时间之间进行转换时非常重要的偏移量。 System.out.println(ZoneId.getAvailableZoneIds());// prints all available timezone idsZoneId zone1 = ZoneId.of(\"Europe/Berlin\");ZoneId zone2 = ZoneId.of(\"Brazil/East\");System.out.println(zone1.getRules());System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=+01:00]// ZoneRules[currentStandardOffset=-03:00] LocalTime LocalTime表示没有时区的时间，例如晚上10点或17:30:15。下面的示例为上面定义的时区创建两个本地时间。然后我们比较这两个时间，并计算这两个时间的 LocalTime now1 = LocalTime.now(zone1);LocalTime now2 = LocalTime.now(zone2);System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); // -3System.out.println(minutesBetween); // -239 LocalTime附带了各种工厂方法来简化新实例的创建，包括时间字符串的解析。 LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late); // 23:59:59DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);System.out.println(leetTime); // 13:37 LocalDate LocalDate表示一个不同的日期，例如2014-03-11。它是不可变的，工作方式与LocalTime完全类似。该示例演示了如何通过增加或减少日、月或年来计算新的日期。请记住，每个操作都返回一个新实例。 LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY 从字符串中解析LocalDate就像解析LocalTime一样简单: DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter);System.out.println(xmas); // 2014-12-24 LocalDateTime LocalDateTime表示**日期-时间**。它将上面的日期和时间合并到一个实例中。LocalDateTime是不可变的，工作原理类似于LocalTime和LocalDate。我们可以利用方法从日期-时间中检索某些字段: LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 1439 通过附加的时区信息，可以将其转换为瞬间。瞬间可以很容易地转换为java.util.Date类型的遗留日期。 Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();Date legacyDate = Date.from(instant);System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化日期-时间就像格式化日期或时间一样。我们可以从自定义模式创建格式化器，而不是使用预定义的格式。 DateTimeFormatter formatter = DateTimeFormatter .ofPattern(\"MMM dd, yyyy - HH:mm\");LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);String string = formatter.format(parsed);System.out.println(string); // Nov 03, 2014 - 07:13 与java.text.NumberFormat不同，新的DateTimeFormatter是不可变的和线程安全的。 Annotations Java 8中的注释是可重复的。让我们直接进入一个例子来解决这个问题。 首先，我们定义一个包装注释，它包含一个实际注释的数组: @interface Hints &#123; Hint[] value();&#125;@Repeatable(Hints.class)@interface Hint &#123; String value();&#125; Java 8允许我们通过声明注释@Repeatable来使用相同类型的多个注释。 变体1:使用容器注释(旧式) @Hints(&#123;@Hint(\"hint1\"), @Hint(\"hint2\")&#125;)class Person &#123;&#125; 变体2:使用可重复的注释(新学校) @Hint(\"hint1\")@Hint(\"hint2\")class Person &#123;&#125; 通过使用变体2,java编译器隐式地在底层设置@Hints注释。这对于通过反射阅读注释信息很重要。 Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint); // nullHints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length); // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length); // 2 尽管我们从来没有在Person类上声明@Hints注释，但通过getnotation (hint .class)仍然可读。然而，更方便的方法是getAnnotationsByType，它允许直接访问所有带注释的@Hin注释。 此外，Java 8中注释的使用扩展到了两个新的目标: @Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)@interface MyAnnotation &#123;&#125;","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"}],"tags":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"}],"author":"sizaif"},{"title":"Py自动化脚本实现去除hexo标签插件语法","slug":"py自动化脚本实现去除hexo标签插件语法","date":"2021-08-08T13:26:40.000Z","updated":"2021-09-19T10:15:49.075Z","comments":true,"path":"posts/28f3a3fd/","link":"","permalink":"https://www.sizaif.com/posts/28f3a3fd/","excerpt":"","text":"py自动化脚本实现去除hexo标签插件语法 [TOC] 需求 鱼和熊掌不可兼得,当采用typora编写md文档时,typora等其他软件是不支持hexo的插件语法的,故而不会实时渲染的.只会显示源代码: 例如 源码 &#123;% note danger, note error/danger %&#125; &#123;% note success, note done/success %&#125; 当同步发表到CSDN等其他博客时,会把源代码显示出来,显得非常不美观,且含有乱码. 故而写一个自动化脚本去除含有 hexo 语法的 内容, 尝试还源一个纯净的md文件 代码 code # !/usr/bin/python # -*- coding: utf-8 -*- # @Author: float311@163.com; sizaif2000@163.com # @Description: 将hexo博客修改为csdn可以使用的格式 # @Date 2021/8/8 17:59 # @Update 2021-08-09 10:17:50 # @note: # 已知bug: # 1. hexo语法不能与文本混用,即处在一行中, 例如: 带 &#123;% u 下划线 %&#125; 的文本 ; 会导致 文本内容丢失 # 2. 代码框中内容也会被处理 import sys,re def matchstring(line): # radio, checkout note matchradio = re.search(r'&#123;% [rcn].*',line,re.I) if matchradio: return re.sub( r'%&#125;', \"\", ','.join(line.split(',')[1:]) ).replace(\" \", \"\") # floding timeline, tab end matchall = re.search(r'&#123;% [fte].*',line,re.I) if matchall: # 全部丢弃 return None # link matchlink = re.search(r'&#123;% link .*',line,re.I) if matchlink: temp = line.split(',') line = \"[\"+temp[0].split(' ')[-1]+\"](\"+re.sub(r'%&#125;',\"\",temp[-1])+\")\" return line.strip() # audio,video matchaudio = re.search(r'&#123;% [av].*',line,re.I) if matchaudio: return line.split(' ')[-2].replace(\" \",\"\") # &lt;!--类 matchall2 = line.find(\"&lt;!--\") if matchall2: return None def modify(original, result): \"\"\" 根据hexo MD文件生成CSDN博客适用的MD文件 :param original: 源文件 :param result: 新文件 \"\"\" content = \"\" with open(original, \"r+\", encoding=\"UTF-8\") as o: for line in o.readlines(): if line.find(\"&#123;%\") == -1 and line.find(\"&lt;!--\"): content += line else: line = matchstring(line) if line is not None: content += line with open(result, \"w+\", encoding=\"UTF-8\") as n: n.write(content) if __name__ == '__main__': original_md = sys.argv[1] + \".md\" result_md = sys.argv[2] + \".md\" modify(original_md, result_md) 使用方法 # 文件名不需要带md $ py main 源文件 输出文件 已知bug radio,checkout,note 文本内容中不能含有’,'(逗号), 会导致分割数据丢失 hexo语法不能与文本混用,即处在一行中, 例如: 带&#123;% u 下划线 %&#125;的文本; 会导致文本内容丢失 代码框中的内容也会被处理 ​ 上面的情况暂时需要手动处理 感谢 感谢 float311@163.com","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Python","slug":"技术向/Python","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Python/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://www.sizaif.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Python","slug":"Python","permalink":"https://www.sizaif.com/tags/Python/"}],"author":"sizaif"},{"title":"Hexo-Gui Project","slug":"hexo-gui-project","date":"2021-08-08T12:35:30.000Z","updated":"2021-08-14T14:15:24.706Z","comments":true,"path":"posts/739d4da5/","link":"","permalink":"https://www.sizaif.com/posts/739d4da5/","excerpt":"","text":"[toc] hexo图形界面 gui需求文档 [ ] 部署到github [ ] 一键创建文章,并自动资源管理器中打开_post文件夹 [ ] 一键创建page,并自动资源管理器中打开source文件夹 [ ] 一键本地预览 [ ] 一键生成,发布到github仓库( 需要配置仓库名称, 待讨论) [ ] 一键打开更改hexo配置 [ ] 一键打开更改hexo 主题配置 一键创建文章 几种方案: 选择其中一种 [ ] 一键创建文章,并自动资源管理器中打开_post文件夹 [ ] 一键创建文章,并自动调用typora打开文章 一键创建page 方案雷同 创建文章 一键本地预览 $ hexo s -g 一键生成,发布到github仓库 若直接调用 $ hexo s -d 则会交互要求输入 github用户名和密码进行验证 不想交互输入的话, 提前设定 用户名和密码 使用sshkey git推送 一键打开设置hexo配置 类同 更改hexo主题配置 一键打开更改hexo 主题配置 需要在hexo 根目录下 新建_config.主题.yml 调用 程序打开, 或者 打开所在文件夹,或者 根据主题一键部署(待讨论, 工作量大) 选择其中一种 [ ] 调用程序打开 e.g sublime text, notep++,等 [ ] 直接打开所在文件夹,用户自己打开配置 [ ] 调用窗口,gui 设定参数(工作量大)","categories":[{"name":"项目","slug":"项目","permalink":"https://www.sizaif.com/navigation/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"github计划","slug":"github计划","permalink":"https://www.sizaif.com/tags/github%E8%AE%A1%E5%88%92/"}],"author":"sizaif"},{"title":"AutoHotkey+Typora 实现快捷键输入Hexo标签插件","slug":"AutoHotkey-Typora-实现快捷键输入hexo标签插件","date":"2021-08-08T12:30:40.000Z","updated":"2021-08-14T14:15:24.700Z","comments":true,"path":"posts/96be5746/","link":"","permalink":"https://www.sizaif.com/posts/96be5746/","excerpt":"","text":"AutoHotkey+Typora 实现快捷键输入hexo标签插件 [toc] 需求 使用hexo写博客时,hexo包括主题文件,提供了丰富的标签插件美化,在博客上非常美观简洁,甚是喜欢. 但语法写起来比较麻烦,需要每次查询,或者手打. 人类的本质是去掉重复工作,懒是提高生产力的最大障碍. 故而想到了使用快捷键的方式在typora中快速的插入语法 所需环境 AutoHotkey Typora AutoHotkey: 去官网安装即可 AutoHotkey官网https://www.autohotkey.com/ Typora: 去官网安装 Typora官网https://typora.io/ 编写Autohotkey脚本 创建xxx.ahk文件 粘贴我写的代码进去, 可自定义脚本,添加其他功能. ^ : ctrl !: alt #: win +: shift ~: alt+tab 代码 ; Typora ; 快捷设置兼容hexo格式 ; SendInput &#123;Text&#125; 解决中文输入法问题 #IfWinActive ahk_exe Typora.exe &#123; ; ctrl+1 tab ^1::addtabcode() ; ctrl+2 note ^2::addnotecode() ; ctrl+3 folding ^3::addfoldingcode() ; ctrl+4 link ^4::addlinkcode() ; ctrl+5 span ^5::addspancode() ; ctrl+6 radio ^6::addradiocode() &#125; ; 快捷设置tab addtabcode()&#123; clipboard := \"&#123;% tabs tab-id %&#125;`n`t&lt;!-- tab 1 -->`nreplace`n&lt;!-- endtab -->`n&lt;!-- tab 2 -->`nreplace`n&lt;!-- endtab -->`n&#123;% endtabs %&#125;\" Send ^v return &#125; ; 快捷设置note addnotecode()&#123; clipboard := \"&#123;% note danger, note error/danger %&#125;`n&#123;% note success, note done/success %&#125;\" Send ^v return &#125; ; 快捷设置folding addfoldingcode()&#123; clipboard := \"&#123;% folding green, text %&#125;`n&#123;% endfolding %&#125;\" Send ^v return &#125; ; 快捷设置link addlinkcode()&#123; clipboard := \"&#123;% link title, link %&#125;\" Send ^v return &#125; ; 快捷设置span addspancode()&#123; clipboard := \"&#123;% span parm, txt %&#125;\" Send ^v return &#125; ; 快捷设置radio addradiocode()&#123; clipboard := \"&#123;% radio green checked, text %&#125;\" Send ^v return &#125; 编译运行 xxx.ahk文件 鼠标右键文件 compiler script 双击启动脚本 Typora中运行 快去愉快的测试吧! 遇到问题 当设置 alt 按键的时候, 如果运行时按下出现键盘功能变得诡异, 请再按一次alt 相关文档 但鱼和熊掌不可兼得,当采用typora编写md文档时,typora等其他软件是不支持hexo的插件语法的,故而不会实时渲染的.只会显示源代码: 例如 源码 &#123;% note danger, note error/danger %&#125; &#123;% note success, note done/success %&#125; 当去CSDN等其他博客发表时,会把源代码显示出来,显得非常丑. 解决方法: py自动化脚本实现去除hexo标签插件语法https://www.sizaif.com/2021/08/08/py%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%BB%E9%99%A4hexo%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6%E8%AF%AD%E6%B3%95/","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}],"author":"sizaif"},{"title":"Volantis 5.0 标签插件","slug":"volantis-5-0-标签插件","date":"2021-08-08T03:24:11.000Z","updated":"2021-08-14T14:15:24.715Z","comments":true,"path":"posts/e55b6fd4/","link":"","permalink":"https://www.sizaif.com/posts/e55b6fd4/","excerpt":"","text":"volantis 5.0 标签插件 为了兼容老用户，旧的标签插件在重构之前依然沿用旧的格式，即 command + 空格 作为参数分隔符，而部分新增标签插件是 空格 + 英文竖线 + 空格 ，请注意区分。 我们也在探索哪种分隔符既简单又不容易引起冲突，所以可能存在多种格式，具体以对应文档描述为准。 text 效果源码带 下划线 的文本；带 着重号 的文本；带 波浪线 的文本；带 删除线 的文本 键盘样式的文本：⌘ + D 密码样式的文本：这里没有验证码带 &#123;% u 下划线 %&#125; 的文本；带 &#123;% emp 着重号 %&#125; 的文本；带 &#123;% wavy 波浪线 %&#125; 的文本；带 &#123;% del 删除线 %&#125; 的文本 键盘样式的文本：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125; 密码样式的文本：&#123;% psw 这里没有验证码 %&#125; 标签插件https://volantis.js.org/v5/tag-plugins/","categories":[{"name":"建站笔记","slug":"建站笔记","permalink":"https://www.sizaif.com/navigation/categories/%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}],"author":"sizaif"},{"title":"Hexo+github博客搭建","slug":"hexo-github博客搭建","date":"2021-08-08T03:20:47.000Z","updated":"2021-09-19T10:16:09.808Z","comments":true,"path":"posts/b4a23979/","link":"","permalink":"https://www.sizaif.com/posts/b4a23979/","excerpt":"","text":"hexo+github博客搭建 需求 将本地博客存放在DropBox云中 使用hexo构建博客系统 使用github作为远程仓库 使用gitee作为备用仓库 绑定域名 本地使用ssh git方式推送 搭建步骤 安装必要环境 git windows10 (非必须) Hexo: 4.2 ~ 5.x hexo-cli: 3.1 ~ 4.x node.js: 12.16 ~ latest # 推荐使用 LTS 版 npm: 6.13 ~ latest 安装node,js: https://nodejs.org/en/ 安装git: https://git-scm.com/ 安装node.js 和git后进行测试: $ npm -v $ git --version 安装hexo: 因为我将blog文件存放在Dropbox云中, 而Dropbox本地文件在.Dropbox\\XXX 若之间使用npm命令则会出现找不到包的问题 我这里的解决方法是: 先在控制台使用npm 命令安装 npm install hexo-cli -g 将目录C:\\Users\\XXX\\AppData\\Roaming\\npm 下的 node_modules和 hexo*相关的文件复制一份到.Dropbox\\XXX\\Blog\\下 在.Dropbox\\XXX\\Blog\\下打开控制台继续执行安装hexo的命令 # 安装 npm install hexo-cli -g # 测试版本 $ hexo -v # 安装 $ hexo init blog &amp; cd blog &amp; npm install # 浏览器访问 localhost:4000 测试 $ hexo server # 此时本地安装hexo已完成 hexo文件树: . ├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json ├── scaffolds # 模版文件夹 ├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹 | ├── _drafts # 草稿文件 | └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 如果遇到npm 安装 报错问题, 尝试删除 package-lock.json 再试 hexo常用命令: hexo npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿 hexo publish [layout] &lt;title> 安装hexo主题: 安装适合自己口味的主题 设置github github 新建仓库,仓库名称为 XXX.github.io; XXX为你的用户名! 注意项: 1. ==仓库名称中XXX必须与用户名对应!!!!== 2. 方式为`public` 设置使用ssh方式推送 查看本地C:\\Users\\XXX\\.ssh 下有无id_rsa样式文件 若无,创建新的ssh 密钥, $ ssh-keygen -T rsa -C 'github邮箱地址' # 回车继续, passphrase 密码可输入可不输 复制.ssh目录下的id_rsa.pub中文件内容到github ssh keys管理中 测试ssh $ ssh git@github.com 若出现: ssh: connect to host github.com port 22: Connection refused 错误 解决方法: XXX\\.ssh目录下创建config文件 config文件中写入下面的信息： Host github.com User xxxxx@xx.com(github用户邮箱) Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 再使用ssh git@github.com测试 选择配置自己的hexo 主题(可选) 选择适合自己口味的blog主题即可 域名绑定github 域名解析商解析方式选择CNAME; 站点为: XXX.github.io xxx.github.io仓库中,setting选项Page中配置 Custom domain 内容为你的域名,save保存 blog 根目录下的source文件中创建CNAME文件 (必须选项) 内容为你的域名 作用: 防止每次hexo推送博客后,域名解析失效,重新配置Custom domain","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Hexo","slug":"技术向/Hexo","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Hexo/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}],"author":"sizaif"},{"title":"吹一吹云空调","slug":"吹一吹云空调","date":"2021-08-07T17:09:52.000Z","updated":"2021-09-19T07:31:54.018Z","comments":true,"path":"posts/bfcf32d/","link":"","permalink":"https://www.sizaif.com/posts/bfcf32d/","excerpt":"","text":"","categories":[],"tags":[],"author":"sizaif"},{"title":"第一次建站","slug":"第一次建站","date":"2021-08-07T15:28:55.000Z","updated":"2021-09-19T10:16:17.208Z","comments":true,"path":"posts/8b3781ae/","link":"","permalink":"https://www.sizaif.com/posts/8b3781ae/","excerpt":"","text":"[TOC] 春江花月夜 春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰； 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年望相似。 不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月裴回，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。 寄语 愿所有日日夜夜的努力都能迎来明日的初升的太阳 by sizaif 2021-08-07 23:38:41 你好明天","categories":[{"name":"杂文","slug":"杂文","permalink":"https://www.sizaif.com/navigation/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}],"author":"sizaif"},{"title":"Java8 Stream 教程学习","slug":"Java8-Stream-教程学习","date":"2021-05-29T12:37:59.000Z","updated":"2021-09-19T10:15:53.793Z","comments":true,"path":"posts/2180828f/","link":"","permalink":"https://www.sizaif.com/posts/2180828f/","excerpt":"","text":"Java8 Stream 教程学习 😄 @Auther: sizaif 📆 2021-05-29 20:37:59 🔗 转载翻译于 https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/ [TOC] 说明 这个示例驱动的教程深入概述了Java 8流。当我第一次读到Stream API时，我对它的名字感到困惑，因为它听起来类似于Java I/O中的InputStream和OutputStream。但是Java 8流是完全不同的东西。Stream是Monads，因此在将函数式编程引入Java中扮演着重要的角色: 在函数式编程，Monads是一个结构，表示计算定义为一系列的步骤。一个具有单子结构的类型定义了将操作链起来的含义，或将该类型的函数嵌套在一起。 本指南教你如何使用Java 8流以及如何使用不同类型的可用流操作。您将了解处理顺序以及流操作的顺序如何影响运行时性能。更强大的流操作reduce，collect和flatMap将详细介绍。本教程最后对并行流进行了深入研究。 流是如何工作的(How streams work) 一个流表示一个元素序列，并支持不同类型的操作来对这些元素执行计算: List&lt;String> myList = Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\"); myList .stream() .filter(s -> s.startsWith(\"c\")) .map(String::toUpperCase) .sorted() .forEach(System.out::println); // C1 // C2 流操作可以是中间操作，也可以是终端操作。中间操作返回一个流，因此我们可以不使用分号链接多个中间操作.终端操作要么为空，要么返回非流结果.上面的过滤器示例中，map和sorted是中间操作，而forEach是终端操作。有关所有可用流操作的完整列表，请参阅stream Javadoc。如上例中所示的这种流操作链也称为操作管道。 大多数流操作接受某种类型的lambda表达式参数，一个指定操作确切行为的函数接口。大多数操作必须是无干扰和无状态的。这是什么意思? 当一个函数不修改流的基础数据源时，它就是无干扰的,例如,在上面的例子中，没有一个lambda表达式通过从集合中添加或删除元素来修改myList。 当操作的执行是确定的时，函数就是无状态 的，例如，在上面的例子中，没有lambda表达式依赖于在执行过程中可能改变的外部作用域的任何可变变量或状态。 不同类型的流(Different kind of streams) 可以从各种数据源创建流，特别是集合。列表和集合支持新的方法stream()和parallelStream()来创建顺序流或并行流。并行流能够在多个线程上操作，本教程的后面一节将对此进行介绍。我们现在主要关注顺序流: Arrays.asList(\"a1\", \"a2\", \"a3\") .stream() .findFirst() .ifPresent(System.out::println); // a1 在对象列表上调用方法stream()将返回一个常规对象流。但我们不需要创建集合来处理流，就像我们在下一个代码示例中看到的: Stream.of(\"a1\", \"a2\", \"a3\") .findFirst() .ifPresent(System.out::println); // a1 只需使用stream .of()从一堆对象引用创建一个流。 除了常规的对象流之外，Java 8还提供了特殊类型的流，用于处理基本数据类型int、long和double。你可能已经猜到是IntStream, LongStream和DoubleStream。 IntStreams可以使用IntStream.range()替换常规的for循环: IntStream.range(1, 4) .forEach(System.out::println); // 1 // 2 // 3 所有这些基元流都像普通的对象流一样工作，有以下不同:基元流使用特化的lambda表达式，例如用IntFunction代替Function，用IntPredicate代替Predicate。原始流支持附加的终端聚合操作sum()和average(): Arrays.stream(new int[] &#123;1, 2, 3&#125;) .map(n -> 2 * n + 1) .average() .ifPresent(System.out::println); // 5.0 有时将常规对象流转换为基本流很有用，反之亦然。为此，对象流支持特殊的映射操作mapToInt()、mapToLong()和mapToDouble: Stream.of(\"a1\", \"a2\", \"a3\") .map(s -> s.substring(1)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); // 3 原始流可以通过mapToObj()转换为对象流: IntStream.range(1, 4) .mapToObj(i -> \"a\" + i) .forEach(System.out::println); // a1 // a2 // a3 下面是一个组合的例子:double类型的流首先映射到int类型的流，然后再映射到string类型的对象流: Stream.of(1.0, 2.0, 3.0) .mapToInt(Double::intValue) .mapToObj(i -> \"a\" + i) .forEach(System.out::println); // a1 // a2 // a3 处理次序(Processing Order) 现在，我们已经学习了如何创建和使用不同类型的流，让我们深入了解如何在幕后处理流操作。中间操作的一个重要特征是惰性。看看这个例子，这里缺少了一个终端操作: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> &#123; System.out.println(\"filter: \" + s); return true; &#125;); 在执行此代码片段时，不会将任何内容打印到控制台。这是因为只有在存在终端操作时才会执行中间操作。 让我们通过终端操作forEach来扩展上面的示例: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> &#123; System.out.println(\"filter: \" + s); return true; &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); 执行此代码片段会在控制台上产生所需的输出: filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c 结果的顺序可能会令人惊讶。一种简单的方法是在流的所有元素上一个接一个地水平执行操作.但是每个元素都沿着链垂直移动。第一个字符串“d2”传递filter然后forEach，只有这样第二个字符串“a2”才会被处理。 这种行为可以减少对每个元素执行的实际操作数，在下一个例子中我们可以看到: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .anyMatch(s -> &#123; System.out.println(\"anyMatch: \" + s); return s.startsWith(\"A\"); &#125;); // map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2 只要谓词应用于给定的输入元素，anyMatch操作就返回true。对于传递给“A2”的第二个元素是这样的。由于流链是垂直执行的，所以在这种情况下只需要执行两次map。因此，不是映射流的所有元素，而是尽可能少地调用map。 Why order matters 下一个示例包含两个中间操作map和filter以及终端操作forEach。让我们再次检查这些操作是如何执行的: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .filter(s -> &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"A\"); &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); // map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C 您可能已经猜到，对于底层集合中的每个字符串，map和filter都被调用5次，而forEach只被调用一次。 如果我们改变操作的顺序，将filter移到链的开头，就可以大大减少实际执行的次数: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); // filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c 现在，map只被调用一次，所以对于大量输入元素，操作管道的执行速度要快得多。在编写复杂的方法链时，请记住这一点。 让我们通过一个额外的操作来扩展上面的例子，sorted: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .sorted((s1, s2) -> &#123; System.out.printf(\"sort: %s; %s\\n\", s1, s2); return s1.compareTo(s2); &#125;) .filter(s -> &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); 排序是一种特殊的中间操作。这是一个所谓的有状态操作，因为为了对元素集合排序，您必须在排序期间保持状态。 执行这个示例会得到以下控制台输出: sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2 首先，对整个输入集合执行排序操作。换句话说，排序是水平执行的。所以在这种情况下，对于输入集合中的每个元素的多个组合，sorted被调用8次。 再一次，我们可以通过重新排序链来优化性能: Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> &#123; System.out.println(\"filter: \" + s); return s.startsWith(\"a\"); &#125;) .sorted((s1, s2) -> &#123; System.out.printf(\"sort: %s; %s\\n\", s1, s2); return s1.compareTo(s2); &#125;) .map(s -> &#123; System.out.println(\"map: \" + s); return s.toUpperCase(); &#125;) .forEach(s -> System.out.println(\"forEach: \" + s)); // filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2 在本例中，从未调用sorted，因为filter将输入集合减少到只有一个元素。因此，对于更大的输入集合，性能会大大提高 复用流(Reusing Streams) Java 8流不能被重用。当你调用任何终端操作时，流就会被关闭: Stream&lt;String> stream = Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> s.startsWith(\"a\")); stream.anyMatch(s -> true); // ok stream.noneMatch(s -> true); // exception 在同一个流的anyMatch之后调用nonmatch会导致以下异常: java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459) at com.winterbe.java8.Streams5.test7(Streams5.java:38) at com.winterbe.java8.Streams5.main(Streams5.java:28) 为了克服这个限制，我们必须为想要执行的每个终端操作创建一个新的流链，例如，我们可以创建一个流供应商来构造一个所有中间操作都已经设置好的新流: Supplier&lt;Stream&lt;String>> streamSupplier = () -> Stream.of(\"d2\", \"a2\", \"b1\", \"b3\", \"c\") .filter(s -> s.startsWith(\"a\"));streamSupplier.get().anyMatch(s -> true); // okstreamSupplier.get().noneMatch(s -> true); // ok 对get()的每次调用都会构造一个新流，我们将在其上保存以调用所需的终端操作。 高级操作(Advanced Operations) 流支持许多不同的操作。我们已经学习了最重要的操作，如filter或map。我把所有其他可用的操作留给您去发现(请参阅Stream Javadoc)。相反，让我们深入研究更复杂的操作收集、flatMap和reduce。 本节中的大多数代码示例使用以下人员列表进行演示: class Person &#123; String name; int age; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return name; &#125; &#125; List&lt;Person> persons = Arrays.asList( new Person(\"Max\", 18), new Person(\"Peter\", 23), new Person(\"Pamela\", 23), new Person(\"David\", 12)); Collect Collect是一个非常有用的终端操作，可以将流的元素转换为另一种结果，例如: list,map,set.Collect接受Collector，收集器由四种不同的操作组成:供应商(supplier)、累加器( accumulator)、合并器(combiner)和收尾器(finisher)。乍一听，这听起来非常复杂，但好的部分是Java 8通过collector类支持各种内置收集器。所以对于最常见的操作，你不需要自己实现收集器。 让我们从一个非常常见的用例开始: List&lt;Person> filtered = persons .stream() .filter(p -> p.name.startsWith(\"P\")) .collect(Collectors.toList());System.out.println(filtered); // [Peter, Pamela] 如您所见，从流的元素构造一个列表非常简单。需要一个集合而不是列表-只需使用collections . toset()。 下一个例子将所有人按年龄分组: Map&lt;Integer, List&lt;Person>> personsByAge = persons .stream() .collect(Collectors.groupingBy(p -> p.age)); personsByAge .forEach((age, p) -> System.out.format(\"age %s: %s\\n\", age, p)); // age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David] Collectors是非常多才多艺的。你也可以创建流元素的聚合， 例如确定所有人的平均年龄: Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -> p.age)); System.out.println(averageAge); // 19.0 如果您对更全面的统计信息感兴趣，汇总收集器将返回一个特殊的内置汇总统计信息对象。因此，我们可以简单地确定人员的最小年龄，最大年龄和算术平均年龄以及总和和计数。 IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -> p.age));System.out.println(ageSummary);// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125; 下一个例子将所有人连接到一个字符串中: String phrase = persons .stream() .filter(p -> p.age >= 18) .map(p -> p.name) .collect(Collectors.joining(\" and \", \"In Germany \", \" are of legal age.\"));System.out.println(phrase);// In Germany Max and Peter and Pamela are of legal age. 连接收集器接受分隔符以及可选的前缀和后缀。 为了将流元素转换为映射，我们必须指定键和值应该如何映射。请记住，映射的键必须是唯一的，否则抛出IllegalStateException。您可以选择将merge函数作为附加参数传递，以绕过异常: Map&lt;Integer, String> map = persons .stream() .collect(Collectors.toMap( p -> p.age, p -> p.name, (name1, name2) -> name1 + \";\" + name2));System.out.println(map);// &#123;18=Max, 23=Peter;Pamela, 12=David&#125; 现在我们已经了解了一些最强大的内置收集器，让我们尝试构建自己的特殊收集器。我们想要将流中的所有人转换为单个字符串，该字符串由以|管道字符分隔的所有大写字母组成。 为了实现这一点，我们通过collector .of()创建一个新的收集器。我们必须传递收集器的四个组成部分:供应商(supplier)、累加器( accumulator)、合并器(combiner)和收尾器(finisher) Collector&lt;Person, StringJoiner, String> personNameCollector = Collector.of( () -> new StringJoiner(\" | \"), // supplier (j, p) -> j.add(p.name.toUpperCase()), // accumulator (j1, j2) -> j1.merge(j2), // combiner StringJoiner::toString); // finisherString names = persons .stream() .collect(personNameCollector);System.out.println(names); // MAX | PETER | PAMELA | DAVID 由于Java中的字符串是不可变的，我们需要一个像StringJoiner这样的helper类来让收集器构造我们的字符串。提供者最初构造这样一个带有适当分隔符的StringJoiner。累加器用于将每个人的大写名称添加到StringJoiner中。组合器知道如何将两个StringJoiners合并为一个。在最后一步中，完成器从StringJoiner构造所需的字符串。 FlatMap 我们已经学习了如何利用map操作将流的对象转换为另一种类型的对象。Map有一定的局限性，因为每个对象只能映射到另一个对象。但是，如果我们想将一个对象转换为多个其他对象，或者根本不转换该怎么办呢?这就是flatMap的救星。 FlatMap将流的每个元素转换为其他对象的流。因此，每个对象将被转换为0个、一个或多个由流支持的其他对象。这些流的内容将被放置到flatMap操作返回的流中。 在我们看到flatMap的实际应用之前，我们需要一个适当的类型层次结构: class Foo &#123; String name; List&lt;Bar> bars = new ArrayList&lt;>(); Foo(String name) &#123; this.name = name; &#125; &#125; class Bar &#123; String name; Bar(String name) &#123; this.name = name; &#125; &#125; 我们利用我们关于流的知识来实例化几个对象: List&lt;Foo> foos = new ArrayList&lt;>(); // create foos IntStream .range(1, 4) .forEach(i -> foos.add(new Foo(\"Foo\" + i))); // create bars foos.forEach(f -> IntStream .range(1, 4) .forEach(i -> f.bars.add(new Bar(\"Bar\" + i + \" &lt;- \" + f.name)))); 现在我们有一个包含三个foo的列表，每个foo由三个bar组成。 FlatMap接受一个必须返回对象流的函数。因此，为了解析每个foo的bar对象，我们只需传递适当的函数: foos.stream() .flatMap(f -> f.bars.stream()) .forEach(b -> System.out.println(b.name)); // Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3 正如您所看到的，我们已经成功地将三个foo对象的流转换为九个bar对象的流。 最后，上面的代码示例可以简化为一个流操作的单一管道: IntStream.range(1, 4) .mapToObj(i -> new Foo(\"Foo\" + i)) .peek(f -> IntStream.range(1, 4) .mapToObj(i -> new Bar(\"Bar\" + i + \" &lt;- \" f.name)) .forEach(f.bars::add)) .flatMap(f -> f.bars.stream()) .forEach(b -> System.out.println(b.name)); FlatMap也适用于Java 8中引入的Optional类。flatMap操作返回另一种类型的可选对象。因此可以利用它来防止讨厌的空检查。 想想这样一个高度分层的结构: class Outer &#123; Nested nested;&#125;class Nested &#123; Inner inner;&#125;class Inner &#123; String foo;&#125; 为了解析外部实例的内部字符串foo，你必须添加多个空检查来防止可能的nullpointerexception: Outer outer = new Outer();if (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) &#123; System.out.println(outer.nested.inner.foo);&#125; 同样的行为可以通过使用可选的flatMap操作获得: Optional.of(new Outer()) .flatMap(o -> Optional.ofNullable(o.nested)) .flatMap(n -> Optional.ofNullable(n.inner)) .flatMap(i -> Optional.ofNullable(i.foo)) .ifPresent(System.out::println); 对flatMap的每次调用返回一个可选的包装(如果存在)所需对象，如果不存在则返回null。 Reduce reduce操作将流的所有元素合并为一个结果。Java 8支持三种不同的reduce方法。第一种方法将元素流缩减为流中的一个元素。 让我们看看如何使用这个方法来确定最年长的人: persons .stream() .reduce((p1, p2) -> p1.age > p2.age ? p1 : p2) .ifPresent(System.out::println); // Pamela reduce方法接受一个BinaryOperator累加器函数。这实际上是一个BiFunction，其中两个操作数共享同一类型，在这里是Person。BiFunctions类似于Function，但接受两个参数。示例函数比较两个人的年龄，以便返回具有最大年龄的人。 第二个reduce方法同时接受标识值和BinaryOperator累加器。该方法可用于构造一个新的Person， 该Person具有来自流中所有其他人员的聚合名称和年龄: Person result = persons .stream() .reduce(new Person(\"\", 0), (p1, p2) -> &#123; p1.age += p2.age; p1.name += p2.name; return p1; &#125;); System.out.format(\"name=%s; age=%s\", result.name, result.age); // name=MaxPeterPamelaDavid; age=76 第三个reduce方法接受三个参数:一个标识值、一个BiFunction累加器和一个BinaryOperator类型的组合函数。因为身份值类型不限于Person类型，我们可以利用这个约简来确定所有人的年龄总和: Integer ageSum = persons .stream() .reduce(0, (sum, p) -> sum += p.age, (sum1, sum2) -> sum1 + sum2);System.out.println(ageSum); // 76 正如你所看到的，结果是76，但在引擎盖下到底发生了什么?让我们通过一些调试输出来扩展上面的代码: Integer ageSum = persons .stream() .reduce(0, (sum, p) -> &#123; System.out.format(\"accumulator: sum=%s; person=%s\\n\", sum, p); return sum += p.age; &#125;, (sum1, sum2) -> &#123; System.out.format(\"combiner: sum1=%s; sum2=%s\\n\", sum1, sum2); return sum1 + sum2; &#125;);// accumulator: sum=0; person=Max// accumulator: sum=18; person=Peter// accumulator: sum=41; person=Pamela// accumulator: sum=64; person=David 正如你所看到的，累加器函数完成了所有的工作。它首先被调用，初始值为0，第一个人是Max。在接下来的三个步骤中，总和随着最后一步的年龄不断增加，直到76岁。 Wait what?合成器(combiner)从来没有被调用?并行执行同一个流将解除秘密: Integer ageSum = persons .parallelStream() .reduce(0, (sum, p) -> &#123; System.out.format(\"accumulator: sum=%s; person=%s\\n\", sum, p); return sum += p.age; &#125;, (sum1, sum2) -> &#123; System.out.format(\"combiner: sum1=%s; sum2=%s\\n\", sum1, sum2); return sum1 + sum2; &#125;); // accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35 并行执行此流会导致完全不同的执行行为。现在合并器被调用了。由于累加器是并行调用的，因此需要合并器将单独累加的值相加。 让我们在下一章更深入地探讨并行流。 并行流(Parallel Streams) 流可以并行执行，以提高大量输入元素的运行时性能。并行流使用通过静态ForkJoinPool. commonpool()方法可用的公共ForkJoinPool。底层线程池的大小最多使用5个线程—取决于可用的物理CPU内核的数量: ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); // 3 在我的机器上，公共池初始化时的并行度默认为3。这个值可以通过设置以下JVM参数来增加或减少: -Djava.util.concurrent.ForkJoinPool.common.parallelism=5 集合支持parallelStream()方法来创建元素的并行流。或者，您可以在给定流上调用中间方法parallel()来将顺序流转换为并行对应流。 为了少描述并行流的并行执行行为，下面的例子将当前线程的信息打印到sout: Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\") .parallelStream() .filter(s -> &#123; System.out.format(\"filter: %s [%s]\\n\", s, Thread.currentThread().getName()); return true; &#125;) .map(s -> &#123; System.out.format(\"map: %s [%s]\\n\", s, Thread.currentThread().getName()); return s.toUpperCase(); &#125;) .forEach(s -> System.out.format(\"forEach: %s [%s]\\n\", s, Thread.currentThread().getName())); 通过研究调试输出，我们应该更好地理解哪些线程实际用于执行流操作: filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-1] map: a2 [ForkJoinPool.commonPool-worker-1] filter: c2 [ForkJoinPool.commonPool-worker-3] map: c2 [ForkJoinPool.commonPool-worker-3] filter: c1 [ForkJoinPool.commonPool-worker-2] map: c1 [ForkJoinPool.commonPool-worker-2] forEach: C2 [ForkJoinPool.commonPool-worker-3] forEach: A2 [ForkJoinPool.commonPool-worker-1] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-3] map: a1 [ForkJoinPool.commonPool-worker-3] forEach: A1 [ForkJoinPool.commonPool-worker-3] forEach: C1 [ForkJoinPool.commonPool-worker-2] 正如您可以看到的，并行流利用了公共ForkJoinPool中的所有可用线程来执行流操作。连续运行时的输出可能不同，因为实际使用的特定线程的行为是不确定的。 让我们通过一个额外的流操作——sort来扩展这个示例: Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\") .parallelStream() .filter(s -> &#123; System.out.format(\"filter: %s [%s]\\n\", s, Thread.currentThread().getName()); return true; &#125;) .map(s -> &#123; System.out.format(\"map: %s [%s]\\n\", s, Thread.currentThread().getName()); return s.toUpperCase(); &#125;) .sorted((s1, s2) -> &#123; System.out.format(\"sort: %s &lt;> %s [%s]\\n\", s1, s2, Thread.currentThread().getName()); return s1.compareTo(s2); &#125;) .forEach(s -> System.out.format(\"forEach: %s [%s]\\n\", s, Thread.currentThread().getName())); 乍一看，结果可能很奇怪: filter: c2 [ForkJoinPool.commonPool-worker-3]filter: c1 [ForkJoinPool.commonPool-worker-2]map: c1 [ForkJoinPool.commonPool-worker-2]filter: a2 [ForkJoinPool.commonPool-worker-1]map: a2 [ForkJoinPool.commonPool-worker-1]filter: b1 [main]map: b1 [main]filter: a1 [ForkJoinPool.commonPool-worker-2]map: a1 [ForkJoinPool.commonPool-worker-2]map: c2 [ForkJoinPool.commonPool-worker-3]sort: A2 &lt;> A1 [main]sort: B1 &lt;> A2 [main]sort: C2 &lt;> B1 [main]sort: C1 &lt;> C2 [main]sort: C1 &lt;> B1 [main]sort: C1 &lt;> C2 [main]forEach: A1 [ForkJoinPool.commonPool-worker-1]forEach: C2 [ForkJoinPool.commonPool-worker-3]forEach: B1 [main]forEach: A2 [ForkJoinPool.commonPool-worker-2]forEach: C1 [ForkJoinPool.commonPool-worker-1] 排序似乎只在主线程上顺序执行。实际上，在并行流上排序使用了新的Java 8方法Arrays.parallelSort()。如Javadoc中所述，如果排序是顺序执行还是并行执行，该方法决定数组的长度: 如果指定数组的长度小于最小粒度，则使用适当的Arrays对其进行排序。排序方法。 回到上一节的reduce示例。我们已经发现，combiner函数只在并行中调用，而不是在顺序流中调用。让我们看看哪些线程真正涉及: List&lt;Person> persons = Arrays.asList( new Person(\"Max\", 18), new Person(\"Peter\", 23), new Person(\"Pamela\", 23), new Person(\"David\", 12)); persons .parallelStream() .reduce(0, (sum, p) -> &#123; System.out.format(\"accumulator: sum=%s; person=%s [%s]\\n\", sum, p, Thread.currentThread().getName()); return sum += p.age; &#125;, (sum1, sum2) -> &#123; System.out.format(\"combiner: sum1=%s; sum2=%s [%s]\\n\", sum1, sum2, Thread.currentThread().getName()); return sum1 + sum2; &#125;); 控制台输出显示累加器和组合器函数在所有可用线程上并行执行: accumulator: sum=0; person=Pamela; [main] accumulator: sum=0; person=Max; [ForkJoinPool.commonPool-worker-3] accumulator: sum=0; person=David; [ForkJoinPool.commonPool-worker-2] accumulator: sum=0; person=Peter; [ForkJoinPool.commonPool-worker-1] combiner: sum1=18; sum2=23; [ForkJoinPool.commonPool-worker-1] combiner: sum1=23; sum2=12; [ForkJoinPool.commonPool-worker-2] combiner: sum1=41; sum2=35; [ForkJoinPool.commonPool-worker-2] 总之，可以这样说，并行流可以为具有大量输入元素的流带来很好的性能提升。但是请记住，像reduce和collect这样的并行流操作需要额外的计算(合并操作)，这在顺序执行时是不需要的。 此外，我们还了解到所有并行流操作共享同一个jvm范围的公共ForkJoinPool。因此，您可能希望避免实现缓慢阻塞的流操作，因为这可能会降低应用程序中严重依赖并行流的其他部分的速度。","categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"}],"author":"sizaif"}],"categories":[{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"LTE","slug":"技术向/LTE","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/LTE/"},{"name":"Docker","slug":"技术向/Docker","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Docker/"},{"name":"游戏向","slug":"游戏向","permalink":"https://www.sizaif.com/navigation/categories/%E6%B8%B8%E6%88%8F%E5%90%91/"},{"name":"TSW2","slug":"游戏向/TSW2","permalink":"https://www.sizaif.com/navigation/categories/%E6%B8%B8%E6%88%8F%E5%90%91/TSW2/"},{"name":"Win","slug":"技术向/Win","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Win/"},{"name":"Hexo","slug":"技术向/Hexo","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Hexo/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.sizaif.com/navigation/categories/%E6%9D%82%E8%B0%88/"},{"name":"Mybatis","slug":"技术向/Mybatis","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mybatis/"},{"name":"杂项","slug":"技术向/杂项","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9D%82%E9%A1%B9/"},{"name":"图床","slug":"技术向/图床","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E5%9B%BE%E5%BA%8A/"},{"name":"Microsoft SEAL","slug":"技术向/Microsoft-SEAL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Microsoft-SEAL/"},{"name":"Js","slug":"技术向/Js","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Js/"},{"name":"Java","slug":"技术向/Java","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Java/"},{"name":"Linux","slug":"技术向/Linux","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Linux/"},{"name":"Springboot","slug":"技术向/Springboot","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Springboot/"},{"name":"算法","slug":"技术向/算法","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"技术向/C","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/C/"},{"name":"路由器","slug":"技术向/路由器","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"机器学习","slug":"技术向/机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"VS2019","slug":"技术向/VS2019","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/VS2019/"},{"name":"Tensorflow","slug":"机器学习/Tensorflow","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/"},{"name":"OpenCV","slug":"机器学习/OpenCV","permalink":"https://www.sizaif.com/navigation/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/OpenCV/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSL","slug":"笔记/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/SSL/"},{"name":"SSL","slug":"技术向/SSL","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/SSL/"},{"name":"Mysql","slug":"技术向/Mysql","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Mysql/"},{"name":"JAXB","slug":"笔记/JAXB","permalink":"https://www.sizaif.com/navigation/categories/%E7%AC%94%E8%AE%B0/JAXB/"},{"name":"Git","slug":"技术向/Git","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Git/"},{"name":"Python","slug":"技术向/Python","permalink":"https://www.sizaif.com/navigation/categories/%E6%8A%80%E6%9C%AF%E5%90%91/Python/"},{"name":"项目","slug":"项目","permalink":"https://www.sizaif.com/navigation/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"建站笔记","slug":"建站笔记","permalink":"https://www.sizaif.com/navigation/categories/%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/"},{"name":"杂文","slug":"杂文","permalink":"https://www.sizaif.com/navigation/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"LTE","slug":"LTE","permalink":"https://www.sizaif.com/tags/LTE/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://www.sizaif.com/tags/Wireshark/"},{"name":"ASN.1","slug":"ASN-1","permalink":"https://www.sizaif.com/tags/ASN-1/"},{"name":"标签二","slug":"标签二","permalink":"https://www.sizaif.com/tags/%E6%A0%87%E7%AD%BE%E4%BA%8C/"},{"name":"Docker","slug":"Docker","permalink":"https://www.sizaif.com/tags/Docker/"},{"name":"TSW2","slug":"TSW2","permalink":"https://www.sizaif.com/tags/TSW2/"},{"name":"Win","slug":"Win","permalink":"https://www.sizaif.com/tags/Win/"},{"name":"脚本格式","slug":"脚本格式","permalink":"https://www.sizaif.com/tags/%E8%84%9A%E6%9C%AC%E6%A0%BC%E5%BC%8F/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.sizaif.com/tags/Hexo/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.sizaif.com/tags/%E6%9D%82%E8%B0%88/"},{"name":"Java","slug":"Java","permalink":"https://www.sizaif.com/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.sizaif.com/tags/Mybatis/"},{"name":"图床","slug":"图床","permalink":"https://www.sizaif.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Waline","slug":"Waline","permalink":"https://www.sizaif.com/tags/Waline/"},{"name":"PicGo","slug":"PicGo","permalink":"https://www.sizaif.com/tags/PicGo/"},{"name":"Gitee","slug":"Gitee","permalink":"https://www.sizaif.com/tags/Gitee/"},{"name":"Seal","slug":"Seal","permalink":"https://www.sizaif.com/tags/Seal/"},{"name":"同态加密","slug":"同态加密","permalink":"https://www.sizaif.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"},{"name":"Js","slug":"Js","permalink":"https://www.sizaif.com/tags/Js/"},{"name":"Layui","slug":"Layui","permalink":"https://www.sizaif.com/tags/Layui/"},{"name":"Jdk","slug":"Jdk","permalink":"https://www.sizaif.com/tags/Jdk/"},{"name":"Linux","slug":"Linux","permalink":"https://www.sizaif.com/tags/Linux/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.sizaif.com/tags/Springboot/"},{"name":"C++","slug":"C","permalink":"https://www.sizaif.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://www.sizaif.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"路由器","slug":"路由器","permalink":"https://www.sizaif.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"Hyper-v","slug":"Hyper-v","permalink":"https://www.sizaif.com/tags/Hyper-v/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.sizaif.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.sizaif.com/tags/Tensorflow/"},{"name":"VS2019","slug":"VS2019","permalink":"https://www.sizaif.com/tags/VS2019/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.sizaif.com/tags/OpenCV/"},{"name":"SSL","slug":"SSL","permalink":"https://www.sizaif.com/tags/SSL/"},{"name":"笔记","slug":"笔记","permalink":"https://www.sizaif.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://www.sizaif.com/tags/OpenSSL/"},{"name":"GnuTLS","slug":"GnuTLS","permalink":"https://www.sizaif.com/tags/GnuTLS/"},{"name":"WolfSSL","slug":"WolfSSL","permalink":"https://www.sizaif.com/tags/WolfSSL/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.sizaif.com/tags/Mysql/"},{"name":"教程","slug":"教程","permalink":"https://www.sizaif.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"技术向","slug":"技术向","permalink":"https://www.sizaif.com/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"Xml","slug":"Xml","permalink":"https://www.sizaif.com/tags/Xml/"},{"name":"JAXB","slug":"JAXB","permalink":"https://www.sizaif.com/tags/JAXB/"},{"name":"IDEA","slug":"IDEA","permalink":"https://www.sizaif.com/tags/IDEA/"},{"name":"Git","slug":"Git","permalink":"https://www.sizaif.com/tags/Git/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.sizaif.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"脚本","slug":"脚本","permalink":"https://www.sizaif.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Python","slug":"Python","permalink":"https://www.sizaif.com/tags/Python/"},{"name":"github计划","slug":"github计划","permalink":"https://www.sizaif.com/tags/github%E8%AE%A1%E5%88%92/"},{"name":"网站","slug":"网站","permalink":"https://www.sizaif.com/tags/%E7%BD%91%E7%AB%99/"}]}